// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export namespace Aom {
    export interface AlarmRuleDimension {
        /**
         * Specifies the dimension name. Changing this creates a new resource.
         */
        name: string;
        /**
         * Specifies the dimension value. Changing this creates a new resource.
         */
        value: string;
    }

    export interface ServiceDiscoveryRuleDiscoveryRule {
        /**
         * Specifies the matched value. This is a list of strings.
         */
        checkContents: string[];
        /**
         * Specifies the match condition. The values can be **contain** and **equals**.
         */
        checkMode: string;
        /**
         * Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
         */
        checkType: string;
    }

    export interface ServiceDiscoveryRuleLogPathRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of `nameType` is
         * **cmdLineHash**.
         */
        values: string[];
    }

    export interface ServiceDiscoveryRuleNameRules {
        /**
         * Specifies the application name rule. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
         * the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"], indicating that
         * the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the format of
         * ["fix"], indicating that the application name is suffixed with fix. If the value of `nameType` is **cmdLineHash**,
         * `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
         * ser when the startup command is 0001. The object structure is documented below.
         */
        applicationNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesApplicationNameRule[];
        /**
         * Specifies the service name rule. If there are multiple objects in the array,
         * the character strings extracted from these objects constitute the service name. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
         * in the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"],
         * indicating that the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the
         * format of ["fix"], indicating that the service name is suffixed with fix. If the value of `nameType` is
         * **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
         * service name is ser when the startup command is 0001. The object structure is
         * documented below.
         */
        serviceNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesServiceNameRule[];
    }

    export interface ServiceDiscoveryRuleNameRulesApplicationNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of `nameType` is
         * **cmdLineHash**.
         */
        values?: string[];
    }

    export interface ServiceDiscoveryRuleNameRulesServiceNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of `nameType` is
         * **cmdLineHash**.
         */
        values?: string[];
    }

}

export namespace As {
    export interface BandwidthPolicyScalingPolicyAction {
        /**
         * Specifies the operation restrictions.
         * - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
         * - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
         * - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
         */
        limits: number;
        /**
         * Specifies the operation to be performed. The default operation is ADD.
         * The options are as follows:
         * - **ADD**: indicates adding the bandwidth size.
         * - **REDUCE**: indicates reducing the bandwidth size.
         * - **SET**: indicates setting the bandwidth size to a specified value.
         */
        operation: string;
        /**
         * Specifies the bandwidth (Mbit/s).
         * The value is an integer from 1 to 2000. The default value is 1.
         */
        size: number;
    }

    export interface BandwidthPolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically.
         * The time format complies with UTC. This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered.
         * The time format complies with UTC.
         * - If scalingPolicyType is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
         * - If scalingPolicyType is set to RECURRENCE, the time format is hh:mm.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE. The options are as follows:
         * - **Daily**: indicates that the scaling action is triggered once a day.
         * - **Weekly**: indicates that the scaling action is triggered once a week.
         * - **Monthly**: indicates that the scaling action is triggered once a month.
         */
        recurrenceType: string;
        /**
         * Specifies the day when a periodic scaling action is triggered.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * - If recurrenceType is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
         * - If recurrenceType is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
         * The digits refer to dates in each week and separated by a comma, such as 1,3,5.
         * - If recurrenceType is set to Monthly, the value ranges from 1 to 31.
         * The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically.
         * The time format complies with UTC. The default value is the local time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime: string;
    }

    export interface ConfigurationInstanceConfig {
        /**
         * Specifies the initial login password of the administrator account for
         * logging in to an ECS using password authentication. The Windows administrator is `Administrator`.
         */
        adminPass?: string;
        /**
         * Specifies the bandwidth billing type.
         * Changing this creates a new resource. The valid values are as follows:
         * + **bandwidth**: Billing by bandwidth.
         * + **traffic**: Billing by traffic.
         */
        chargingMode?: string;
        /**
         * Specifies the ID of the DEH.
         * Changing this will create a new resource.
         */
        dedicatedHostId: string;
        /**
         * Specifies the disk group information. System disks are mandatory and
         * data disks are optional. The disk structure is documented below.
         * Changing this will create a new resource.
         */
        disks: outputs.As.ConfigurationInstanceConfigDisk[];
        /**
         * Specifies the ECS group ID. Changing this will create a new resource.
         */
        ecsGroupId: string;
        /**
         * Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
         * Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the priority policy used when there are multiple flavors
         * and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
         */
        flavorPriorityPolicy: string;
        /**
         * Specifies the ECS image ID. Changing this will create a new resource.
         */
        image: string;
        /**
         * Specifies the ECS instance ID when using its specification
         * as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `securityGroupIds`, `tenancy`
         * and `dedicatedHostId` arguments do not take effect.
         * If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
         * Changing this will create a new resource.
         */
        instanceId: string;
        /**
         * Specifies the name of the SSH key pair used to log in to the instance.
         * Changing this will create a new resource.
         */
        keyName: string;
        /**
         * Specifies the key/value pairs to make available from within the instance.
         * Changing this will create a new resource.
         */
        metadata?: {[key: string]: string};
        /**
         * Specifies the customize personality of an instance by defining one or
         * more files and their contents. The personality structure is documented below.
         * Changing this will create a new resource.
         */
        personalities: outputs.As.ConfigurationInstanceConfigPersonality[];
        /**
         * Specifies the EIP of the ECS instance.
         * The publicIp structure is documented below.
         * Changing this will create a new resource.
         */
        publicIp: outputs.As.ConfigurationInstanceConfigPublicIp;
        /**
         * Specifies an array of one or more security group IDs.
         * Changing this will create a new resource.
         */
        securityGroupIds: string[];
        /**
         * Configure this field to **dedicated** to create ECS instances on DeHs.
         * Before configuring this field, prepare DeHs. Changing this will create a new resource.
         */
        tenancy: string;
        /**
         * Specifies the user data to be injected during the ECS creation process.
         * Changing this will create a new resource. For more information, see
         * [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).
         */
        userData?: string;
    }

    export interface ConfigurationInstanceConfigDisk {
        /**
         * Specifies the ID of a data disk image used to export data disks of
         * an ECS.
         */
        dataDiskImageId: string;
        /**
         * Specifies a DSS device ID for creating an ECS disk.
         */
        dedicatedStorageId: string;
        /**
         * Specifies whether the disk is a system disk or a data disk.
         * Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
         * Changing this will create a new resource.
         */
        diskType: string;
        /**
         * Specifies the IOPS configured for an EVS disk.
         * Changing this will create a new resource.
         */
        iops: number;
        /**
         * Specifies the encryption KMS ID of the **DATA** disk.
         * Changing this will create a new resource.
         */
        kmsId: string;
        /**
         * Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
         * is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
         * Changing this creates a new resource.
         */
        size: number;
        /**
         * Specifies the disk backup snapshot ID for restoring the system disk and
         * data disks using a full-ECS backup when a full-ECS image is used.
         */
        snapshotId: string;
        /**
         * Specifies the throughput of an EVS disk. The unit is MiB/s.
         * Changing this will create a new resource.
         */
        throughput: number;
        /**
         * Specifies the disk type. Changing this will create a new resource.
         * Available options are:
         * + **SSD**: The ultra-high I/O type.
         * + **SAS**: The high I/O EVS type.
         * + **SATA**: The common I/O type.
         * + **GPSSD**: The general purpose SSD type.
         * + **ESSD**: The extreme SSD type.
         * + **GPSSD2**: The general purpose SSD V2 type.
         * + **ESSD2**: The extreme SSD V2 type.
         */
        volumeType: string;
    }

    export interface ConfigurationInstanceConfigPersonality {
        /**
         * Specifies the content of the injected file, which must be encoded with base64.
         * Changing this creates a new resource.
         */
        content: string;
        /**
         * Specifies the path of the injected file. Changing this creates a new resource.
         * + For Linux OSs, specify the path, for example, **&#47;etc/foo.txt**, for storing the injected file.
         * + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
         * the file name, for example, **foo**. The file name contains only letters and digits.
         */
        path: string;
    }

    export interface ConfigurationInstanceConfigPublicIp {
        /**
         * Specifies the EIP configuration that will be automatically assigned to the instance.
         * The object structure is documented below. Changing this will create a new resource.
         */
        eip: outputs.As.ConfigurationInstanceConfigPublicIpEip;
    }

    export interface ConfigurationInstanceConfigPublicIpEip {
        /**
         * Specifies the bandwidth information. The object structure is documented below.
         * Changing this will create a new resource.
         */
        bandwidth: outputs.As.ConfigurationInstanceConfigPublicIpEipBandwidth;
        /**
         * Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
         * and **5_sbgp** (static BGP). Changing this will create a new resource.
         */
        ipType: string;
    }

    export interface ConfigurationInstanceConfigPublicIpEipBandwidth {
        /**
         * Specifies the bandwidth billing type.
         * Changing this creates a new resource. The valid values are as follows:
         * + **bandwidth**: Billing by bandwidth.
         * + **traffic**: Billing by traffic.
         */
        chargingMode: string;
        /**
         * Specifies the ID of the shared bandwidth.
         * Changing this will create a new resource.
         */
        id: string;
        /**
         * Specifies the bandwidth sharing type.
         * The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
         * Changing this will create a new resource.
         */
        shareType: string;
        /**
         * Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
         * is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
         * Changing this creates a new resource.
         */
        size: number;
    }

    export interface GroupLbaasListener {
        /**
         * Specifies the backend ECS group ID.
         */
        poolId: string;
        /**
         * Specifies the backend protocol, which is the port on which a backend ECS listens for
         * traffic. The number of the port ranges from `1` to `65,535`.
         */
        protocolPort: number;
        /**
         * Specifies the version of instance IP addresses to be associated with the
         * load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.
         */
        protocolVersion: string;
        /**
         * Specifies the weight, which determines the portion of requests a backend ECS processes
         * compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
         * Defaults to `1`.
         */
        weight?: number;
    }

    export interface GroupNetwork {
        /**
         * Specifies the ID of the security group.
         */
        id: string;
        /**
         * Specifies the ID of the shared bandwidth of an IPv6 address.
         */
        ipv6BandwidthId?: string;
        /**
         * Specifies whether to support IPv6 addresses. Defaults to **false**.
         */
        ipv6Enable?: boolean;
        /**
         * Specifies whether process only traffic that is destined specifically
         * for it. Defaults to **true**.
         */
        sourceDestCheck?: boolean;
    }

    export interface GroupSecurityGroup {
        /**
         * Specifies the ID of the security group.
         */
        id: string;
    }

    export interface PolicyScalingPolicyAction {
        /**
         * Specifies the number of instances to be operated.
         */
        instanceNumber: number;
        /**
         * Specifies the percentage of instances to be operated.
         */
        instancePercentage?: number;
        /**
         * Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
         * and `SET`.
         */
        operation: string;
    }

    export interface PolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically. The time format complies
         * with UTC. This argument is mandatory when `scalingPolicyType`
         * is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered.
         * + If `scalingPolicyType` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
         * + If `scalingPolicyType` is set to `RECURRENCE`, the time format is **hh:mm**.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type. This argument is mandatory when
         * `scalingPolicyType` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
         */
        recurrenceType: string;
        /**
         * Specifies the frequency at which scaling actions are triggered.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically. The time format
         * complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime: string;
    }

}

export namespace Bcs {
    export interface InstanceBlockInfo {
        /**
         * Specifies the volume of the block, the unit is MB. The default value is 2.
         * Changing this creates a new instance.
         */
        blockSize?: number;
        /**
         * Specifies the block generation time, the unit is second. The default
         * value is 2. Changing this creates a new instance.
         */
        generationInterval?: number;
        /**
         * Specifies the number of transactions included in the block. The
         * default value is 500. Changing this creates a new instance.
         */
        transactionQuantity?: number;
    }

    export interface InstanceChannel {
        /**
         * Specifies the name of the channel. Changing this creates a new instance.
         */
        name: string;
        /**
         * Specifies the name of the peer organization. Changing this creates a new
         * instance.
         */
        orgNames: string[];
    }

    export interface InstanceCouchdb {
        /**
         * Specifies the password of the couch database. The password consists of 8 to
         * 26 characters and must consist at least three of following: uppercase letters, lowercase letters, digits, special
         * characters(!@$%^-_=+[{}]:,./?). Changing this creates a new instance.
         */
        password: string;
        /**
         * Specifies the user name of the couch database. Changing this creates a new
         * instance.
         */
        userName: string;
    }

    export interface InstanceKafka {
        /**
         * Specifies the availability zone in which to create the kafka. The
         * list must contain one or more than three availability zone. Please
         * following [reference](https://developer.huaweicloud.com/en-us/endpoint/?all) for the values. Changing this creates a
         * new instance.
         */
        availabilityZones: string[];
        /**
         * Specifies the kafka flavor type. Changing this creates a new instance.
         * + `c3.mini` : Mini type, the reference bandwidth is 100MB/s.
         * + `c3.small.2` : Small type, the reference bandwidth is 300MB/s.
         * + `c3.middle.2` : Middle type, the reference bandwidth is 600MB/s.
         * + `c3.high.2` : High type, the reference bandwidth is 1200MB/s.
         */
        flavor: string;
        /**
         * Specifies the name of the channel. Changing this creates a new instance.
         */
        name: string;
        /**
         * Specifies the kafka storage capacity. The storage capacity must be an
         * integral multiple of 100 and the maximum is 90000GB. Changing this creates a new instance.
         * + The minimum storage capacity of mini type is 600GB.
         * + The minimum storage capacity of small type is 1200GB.
         * + The minimum storage capacity of middle type is 2400GB.
         * + The minimum storage capacity of high type is 4800GB.
         */
        storageSize: number;
    }

    export interface InstancePeerOrg {
        addresses: outputs.Bcs.InstancePeerOrgAddress[];
        /**
         * Specifies the number of peers in organization. Changing this creates a new
         * instance.
         */
        count: number;
        /**
         * Specifies the name of the peer organization. Changing this creates a new
         * instance.
         */
        orgName: string;
        pvcName: string;
        /**
         * The status of the BCS instance.
         */
        status: string;
        statusDetail: string;
    }

    export interface InstancePeerOrgAddress {
        domainPort: string;
        ipPort: string;
    }

    export interface InstanceSfsTurbo {
        /**
         * Specifies the availability zone in which to create the kafka. The
         * list must contain one or more than three availability zone. Please
         * following [reference](https://developer.huaweicloud.com/en-us/endpoint/?all) for the values. Changing this creates a
         * new instance.
         */
        availabilityZone?: string;
        /**
         * Specifies the kafka flavor type. Changing this creates a new instance.
         * + `c3.mini` : Mini type, the reference bandwidth is 100MB/s.
         * + `c3.small.2` : Small type, the reference bandwidth is 300MB/s.
         * + `c3.middle.2` : Middle type, the reference bandwidth is 600MB/s.
         * + `c3.high.2` : High type, the reference bandwidth is 1200MB/s.
         */
        flavor?: string;
        /**
         * Specifies the share type of the SFS turbo. Changing this creates a new
         * instance.
         */
        shareType: string;
        /**
         * Specifies the type of SFS turbo. Changing this creates a new instance.
         */
        type?: string;
    }

}

export namespace Bms {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the CPU architecture of the BMS flavor.
         * The value can be x8664 and aarch64, defaults to **x86_64**.
         */
        cpuArch: string;
        /**
         * The id or name of the BMS flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the BMS flavor.
         */
        memory: number;
        /**
         * The operation status of the BMS flavor in an each AZs.
         */
        operation: string;
        /**
         * Specifies the number of vCPUs in the BMS flavor.
         */
        vcpus: number;
    }

    export interface InstanceDataDisk {
        /**
         * Specifies the data disk size, in GB. The value ranges form 10 to 32768. Changing
         * this creates a new instance.
         */
        size: number;
        /**
         * Specifies the BMS data disk type, which must be one of available disk types,
         * contains of *SSD*, *GPSSD* and *SAS*. Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceNic {
        /**
         * Specifies a fixed IPv4 address to be used on this network.
         */
        ipAddress: string;
        /**
         * The MAC address of the nic.
         */
        macAddress: string;
        /**
         * The port ID corresponding to the IP address.
         */
        portId: string;
        /**
         * Specifies the ID of subnet to attach to the instance.
         */
        subnetId: string;
    }

}

export namespace Cbr {
    export interface GetVaultsVault {
        /**
         * The allocated capacity of the vault, in GB.
         */
        allocated: number;
        /**
         * Whether automatic association is enabled. Defaults to **false**.
         */
        autoBind: boolean;
        /**
         * Specifies whether to enable automatic expansion of the backup protection
         * type vault. Defaults to **false**.
         */
        autoExpandEnabled: boolean;
        /**
         * The tags to filter resources for automatic association with **auto_bind**.
         */
        bindRules: {[key: string]: string};
        /**
         * Specifies the consistent level (specification) of the vault.
         * The valid values are as follows:
         * + **[crashConsistent](https://support.huaweicloud.com/intl/en-us/usermanual-cbr/cbr_03_0109.html)**
         * + **[appConsistent](https://support.huaweicloud.com/intl/en-us/usermanual-cbr/cbr_03_0109.html)**
         */
        consistentLevel: string;
        /**
         * Specifies the ID of the enterprise project to which the vault belongs.
         */
        enterpriseProjectId: string;
        /**
         * The vault ID in UUID format.
         */
        id: string;
        /**
         * Specifies the vault name. This parameter can contain a maximum of 64
         * characters, which may consist of letters, digits, underscores(_) and hyphens (-).
         */
        name: string;
        /**
         * Specifies the ID of the policy associated with the vault.
         * The `policyId` cannot be used with the vault of replicate protection type.
         */
        policyId: string;
        /**
         * Specifies the protection type of the vault.
         * The valid values are **backup** and **replication**. Vaults of type **disk** don't support **replication**.
         */
        protectionType: string;
        /**
         * The array of one or more resources to attach to the vault.
         * The object structure is documented below.
         */
        resources: outputs.Cbr.GetVaultsVaultResource[];
        /**
         * Specifies the vault capacity, in GB. The valid value range is `1` to `10,485,760`.
         */
        size: number;
        /**
         * The specification code.
         */
        specCode: string;
        /**
         * Specifies the vault status, including **available**, **lock**, **frozen** and **error**.
         */
        status: string;
        /**
         * The name of the bucket for the vault.
         */
        storage: string;
        /**
         * The key/value pairs to associate with the vault.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the object type of the vault. The valid values are as follows:
         * + **server** (Cloud Servers)
         * + **disk** (EVS Disks)
         * + **turbo** (SFS Turbo file systems)
         */
        type: string;
        /**
         * The used capacity, in GB.
         */
        used: number;
    }

    export interface GetVaultsVaultResource {
        /**
         * The array of disk IDs which will be excluded in the backup.
         */
        excludes: string[];
        /**
         * The array of disk or SFS file system IDs which will be included in the backup.
         */
        includes: string[];
        /**
         * The ID of the ECS instance to be backed up.
         */
        serverId: string;
    }

    export interface PolicyBackupCycle {
        /**
         * Specifies the weekly backup day of backup schedule.  
         * It supports seven days a week (MO, TU, WE, TH, FR, SA, SU) and this parameter is separated by a comma (,) without
         * spaces, between date and date during the configuration.
         */
        days?: string;
        /**
         * Specifies the backup time. Automated backups will be triggered at the backup
         * time. The current time is in the UTC format (HH:MM). The minutes in the list must be set to **00** and the hours
         * cannot be repeated. In the replication policy, you are advised to set one time point for one day.
         */
        executionTimes: string[];
        /**
         * Specifies the interval (in days) of backup schedule.  
         * The valid value ranges from `1` to `30`.
         */
        interval?: number;
    }

    export interface PolicyLongTermRetention {
        /**
         * - Specifies the latest backup of each day is saved in the long term.
         */
        daily?: number;
        /**
         * Specifies how often (after how many incremental backups) a full backup is
         * performed. The valid value ranges from `-1` to `100`.
         * If `-1` is specified, full backup will not be performed.
         */
        fullBackupInterval?: number;
        /**
         * - Specifies the latest backup of each month is saved in the long term.
         */
        monthly?: number;
        /**
         * - Specifies the latest backup of each week is saved in the long term.
         */
        weekly?: number;
        /**
         * - Specifies the latest backup of each year is saved in the long term.
         */
        yearly?: number;
    }

    export interface VaultPolicy {
        /**
         * Specifies the ID of destination vault to which the replication policy
         * will associated.
         */
        destinationVaultId?: string;
        /**
         * Specifies the policy ID.
         */
        id: string;
    }

    export interface VaultResource {
        /**
         * Specifies the array of disk IDs which will be excluded in the backup.
         * Only **server** vault support this parameter.
         */
        excludes: string[];
        /**
         * Specifies the array of disk or SFS file system IDs which will be included in the backup.
         * Only **disk** and **turbo** vault support this parameter.
         */
        includes: string[];
        /**
         * Specifies the ID of the ECS instance to be backed up.
         */
        serverId?: string;
    }

}

export namespace Cce {
    export interface AddonValues {
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `basicJson`, but it is not recommended.
         */
        basic?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         */
        basicJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `customJson`, but it is not recommended.
         */
        custom?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         */
        customJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `flavorJson`, but it is not recommended.
         */
        flavor?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         */
        flavorJson?: string;
    }

    export interface ClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the component name.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface ClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the component name.
         */
        name: string;
    }

    export interface ClusterComponentConfiguration {
        /**
         * Specifies JSON string of the component configurations.
         */
        configurations?: string;
        /**
         * Specifies the component name.
         */
        name: string;
    }

    export interface ClusterExtendParam {
        /**
         * Specifies the AZ of master nodes in the cluster. The value can be:
         * + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
         * + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
         * This parameter is mandatory for dedicated CCE clusters.
         */
        clusterAz?: string;
        /**
         * Specifies the cluster CPU management policy.
         * The value can be:
         * + **none**: CPU cores will not be exclusively allocated to workload pods.
         * Select this value if you want a large pool of shareable CPU cores.
         * + **static**: CPU cores can be exclusively allocated to workload pods.
         * Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
         * this setting is valid only for nodes where common containers, not Kata containers, run.
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the specifications of the master node
         * in the dedicated hybrid cluster.
         * Changing this parameter will create a new cluster resource.
         */
        decMasterFlavor?: string;
        /**
         * Specifies the default UmaskMode configuration of Docker in a
         * cluster. The value can be **secure** or **normal**, defaults to normal.
         * Changing this parameter will create a new cluster resource.
         */
        dockerUmaskMode?: string;
        /**
         * Specifies whether the system and data disks of a master node
         * use dedicated distributed storage. If left unspecified, EVS disks are used by default.
         * This parameter is mandatory for dedicated CCE clusters.
         * It is in the following format:
         */
        dssMasterVolumes?: string;
        /**
         * Specifies the number of mask bits of the fixed IP address pool
         * of the container network model. This field can only be used when `containerNetworkType` is set to **vpc-router**.
         * Changing this parameter will create a new cluster resource.
         */
        fixPoolMask?: string;
    }

    export interface ClusterLogConfigLogConfig {
        /**
         * Specifies whether to collect the log.
         */
        enable?: boolean;
        /**
         * Specifies the log type.
         */
        name?: string;
    }

    export interface ClusterMaster {
        /**
         * Specifies the availability zone of the master node.
         * Changing this parameter will create a new cluster resource.
         */
        availabilityZone: string;
    }

    export interface ClusterUpgradeAddon {
        /**
         * Specifies the add-on name.
         */
        addonTemplateName: string;
        /**
         * Specifies the execution action.
         * For current upgrades, the value can be **patch**.
         */
        operation: string;
        /**
         * Specifies the add-on template installation parameters.
         * These parameters vary depending on the add-on. The values is documented below.
         */
        values?: outputs.Cce.ClusterUpgradeAddonValues;
        /**
         * Specifies the target add-on version.
         * The target add-on version must match the target cluster version.
         */
        version: string;
    }

    export interface ClusterUpgradeAddonValues {
        /**
         * Specifies the json string vary depending on the add-on.
         */
        basicJson?: string;
        /**
         * Specifies the json string vary depending on the add-on.
         */
        customJson?: string;
        /**
         * Specifies the json string vary depending on the add-on.
         */
        flavorJson?: string;
    }

    export interface ClusterUpgradeStrategy {
        /**
         * Specifies the in-place upgrade settings.
         * It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
         * The inPlaceRollingUpdate structure is documented below.
         */
        inPlaceRollingUpdate?: outputs.Cce.ClusterUpgradeStrategyInPlaceRollingUpdate;
        /**
         * Specifies the upgrade strategy type.
         * The value can be **inPlaceRollingUpdate**.
         */
        type: string;
    }

    export interface ClusterUpgradeStrategyInPlaceRollingUpdate {
        /**
         * Specifies the node upgrade step.
         * The value ranges from **1** to **40**. The recommended value is **20**.
         */
        userDefinedStep?: number;
    }

    export interface GetAddonTemplateSupportVersion {
        /**
         * The cluster (Bare Metal) version that the add-on template supported.
         */
        bareMetals: string[];
        /**
         * The cluster (Virtual Machine) version that the add-on template supported.
         */
        virtualMachines: string[];
    }

    export interface GetAddonsItem {
        /**
         * The metadata of the add-on instance.
         */
        metadatas: outputs.Cce.GetAddonsItemMetadata[];
        /**
         * The detailed description of the add-on instance.
         */
        specs: outputs.Cce.GetAddonsItemSpec[];
        /**
         * The statuses of add-on instances.
         */
        statuses: outputs.Cce.GetAddonsItemStatus[];
    }

    export interface GetAddonsItemMetadata {
        /**
         * The add-on instance alias.
         */
        alias: string;
        /**
         * The add-on annotations in the format of key/value pairs.
         */
        annotations: {[key: string]: string};
        /**
         * The creation time.
         */
        creationTimestamp: string;
        /**
         * The add-on labels in key/value pairs.
         */
        labels: {[key: string]: string};
        /**
         * The add-on instance name.
         */
        name: string;
        /**
         * The add-on instance ID.
         */
        uid: string;
        /**
         * The update time.
         */
        updateTimestamp: string;
    }

    export interface GetAddonsItemSpec {
        /**
         * The labels of the add-on template.
         */
        addonTemplateLabels: string[];
        /**
         * The URL for obtaining the add-on template logo.
         */
        addonTemplateLogo: string;
        /**
         * The add-on name.
         */
        addonTemplateName: string;
        /**
         * The add-on type.
         */
        addonTemplateType: string;
        /**
         * Specifies the ID of the cluster to which the add-on instance belongs.
         */
        clusterId: string;
        /**
         * The add-on description.
         */
        description: string;
        /**
         * The add-on installation parameters.
         */
        values: string[];
        /**
         * The add-on version.
         */
        version: string;
    }

    export interface GetAddonsItemStatus {
        /**
         * The cause of the add-on installation failure.
         */
        _reason: string;
        /**
         * The information about the current add-on version.
         */
        currentVersions: outputs.Cce.GetAddonsItemStatusCurrentVersion[];
        /**
         * Whether the add-on version can be rolled back to the source version.
         */
        isRollbackable: boolean;
        /**
         * The installation error details.
         */
        message: string;
        /**
         * The add-on version before upgrade or rollback
         */
        previousVersion: string;
        /**
         * The statuses of add-on instances.
         */
        status: string;
        /**
         * The versions to which the current add-on version can be upgraded.
         */
        targetVersions: string[];
    }

    export interface GetAddonsItemStatusCurrentVersion {
        /**
         * The creation time.
         */
        creationTimestamp: string;
        /**
         * The add-on installation parameters.
         */
        inputs: string[];
        /**
         * Whether the add-on version is a stable release.
         */
        stable: boolean;
        /**
         * The cluster versions that support the add-on.
         */
        supportVersions: outputs.Cce.GetAddonsItemStatusCurrentVersionSupportVersion[];
        /**
         * The translation information used by the GUI.
         */
        translates: string[];
        /**
         * The update time.
         */
        updateTimestamp: string;
        /**
         * The add-on version.
         */
        version: string;
    }

    export interface GetAddonsItemStatusCurrentVersionSupportVersion {
        /**
         * The current support version category.
         */
        categories: string[];
        /**
         * The cluster type that supports the add-on.
         */
        clusterType: string;
        /**
         * The cluster versions that support the add-on. The value is a regular expression.
         */
        clusterVersions: string[];
    }

    export interface GetChartsChart {
        /**
         * The chart URL.
         */
        chartUrl: string;
        /**
         * The create time.
         */
        createdAt: string;
        /**
         * The description of the chart.
         */
        description: string;
        /**
         * The icon URL.
         */
        iconUrl: string;
        /**
         * The chart ID.
         */
        id: string;
        /**
         * The instruction of the chart.
         */
        instruction: string;
        /**
         * The chart name.
         */
        name: string;
        /**
         * Whether the chart is public.
         */
        public: boolean;
        /**
         * The source of the chart.
         */
        source: string;
        /**
         * The traslate source of the chart.
         */
        translate: string;
        /**
         * The update time.
         */
        updatedAt: string;
        /**
         * The values of the chart.
         */
        values: string;
        /**
         * The chart version.
         */
        version: string;
    }

    export interface GetClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClusterCertificatesCluster {
        /**
         * The certificate authority data of the cluster certificate.
         */
        certificateAuthorityData: string;
        /**
         * Whether insecure skip tls verify of the cluster certificate.
         */
        insecureSkipTlsVerify: boolean;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
        /**
         * The server address of the cluster certificate.
         */
        server: string;
    }

    export interface GetClusterCertificatesContext {
        /**
         * The context cluster of the cluster certificate.
         */
        cluster: string;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
        /**
         * The context user of the cluster certificate.
         */
        user: string;
    }

    export interface GetClusterCertificatesUser {
        /**
         * The client certificate data of the cluster certificate.
         */
        clientCertificateData: string;
        /**
         * The client key data of the cluster certificate.
         */
        clientKeyData: string;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
    }

    export interface GetClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClusterMaster {
        /**
         * The availability zone (AZ) of the master node.
         */
        availabilityZone: string;
    }

    export interface GetClustersCluster {
        /**
         * The authentication mode of the cluster, possible values are x509 and rbac. Defaults to **rbac**.
         */
        authenticationMode: string;
        /**
         * The charging mode of the cluster.
         */
        billingMode: number;
        /**
         * The certificate clusters. Structure is documented below.
         */
        certificateClusters: outputs.Cce.GetClustersClusterCertificateCluster[];
        /**
         * The certificate users. Structure is documented below.
         */
        certificateUsers: outputs.Cce.GetClustersClusterCertificateUser[];
        /**
         * Specifies the type of the cluster. Possible values: **VirtualMachine**, **BareMetal**.
         */
        clusterType: string;
        /**
         * The version of the cluster.
         */
        clusterVersion: string;
        /**
         * The container network segment.
         */
        containerNetworkCidr: string;
        /**
         * The container network type: **overlay_l2** , **underlay_ipvlan**, **vpc-router** or **eni**.
         */
        containerNetworkType: string;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The access addresses of kube-apiserver in the cluster. Structure is documented below.
         */
        endpoints: outputs.Cce.GetClustersClusterEndpoint[];
        /**
         * The ENI network segment.
         */
        eniSubnetCidr: string;
        /**
         * The **IPv4 subnet ID** of the subnet where the ENI resides.
         */
        eniSubnetId: string;
        /**
         * Specifies the enterprise project ID of the cluster.
         */
        enterpriseProjectId: string;
        /**
         * The specification of the cluster.
         */
        flavorId: string;
        /**
         * The ID of the cluster.
         */
        id: string;
        /**
         * The raw Kubernetes config to be used by kubectl and other compatible tools.
         */
        kubeConfigRaw: string;
        /**
         * The advanced configuration of master nodes. Structure is documented below.
         */
        masters: outputs.Cce.GetClustersClusterMaster[];
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The security group ID of the cluster.
         */
        securityGroupId: string;
        /**
         * The service network segment.
         */
        serviceNetworkCidr: string;
        /**
         * Specifies the status of the cluster.
         */
        status: string;
        /**
         * The ID of the subnet used to create the node.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID to which the cluster belongs.
         */
        vpcId: string;
    }

    export interface GetClustersClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClustersClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClustersClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClustersClusterMaster {
        /**
         * The availability zone (AZ) of the master node.
         */
        availabilityZone: string;
    }

    export interface GetNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodeHostnameConfig {
        /**
         * The hostname type of the kubernetes node.
         */
        type: string;
    }

    export interface GetNodePoolDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodePoolHostnameConfig {
        /**
         * The hostname type of the kubernetes node.
         */
        type: string;
    }

    export interface GetNodePoolRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNode {
        /**
         * The available partitions where the node is located.
         */
        availabilityZone: string;
        /**
         * The node's billing mode: The value is 0 (on demand).
         */
        billingMode: number;
        /**
         * The data related configuration. Structure is documented below.
         */
        dataVolumes: outputs.Cce.GetNodesNodeDataVolume[];
        /**
         * The ID of ECS group to which the node belongs.
         */
        ecsGroupId: string;
        /**
         * The enterprise project ID of the node.
         */
        enterpriseProjectId: string;
        /**
         * The flavor ID to be used.
         */
        flavorId: string;
        /**
         * The hostname config of the kubernetes node.
         * The object structure is documented below.
         */
        hostnameConfigs: outputs.Cce.GetNodesNodeHostnameConfig[];
        /**
         * The ID of the node.
         */
        id: string;
        /**
         * The key pair name when logging in to select the key pair mode.
         */
        keyPair: string;
        /**
         * Specifies the of the node.
         */
        name: string;
        /**
         * The operating System of the node.
         */
        os: string;
        /**
         * The private IP of the node.
         */
        privateIp: string;
        /**
         * The elastic IP parameters of the node.
         */
        publicIp: string;
        /**
         * The system disk related configuration. Structure is documented below.
         */
        rootVolumes: outputs.Cce.GetNodesNodeRootVolume[];
        /**
         * The node's virtual machine ID in ECS.
         */
        serverId: string;
        /**
         * Specifies the status of the node.
         */
        status: string;
        /**
         * The ID of the subnet to which the NIC belongs.
         */
        subnetId: string;
        /**
         * The tags of a VM node, key/value pair format.
         */
        tags: {[key: string]: string};
    }

    export interface GetNodesNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNodeHostnameConfig {
        /**
         * The hostname type of the kubernetes node.
         */
        type: string;
    }

    export interface GetNodesNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface NodeAttachDataVolume {
        /**
         * The DSS pool ID. This field is used only for dedicated storage.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam: string;
        /**
         * The disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * The iops of the disk.
         */
        iops: number;
        /**
         * The ID of a KMS key. This is used to encrypt the volume.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will reset the node.
         */
        size: number;
        /**
         * The throughput of the disk.
         */
        throughput: number;
        /**
         * The disk type.
         */
        volumetype: string;
    }

    export interface NodeAttachHostnameConfig {
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type: string;
    }

    export interface NodeAttachRootVolume {
        /**
         * The DSS pool ID. This field is used only for dedicated storage.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam: string;
        /**
         * The disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * The iops of the disk.
         */
        iops: number;
        /**
         * The ID of a KMS key. This is used to encrypt the volume.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will reset the node.
         */
        size: number;
        /**
         * The throughput of the disk.
         */
        throughput: number;
        /**
         * The disk type.
         */
        volumetype: string;
    }

    export interface NodeAttachStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will reset the node.
         */
        groups: outputs.Cce.NodeAttachStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will reset the node.
         */
        selectors: outputs.Cce.NodeAttachStorageSelector[];
    }

    export interface NodeAttachStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will reset the node.
         */
        cceManaged?: boolean;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will reset the node.
         */
        name: string;
        /**
         * Specifies the list of names of selectors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will reset the node.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will reset the node.
         */
        virtualSpaces: outputs.Cce.NodeAttachStorageGroupVirtualSpace[];
    }

    export interface NodeAttachStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
         */
        lvmPath?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will reset the node.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will reset the node.
         */
        size: string;
    }

    export interface NodeAttachStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will reset the node.
         */
        matchLabelCount?: string;
        /**
         * Specifies the customer master key ID of an encrypted
         * disk. Changing this parameter will reset the node.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will reset the node.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will reset the node.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will reset the node.
         */
        name: string;
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type?: string;
    }

    export interface NodeAttachTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will reset the node.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will reset the node.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * reset the node.
         */
        value: string;
    }

    export interface NodeDataVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for
         * dedicated storage. Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the extended parameters.
         * The object structure is documented below.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         */
        throughput: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodeExtendParams {
        /**
         * Specifies the agency name.
         * Changing this parameter will create a new resource.
         */
        agencyName?: string;
        /**
         * Specifies the available disk space of a single container on a node,
         * in GB. Changing this parameter will create a new resource.
         */
        dockerBaseSize?: number;
        /**
         * Specifies the reserved node memory, which is reserved for
         * Kubernetes-related components. Changing this parameter will create a new resource.
         */
        kubeReservedMem?: number;
        marketType?: string;
        /**
         * Specifies the maximum number of instances a node is allowed to create.
         * Changing this parameter will create a new resource.
         */
        maxPods?: number;
        /**
         * Specifies the ENI pre-binding thresholds.
         * Example setting: **"0.3:0.6"**. Changing this parameter will create a new resource.
         */
        nicThreshold?: string;
        /**
         * Specifies the image ID to create the node.
         * Changing this parameter will create a new resource.
         */
        nodeImageId?: string;
        /**
         * Specifies the number of ENI queues.
         * Example setting: **"[{\"queue\":4}]"**. Changing this parameter will create a new resource.
         */
        nodeMultiQueue?: string;
        /**
         * Specifies the script to be executed after installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        postinstall?: string;
        /**
         * Specifies the script to be executed before installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        preinstall?: string;
        /**
         * Specifies the security reinforcement type.
         * The value can be: **null** or **cybersecurity**. Changing this parameter will create a new resource.
         */
        securityReinforcementType?: string;
        spotPrice?: string;
        /**
         * Specifies the reserved node memory, which is reserved
         * value for system components. Changing this parameter will create a new resource.
         */
        systemReservedMem?: number;
    }

    export interface NodeExtensionNic {
        /**
         * Specifies the ID of the subnet to which the NIC belongs.
         * Changing this parameter will create a new resource.
         */
        subnetId: string;
    }

    export interface NodeHostnameConfig {
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type: string;
    }

    export interface NodePoolDataVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for dedicated storage.
         * Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the KMS key ID. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         */
        throughput: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolExtendParams {
        /**
         * Specifies the agency name.
         * Changing this parameter will create a new resource.
         */
        agencyName?: string;
        /**
         * Specifies the available disk space of a single container on a node,
         * in GB. Changing this parameter will create a new resource.
         */
        dockerBaseSize?: number;
        /**
         * Specifies the reserved node memory, which is reserved for
         * Kubernetes-related components. Changing this parameter will create a new resource.
         */
        kubeReservedMem?: number;
        marketType?: string;
        /**
         * Specifies the maximum number of instances a node is allowed to create.
         * Changing this parameter will create a new resource.
         */
        maxPods?: number;
        /**
         * Specifies the ENI pre-binding thresholds.
         * Example setting: **"0.3:0.6"**. Changing this parameter will create a new resource.
         */
        nicThreshold?: string;
        /**
         * Specifies the image ID to create the node.
         * Changing this parameter will create a new resource.
         */
        nodeImageId?: string;
        /**
         * Specifies the number of ENI queues.
         * Example setting: **"[{\"queue\":4}]"**. Changing this parameter will create a new resource.
         */
        nodeMultiQueue?: string;
        /**
         * Specifies the script to be executed after installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        postinstall?: string;
        /**
         * Specifies the script to be executed before installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        preinstall?: string;
        /**
         * Specifies the security reinforcement type.
         * The value can be: **null** or **cybersecurity**. Changing this parameter will create a new resource.
         */
        securityReinforcementType?: string;
        spotPrice?: string;
        /**
         * Specifies the reserved node memory, which is reserved
         * value for system components. Changing this parameter will create a new resource.
         */
        systemReservedMem?: number;
    }

    export interface NodePoolExtensionScaleGroup {
        /**
         * Specifies the basic information about the extended scaling group.
         * The object structure is documented below.
         */
        metadata?: outputs.Cce.NodePoolExtensionScaleGroupMetadata;
        /**
         * Specifies the configurations of the extended scaling group,
         * which carry different configurations from those of the default scaling group.
         * The object structure is documented below.
         */
        spec?: outputs.Cce.NodePoolExtensionScaleGroupSpec;
    }

    export interface NodePoolExtensionScaleGroupMetadata {
        /**
         * Specifies the name of an extended scaling group.
         * The value cannot be default and can contain a maximum of 55 characters.
         * Only digits, lowercase letters, and hyphens (-) are allowed.
         */
        name?: string;
    }

    export interface NodePoolExtensionScaleGroupSpec {
        /**
         * Specifies the auto scaling configurations of the extended scaling group.
         * The object structure is documented below.
         */
        autoscaling?: outputs.Cce.NodePoolExtensionScaleGroupSpecAutoscaling;
        /**
         * Specifies the availability zone of a node.
         * If this parameter is not specified or left blank, the default scaling group configurations take effect.
         */
        az?: string;
        /**
         * Specifies the capacity reservation
         * configurations of the extended scaling group.
         * The object structure is documented below.
         */
        capacityReservationSpecification?: outputs.Cce.NodePoolExtensionScaleGroupSpecCapacityReservationSpecification;
        /**
         * Specifies the node flavor.
         */
        flavor?: string;
    }

    export interface NodePoolExtensionScaleGroupSpecAutoscaling {
        /**
         * Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
         */
        enable?: boolean;
        /**
         * Specifies the priority of the scaling group, defaults to **0**.
         * A higher value indicates a greater priority.
         */
        extensionPriority?: number;
        /**
         * Specifies the maximum number of nodes that can be retained in the scaling group
         * during auto scaling. The value must be greater than or equal to that of `minNodeCount`, and can neither be greater
         * than the maximum number of nodes allowed by the cluster nor the maximum number of nodes in the node pool.
         */
        maxNodeCount?: number;
        /**
         * Specifies the minimum number of nodes in the scaling group during auto scaling.
         * The value must be greater than **0**.
         */
        minNodeCount?: number;
    }

    export interface NodePoolExtensionScaleGroupSpecCapacityReservationSpecification {
        /**
         * Specifies the private pool ID.
         * The parameter value can be ignored when preference is set to none.
         */
        id?: string;
        /**
         * Specifies the capacity of a private storage pool. If the value is none,
         * the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
         * In this case, the `id` cannot be left blank.
         */
        preference?: string;
    }

    export interface NodePoolHostnameConfig {
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type: string;
    }

    export interface NodePoolNodesAddNodeList {
        /**
         * Specifies server ID.
         */
        serverId: string;
    }

    export interface NodePoolRootVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for dedicated storage.
         * Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the KMS key ID. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         */
        throughput: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        groups: outputs.Cce.NodePoolStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        selectors: outputs.Cce.NodePoolStorageSelector[];
    }

    export interface NodePoolStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will create a new resource.
         */
        cceManaged?: boolean;
        /**
         * Specifies the name of an extended scaling group.
         * The value cannot be default and can contain a maximum of 55 characters.
         * Only digits, lowercase letters, and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the list of names of selectors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will create a new resource.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will create a new resource.
         */
        virtualSpaces: outputs.Cce.NodePoolStorageGroupVirtualSpace[];
    }

    export interface NodePoolStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will create a new resource.
         */
        lvmPath?: string;
        /**
         * Specifies the name of an extended scaling group.
         * The value cannot be default and can contain a maximum of 55 characters.
         * Only digits, lowercase letters, and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will create a new resource.
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: string;
    }

    export interface NodePoolStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will create a new resource.
         */
        matchLabelCount?: string;
        /**
         * Specifies the customer master key ID of an encrypted
         * disk. Changing this parameter will create a new resource.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will create a new resource.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will create a new resource.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will create a new resource.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the name of an extended scaling group.
         * The value cannot be default and can contain a maximum of 55 characters.
         * Only digits, lowercase letters, and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type?: string;
    }

    export interface NodePoolTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
         * digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
         * prefix of a key.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63 characters,
         * including letters, digits, hyphens (-), underscores (_), and periods (.).
         */
        value: string;
    }

    export interface NodeRootVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for
         * dedicated storage. Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the extended parameters.
         * The object structure is documented below.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         */
        throughput: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodeStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        groups: outputs.Cce.NodeStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        selectors: outputs.Cce.NodeStorageSelector[];
    }

    export interface NodeStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will create a new resource.
         */
        cceManaged?: boolean;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the list of names of selectors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will create a new resource.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will create a new resource.
         */
        virtualSpaces: outputs.Cce.NodeStorageGroupVirtualSpace[];
    }

    export interface NodeStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will create a new resource.
         */
        lvmPath?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will create a new resource.
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: string;
    }

    export interface NodeStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will create a new resource.
         */
        matchLabelCount?: string;
        /**
         * Specifies the customer master key ID of an encrypted
         * disk. Changing this parameter will create a new resource.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will create a new resource.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will create a new resource.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will create a new resource.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the hostname type of the kubernetes node.
         * The value can be:
         * + **privateIp**: The Kubernetes node is named after its IP address.
         * + **cceNodeName**: The Kubernetes node is named after the CCE node.
         */
        type?: string;
    }

    export interface NodeTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will create a new resource.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will create a new resource.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * create a new resource.
         */
        value?: string;
    }
}

export namespace Cci {
    export interface GetNamespacesNamespace {
        /**
         * Whether elastic scheduling is enabled.
         */
        autoExpendEnabled: boolean;
        /**
         * Whether container network is enabled.
         */
        containerNetworkEnabled: boolean;
        /**
         * The time when the namespace was created in UTC format, such as **2021-09-27T01:30:39Z**.
         */
        createdAt: string;
        /**
         * Specifies the enterprise project ID in UUID format.
         */
        enterpriseProjectId: string;
        /**
         * The VPC ID in UUID format.
         */
        id: string;
        /**
         * Specifies th name of the specified CCI namespace.
         * This parameter can contain a maximum of 63 characters, which may consist of lowercase letters, digits and hyphens,
         * and must start and end with lowercase letters and digits.
         */
        name: string;
        /**
         * The network information of the CCI namespace. The structure is documented below.
         */
        networks: outputs.Cci.GetNamespacesNamespaceNetwork[];
        /**
         * Whether Role-based access control is enabled.
         * After the RBAC permission is enabled, the user's use of resources under the namespace will be controlled by the RBAC
         * permission.
         */
        rbacEnabled: boolean;
        /**
         * The IP address recycling interval in hour.
         * The idle IP resources from the elastic expansion of the IP resource pool can be recycled within this time.
         */
        recyclingInterval: number;
        /**
         * The CCI namespace status.
         */
        status: string;
        /**
         * Specifies the CCI namespace type.
         * The valid values are **general-computing** and **gpu-accelerated**.
         */
        type: string;
        /**
         * The size of IP pool to warm-up.
         */
        warmupPoolSize: number;
    }

    export interface GetNamespacesNamespaceNetwork {
        /**
         * Specifies th name of the specified CCI namespace.
         * This parameter can contain a maximum of 63 characters, which may consist of lowercase letters, digits and hyphens,
         * and must start and end with lowercase letters and digits.
         */
        name: string;
        /**
         * The default security group ID in UUID format.
         */
        securityGroupId: string;
        /**
         * The network information of the VPC under the CCI network. The structure is documented below.
         */
        vpcs: outputs.Cci.GetNamespacesNamespaceNetworkVpc[];
    }

    export interface GetNamespacesNamespaceNetworkVpc {
        /**
         * The VPC ID in UUID format.
         */
        id: string;
        /**
         * The network ID of the VPC subnet in UUID format.
         */
        networkId: string;
        /**
         * The subnet CIDR block.
         */
        subnetCidr: string;
        /**
         * The VPC subnet ID in UUID format.
         */
        subnetId: string;
    }

}

export namespace Cdm {
    export interface ClusterInstance {
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Management IP address.
         */
        manageIp: string;
        /**
         * Specifies cluster name. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Private IP.
         */
        privateIp: string;
        /**
         * Public IP.
         */
        publicIp: string;
        /**
         * Instance role.
         */
        role: string;
        /**
         * Traffic IP.
         */
        trafficIp: string;
        /**
         * Instance type.
         */
        type: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The numbers of CDM cluster vCPUs.
         */
        cpu: string;
        /**
         * The ID of the CDM flavor.
         */
        id: string;
        /**
         * The memory size in GB.
         */
        memory: string;
        /**
         * The name of the CDM flavor. Format is `cdm.<flavor_type>`.
         */
        name: string;
    }

    export interface JobConfig {
        /**
         * Specifies group to which a job belongs. The default group is `DEFAULT`.
         */
        groupName?: string;
        /**
         * Specifies whether to automatically retry if a job fails to be executed.
         * The options are as follows:
         * + **NONE**: Do not retry.
         * + **RETRY_TRIPLE**: Retry three times.
         */
        retryType?: string;
        /**
         * Specifies cycle of a scheduled task. If `schedulerCycleType` is set to minute
         * and `schedulerCycle` is set to 10, the scheduled task is executed every 10 minutes.
         */
        schedulerCycle?: number;
        /**
         * Specifies cycle type of a scheduled task. The options are as follows:
         * `minute`, `hour`, `day`, `week`, `month`.
         */
        schedulerCycleType?: string;
        /**
         * Specifies whether to delete a job after the job is executed.
         * The options are as follows:
         * + **NONE**: The job will not be deleted after it is executed.
         * + **DELETE_AFTER_SUCCEED**: The job will be deleted only after it is successfully executed. It is applicable to
         * massive one-time jobs.
         * + **DELETE**: The job will be deleted after it is executed, regardless of the execution result.
         */
        schedulerDisposableType?: string;
        /**
         * Specifies whether to enable a scheduled task.  Default value is `false`.
         */
        schedulerEnabled?: boolean;
        /**
         * Specifies time when a scheduled task is triggered in a cycle. This parameter
         * is valid only when `schedulerCycleType` is set to `hour`, `week`, or `month`.
         * + If `schedulerCycleType` is set to month, cycle is set to 1, and runAt is set to 15, the scheduled task is executed
         * on the 15th day of each month. You can set runAt to multiple values and separate the values with commas (,).
         * For example, if runAt is set to 1,2,3,4,5, the scheduled task is executed on the first day, second day, third day,
         * fourth day, and fifth day of each month.
         * + If `schedulerCycleType` is set to week and runAt is set to mon,tue,wed,thu,fri, the scheduled task is executed on
         * Monday to Friday.
         * + If `schedulerCycleType` is set to hour and runAt is set to 27,57, the scheduled task is executed at the 27th and
         * 57th minute in the cycle.
         */
        schedulerRunAt?: string;
        /**
         * Specifies start time of a scheduled task.
         * For example, `2018-01-24 19:56:19`
         */
        schedulerStartDate?: string;
        /**
         * Specifies End time of a scheduled task. For example, `2018-01-27 23:59:00`.
         * If you do not set the end time, the scheduled task is always executed and will never stop.
         */
        schedulerStopDate?: string;
        /**
         * Specifies name of the OBS bucket to which dirty data is
         * written. This parameter is valid only when dirty data is written to `OBS`.
         */
        throttlingDirtyWriteToBucket?: string;
        /**
         * Specifies the directory in the OBS bucket or HDFS which
         * dirty data is written to. For example, `/data/dirtydata/`.
         */
        throttlingDirtyWriteToDirectory?: string;
        /**
         * Specifies the link name to which dirty data is written to.
         * The Dirty data can be written only to `OBS` or `HDFS`.
         */
        throttlingDirtyWriteToLink?: string;
        /**
         * Specifies maximum number of concurrent extraction jobs.
         */
        throttlingExtractorsNumber?: number;
        /**
         * Specifies maximum number of loading jobs. This parameter is available
         * only when HBase or Hive serves as the destination data source.
         */
        throttlingLoaderNumber?: number;
        /**
         * Specifies maximum number of error records in a single
         * shard. When the number of error records of a map exceeds the upper limit, the task automatically ends.
         */
        throttlingMaxErrorRecords?: number;
        /**
         * Specifies whether to write dirty data.
         */
        throttlingRecordDirtyData?: boolean;
    }

}

export namespace Cdn {
    export interface DomainCacheSettings {
        /**
         * Specifies whether to enable origin cache control. Defaults to **false**.
         */
        followOrigin?: boolean;
        /**
         * Specifies the cache rules, which overwrite the previous rule configurations.
         * Blank rules are reset to default rules. The rules structure is documented below.
         */
        rules?: outputs.Cdn.DomainCacheSettingsRule[];
    }

    export interface DomainCacheSettingsRule {
        /**
         * Specifies the content that matches `ruleType`.
         * + If `ruleType` is set to **all** or **home_page**, keep this parameter empty.
         * + If `ruleType` is set to **file_extension**, the value of this parameter is a list of file name
         * extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
         * for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
         * + If `ruleType` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
         * a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
         * Up to 20 directories are supported.
         * + If `ruleType` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
         * Example: `/test/index.html` or `/test/*.jpg`
         */
        content?: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
        /**
         * Specifies the rule type. Possible value are:
         * + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
         * rule type by default.
         * + **file_extension**: Files are matched based on their suffixes.
         * + **catalog**: Files are matched based on their directories.
         * + **full_path**: Files are matched based on their full paths.
         * + **home_page**: Files are matched based on their homepage.
         */
        ruleType: string;
        /**
         * Specifies the cache age. The maximum cache age is 365 days.
         */
        ttl: number;
        /**
         * Specifies the unit of the cache age. Possible values:
         * + **s**: Second
         * + **m**: Minute
         * + **h**: Hour
         * + **d**: Day
         */
        ttlType: string;
        /**
         * Specifies the URL parameter types. Valid values are as follows:
         * + **del_params**: Ignore specific URL parameters.
         * + **reserve_params**: Retain specific URL parameters.
         * + **ignore_url_params**: Ignore all URL parameters.
         * + **full_url**: Retain all URL parameters.
         */
        urlParameterType?: string;
        /**
         * Specifies the URL parameter values, which are separated by commas (,).
         * Up to 10 parameters can be set.
         * This parameter is mandatory when `urlParameterType` is set to **del_params** or **reserve_params**.
         */
        urlParameterValue?: string;
    }

    export interface DomainConfigs {
        /**
         * Specifies the geographic access control rules.
         * The accessAreaFilter structure is documented below.
         */
        accessAreaFilters?: outputs.Cdn.DomainConfigsAccessAreaFilter[];
        /**
         * Specifies the browser cache expiration settings.
         * The browserCacheRules structure is documented below.
         */
        browserCacheRules?: outputs.Cdn.DomainConfigsBrowserCacheRule[];
        cacheUrlParameterFilter: outputs.Cdn.DomainConfigsCacheUrlParameterFilter;
        /**
         * Specifies the client certificate configuration.
         * The clientCert structure is documented below.
         */
        clientCert: outputs.Cdn.DomainConfigsClientCert;
        /**
         * Specifies the smart compression. The compress structure
         * is documented below.
         */
        compress: outputs.Cdn.DomainConfigsCompress;
        /**
         * Specifies the description of the domain. The value contains up to `200` characters.
         */
        description?: string;
        /**
         * Specifies the status code cache TTL.
         * The errorCodeCache structure is documented below.
         */
        errorCodeCaches?: outputs.Cdn.DomainConfigsErrorCodeCach[];
        /**
         * Specifies the custom error pages.
         * The errorCodeRedirectRules structure is documented below.
         */
        errorCodeRedirectRules?: outputs.Cdn.DomainConfigsErrorCodeRedirectRule[];
        /**
         * Specifies the advanced origin rules.
         * The flexibleOrigin structure is documented below.
         */
        flexibleOrigins?: outputs.Cdn.DomainConfigsFlexibleOrigin[];
        /**
         * Specifies the force redirect.
         * The forceRedirect structure is documented below.
         */
        forceRedirect: outputs.Cdn.DomainConfigsForceRedirect;
        /**
         * Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
         * your server, improving access security. The hsts structure is documented below.
         */
        hsts: outputs.Cdn.DomainConfigsHsts;
        /**
         * Specifies the HTTP response header settings.
         * The httpResponseHeader structure is documented below.
         */
        httpResponseHeaders: outputs.Cdn.DomainConfigsHttpResponseHeader[];
        /**
         * Specifies the certificate configuration. The httpsSettings
         * structure is documented below.
         */
        httpsSettings: outputs.Cdn.DomainConfigsHttpsSettings;
        /**
         * Specifies the IP address blacklist or whitelist.
         * The ipFilter structure is documented below.
         */
        ipFilter: outputs.Cdn.DomainConfigsIpFilter;
        /**
         * Specifies the IP access frequency limit.
         * The ipFrequencyLimit structure is documented below.
         */
        ipFrequencyLimit: outputs.Cdn.DomainConfigsIpFrequencyLimit;
        /**
         * Specifies whether to enable IPv6.
         */
        ipv6Enable?: boolean;
        /**
         * Specifies whether to enable redirection from the origin.
         * Valid values are as follows:
         * + **on**: Enable.
         * + **off**: Disable.
         */
        originFollow302Status: string;
        /**
         * Specifies the content retrieval protocol. Possible values:
         * + **follow**: Same as user requests.
         * + **http**: HTTP, which is the default value.
         * + **https**: HTTPS.
         */
        originProtocol: string;
        /**
         * Specifies the origin response timeout.
         * The value ranges from `5` to `60`, in seconds. Defaults to `30`.
         */
        originReceiveTimeout: number;
        /**
         * Specifies the rules of rewriting origin request URLs.
         * The originRequestUrlRewrite structure is documented below.
         */
        originRequestUrlRewrites?: outputs.Cdn.DomainConfigsOriginRequestUrlRewrite[];
        /**
         * Specifies the QUIC protocol. The quic structure is documented below.
         */
        quic: outputs.Cdn.DomainConfigsQuic;
        /**
         * Specifies whether to enable range-based retrieval.
         */
        rangeBasedRetrievalEnabled?: boolean;
        /**
         * Specifies the referer validation. The referer structure is documented below.
         */
        referer: outputs.Cdn.DomainConfigsReferer;
        /**
         * Specifies the remote authentication settings.
         * The remoteAuth structure is documented below.
         */
        remoteAuth: outputs.Cdn.DomainConfigsRemoteAuth;
        /**
         * Specifies the request rate limiting rules.
         * The requestLimitRules structure is documented below.
         */
        requestLimitRules?: outputs.Cdn.DomainConfigsRequestLimitRule[];
        /**
         * Specifies the request url rewrite settings. Set access URL rewrite rules to
         * redirect user requests to the URLs of cached resources.
         * The requestUrlRewrite structure is documented below.
         */
        requestUrlRewrites?: outputs.Cdn.DomainConfigsRequestUrlRewrite[];
        /**
         * Specifies the retrieval request header settings.
         * The retrievalRequestHeader structure is documented below.
         */
        retrievalRequestHeaders: outputs.Cdn.DomainConfigsRetrievalRequestHeader[];
        /**
         * Specifies whether ETag is verified during origin pull.
         * Valid values are as follows:
         * + **on**: Enable.
         * + **off**: Disable.
         */
        sliceEtagStatus: string;
        /**
         * Specifies the origin SNI settings. If your origin server is bound to multiple domains and
         * CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
         * The sni structure is documented below.
         */
        sni: outputs.Cdn.DomainConfigsSni;
        /**
         * Specifies the URL signing.
         * The urlSigning structure is documented below.
         */
        urlSigning: outputs.Cdn.DomainConfigsUrlSigning;
        /**
         * Specifies the User-Agent blacklist or whitelist settings.
         * The userAgentFilter structure is documented below.
         */
        userAgentFilter: outputs.Cdn.DomainConfigsUserAgentFilter;
        /**
         * Specifies the video seek settings. The videoSeek structure
         * is documented below.
         */
        videoSeek: outputs.Cdn.DomainConfigsVideoSeek;
        /**
         * Specifies the websocket settings. This field can only be configured if `type` is
         * set to **wholeSite**. The websocket structure is documented below.
         */
        websocket: outputs.Cdn.DomainConfigsWebsocket;
    }

    export interface DomainConfigsAccessAreaFilter {
        /**
         * Specifies the areas, separated by commas.
         * Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
         */
        area: string;
        /**
         * Specifies the content type. Valid values are:
         * + **all**: The rule takes effect for all files.
         * + **file_directory**: The rule takes effect for resources in the specified directory.
         * + **file_path**: The rule takes effect for resources corresponding to the path.
         */
        contentType: string;
        /**
         * Specifies the content value. The use of this field has the following restrictions:
         * + When `contentType` is set to **all**, make this parameter is empty or not passed.
         * + When `contentType` is set to **file_directory**, the value must start with a slash (/) and multiple directories
         * are separated by commas (,), for example, **&#47;test/folder01,/test/folder02**. Up to `100` directories can be entered.
         * + When `contentType` is set to **file_path**, the value must start with a slash (/) or wildcard (\*). Up to two
         * wildcards (\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
         * for example, **&#47;test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
         */
        contentValue: string;
        /**
         * Specifies the IP addresses exception in access control, separated by commas.
         */
        exceptionIp: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
    }

    export interface DomainConfigsBrowserCacheRule {
        /**
         * Specifies the cache validation type. Valid values are:
         * + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
         * + **ttl**: The browser cache follows the expiration time set by the current rules.
         * + **never**: The browser does not cache resources.
         */
        cacheType: string;
        /**
         * Specifies matching condition.
         * The condition structure is documented below.
         */
        condition: outputs.Cdn.DomainConfigsBrowserCacheRuleCondition;
        /**
         * Specifies the cache age. The maximum cache age is 365 days.
         */
        ttl: number;
        /**
         * Specifies the cache expiration time unit. Valid values are:
         * + **s**: seconds.
         * + **m**: minutes.
         * + **h**: hours.
         * + **d**: days.
         */
        ttlUnit: string;
    }

    export interface DomainConfigsBrowserCacheRuleCondition {
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the cache match settings.
         * + When `matchType` is set to **all**, this field does not need to be configured.
         * + When `matchType` is set to **file_extension**, this field value is the file suffix. The first character of the
         * value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
         * not exceed `20`.
         * + When `matchType` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
         * be separated by "," such as **&#47;test/folder01,/test/folder02**. The total number of directory paths entered must not
         * exceed `20`.
         * + When `matchType` is set to **full_path**, the value of this field is a full path. The value must start with "/".
         * It supports matching specific files in the specified directory or files with a wildcard "*".
         * The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
         * single full path cache rule, such as **&#47;test/index.html** or ***&#47;test/*.jpg**.
         * + When `matchType` is set to **home_page**, this field does not need to be configured.
         */
        matchValue: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
    }

    export interface DomainConfigsCacheUrlParameterFilter {
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value?: string;
    }

    export interface DomainConfigsClientCert {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the domain name specified in the client CA certificate.
         */
        hosts: string;
        status: string;
        /**
         * Specifies the client CA certificate content, only supports PEM format.
         */
        trustedCert: string;
    }

    export interface DomainConfigsCompress {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the formats of files to be compressed. Enter up to 200 characters.
         * Multiple formats are separated by commas (,). Each format contains up to 50 characters.
         * Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.
         */
        fileType: string;
        status: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
    }

    export interface DomainConfigsErrorCodeCach {
        /**
         * Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
         * **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
         */
        code: number;
        /**
         * Specifies the cache age. The maximum cache age is 365 days.
         */
        ttl: number;
    }

    export interface DomainConfigsErrorCodeRedirectRule {
        /**
         * Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
         * **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
         */
        errorCode: number;
        /**
         * Specifies the redirect status code. The value can be **301** or **302**.
         */
        targetCode: number;
        /**
         * Specifies the destination URL. The value must start with **http://** or **https://**.
         * For example: `http://www.example.com`.
         */
        targetLink: string;
    }

    export interface DomainConfigsFlexibleOrigin {
        /**
         * Specifies the back source information. The length of this array field cannot exceed `1`.
         * The backSources structure is documented below.
         */
        backSources: outputs.Cdn.DomainConfigsFlexibleOriginBackSources;
        /**
         * Specifies the URI match rule. The usage rules are as follows:
         * + When `matchType` is set to **all**, set this field to empty.
         * + When `matchType` is set to **file_extension**, the value of this field should start with a period (.).
         * Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
         * + When `matchType` is set to **file_path**, the value of this field should start with a slash (/).
         * Enter up to 20 paths and use semicolons (;) to separate them. Example: **&#47;test/folder01;/test/folder02**.
         */
        matchPattern: string;
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
    }

    export interface DomainConfigsFlexibleOriginBackSources {
        /**
         * Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
         */
        httpPort: number;
        /**
         * Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
         */
        httpsPort: number;
        /**
         * Specifies the IP address or domain name of the origin server.
         * + When `sourcesType` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
         * + When `sourcesType` is set to **domain**, the value of this field can only be set to a domain name.
         * + When `sourcesType` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
         * domain name.
         */
        ipOrDomain: string;
        /**
         * Specifies the OBS bucket type. Valid values are **private** and **public**.
         * This field is required when `sourcesType` is set to **obs_bucket**.
         */
        obsBucketType: string;
        /**
         * Specifies the origin server type. Valid values are as follows:
         * + **ipaddr**: IP address.
         * + **domain**: Domain name.
         * + **obs_bucket**: OBS bucket.
         */
        sourcesType: string;
    }

    export interface DomainConfigsForceRedirect {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the force redirect status code. Valid values are: **301** and **302**.
         * Defaults to **302**.
         */
        redirectCode: number;
        status: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
    }

    export interface DomainConfigsHsts {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies whether subdomain names are included.
         * The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.
         */
        includeSubdomains: string;
        /**
         * Specifies the expiration time, which means the TTL of the response header
         * `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
         * This field is required when enable HSTS settings.
         */
        maxAge: number;
    }

    export interface DomainConfigsHttpResponseHeader {
        /**
         * Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
         */
        action: string;
        /**
         * Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
         * **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
         * **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
         * and hyphens (-), and starts with a letter.
         */
        name: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value?: string;
    }

    export interface DomainConfigsHttpsSettings {
        /**
         * Specifies the content of the certificate used by the HTTPS protocol.
         * This parameter is mandatory when a certificate is configured. The value is in PEM format.
         * This field is required when `certificateSource` is set to `0`.
         */
        certificateBody: string;
        /**
         * Specifies the certificate name. The value contains `3` to `32` characters.
         * This parameter is mandatory when a certificate is configured.
         */
        certificateName: string;
        /**
         * Specifies the certificate source. Valid values are:
         * + `0`: Your own certificate.
         * + `2`: SCM certificate. Please enable SCM delegation authorization to access SCM service.
         */
        certificateSource: number;
        /**
         * Specifies the certificate type. Currently, only **server** is supported, which
         * means international certificate. Defaults to **server**.
         */
        certificateType: string;
        /**
         * Specifies whether HTTP/2 is used. Defaults to **false**.
         * When `httpsEnabled` is set to **false**, this parameter does not take effect.
         */
        http2Enabled: boolean;
        http2Status: string;
        /**
         * Specifies whether to enable HTTPS. Defaults to **false**.
         */
        httpsEnabled: boolean;
        httpsStatus: string;
        /**
         * Specifies whether online certificate status protocol (OCSP) stapling is enabled.
         * Valid values are as follows:
         * + **on**: Enable.
         * + **off**: Disable.
         */
        ocspStaplingStatus: string;
        /**
         * Specifies the private key used by the HTTPS protocol. This parameter is mandatory
         * when a certificate is configured. The value is in PEM format.
         * This field is required when `certificateSource` is set to `0`.
         */
        privateKey: string;
        /**
         * Specifies the SCM certificate ID.
         * This field is required when `certificateSource` is set to `2`.
         */
        scmCertificateId: string;
        /**
         * Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
         * **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
         * enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
         * separate versions, for example, **TLSv1.1,TLSv1.2**.
         */
        tlsVersion: string;
    }

    export interface DomainConfigsIpFilter {
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value: string;
    }

    export interface DomainConfigsIpFrequencyLimit {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
         * This field is required when enable IP access frequency.
         */
        qps: number;
    }

    export interface DomainConfigsOriginRequestUrlRewrite {
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
        /**
         * Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
         * contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
         * Wildcards (*) are supported, for example, `/test/*&#47;*.mp4`. This field is invalid when `matchType` is set to **all**.
         */
        sourceUrl: string;
        /**
         * Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
         * or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
         * `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
         */
        targetUrl: string;
    }

    export interface DomainConfigsQuic {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
    }

    export interface DomainConfigsReferer {
        /**
         * Specifies whether empty user agents are included.
         * A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
         * A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
         * Possible values: **true** (included) and **false** (excluded).
         * The default value is **false** for a blacklist and **true** for a whitelist.
         */
        includeEmpty: boolean;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value: string;
    }

    export interface DomainConfigsRemoteAuth {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the remote authentication settings. The length of this array field
         * cannot exceed `1`. The remoteAuthRules structure is documented below.
         */
        remoteAuthRules?: outputs.Cdn.DomainConfigsRemoteAuthRemoteAuthRules;
    }

    export interface DomainConfigsRemoteAuthRemoteAuthRules {
        /**
         * Specifies the URL validation parameters.
         * The addCustomArgsRules structure is documented below.
         */
        addCustomArgsRules?: outputs.Cdn.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule[];
        /**
         * Specifies the request header authentication parameters.
         * The addCustomHeadersRules structure is documented below.
         */
        addCustomHeadersRules?: outputs.Cdn.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule[];
        /**
         * Specifies the status code returned by the remote authentication server
         * to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
         */
        authFailedStatus: string;
        /**
         * Specifies the address of a reachable server. The address must include **http://** or
         * **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
         * acceleration domain name added on CDN.
         */
        authServer: string;
        /**
         * Specifies the status code returned by the remote authentication server
         * to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
         */
        authSuccessStatus: string;
        /**
         * Specifies the authentication file type settings. Valid values are:
         * + **all**: Requests for all files are authenticated.
         * + **specific_file**: Requests for files of specific types are authenticated.
         */
        fileTypeSetting: string;
        /**
         * Specifies the request method supported by the authentication server. Valid values
         * are **GET**, **POST**, and **HEAD**.
         */
        requestMethod: string;
        /**
         * Specifies the reserve args. Multiple args are separated by vertical bars (|).
         * For example: **key1|key2**. This parameter is mandatory when `reserveArgsSetting` is set to **reserve_specific_args**.
         * In other cases, this parameter is left blank.
         */
        reserveArgs?: string;
        /**
         * Specifies the parameters that need to be authenticated in user requests.
         * Valid values are as follows:
         * + **reserve_all_args**: Retain all URL parameters.
         * + **reserve_specific_args**: Retain specified URL parameters.
         * + **ignore_all_args**: Ignore all URL parameters.
         */
        reserveArgsSetting: string;
        /**
         * Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
         * For example: **key1|key2**. This parameter is mandatory when `reserveHeadersSetting` is set to **reserve_specific_headers**.
         * In other cases, this parameter is left blank.
         */
        reserveHeaders?: string;
        /**
         * Specifies the headers to be authenticated in user requests.
         * Valid values are as follows:
         * + **reserve_all_headers**: Retain all request headers.
         * + **reserve_specific_headers**: Retain specified request headers.
         * + **ignore_all_headers**: Ignore all request headers.
         */
        reserveHeadersSetting: string;
        /**
         * Specifies the status code returned by CDN nodes to users when authentication
         * is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
         */
        responseStatus: string;
        /**
         * Specifies the specific file types. The value contains letters and digits.
         * The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
         * by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `fileTypeSetting` is set to
         * **specific_file**. In other cases, this parameter is left blank.
         */
        specifiedFileType?: string;
        /**
         * Specifies the duration from the time when a CDN node forwards an authentication request
         * to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
         * ranging from `50` to `3,000`. The unit is millisecond.
         */
        timeout: number;
        /**
         * Specifies the action of the CDN nodes to process user requests after the
         * authentication timeout. Valid values are as follows:
         * + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
         * + **forbid**: The user request is rejected after the authentication times out and the configured status code is
         * returned to the user.
         */
        timeoutAction: string;
    }

    export interface DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule {
        /**
         * Specifies the parameter key. The value contains up to `256` characters. The value can be
         * composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
         */
        key: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value: string;
    }

    export interface DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule {
        /**
         * Specifies the parameter key. The value contains up to `256` characters. The value can be
         * composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
         */
        key: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value: string;
    }

    export interface DomainConfigsRequestLimitRule {
        /**
         * Specifies the rate limiting condition. Unit: byte.
         * The value ranges from `0` to `1,073,741,824`.
         */
        limitRateAfter: number;
        /**
         * Specifies the rate limiting value, in bit/s.
         * The value ranges from `0` to `104,857,600`.
         */
        limitRateValue: number;
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the cache match settings.
         * + When `matchType` is set to **all**, this field does not need to be configured.
         * + When `matchType` is set to **file_extension**, this field value is the file suffix. The first character of the
         * value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
         * not exceed `20`.
         * + When `matchType` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
         * be separated by "," such as **&#47;test/folder01,/test/folder02**. The total number of directory paths entered must not
         * exceed `20`.
         * + When `matchType` is set to **full_path**, the value of this field is a full path. The value must start with "/".
         * It supports matching specific files in the specified directory or files with a wildcard "*".
         * The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
         * single full path cache rule, such as **&#47;test/index.html** or ***&#47;test/*.jpg**.
         * + When `matchType` is set to **home_page**, this field does not need to be configured.
         */
        matchValue?: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
    }

    export interface DomainConfigsRequestUrlRewrite {
        /**
         * Specifies matching condition.
         * The condition structure is documented below.
         */
        condition: outputs.Cdn.DomainConfigsRequestUrlRewriteCondition;
        /**
         * Specifies the execution mode. Valid values are:
         * + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
         * After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
         * + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
         * After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
         * The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
         */
        executionMode: string;
        /**
         * Specifies the domain name to redirect client requests.
         */
        redirectHost: string;
        /**
         * Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
         */
        redirectStatusCode: number;
        /**
         * Specifies the redirect URL. The redirected URL starts with a forward slash (/)
         * and does not contain the http:// header or domain name. Example: **&#47;test/index.html**.
         */
        redirectUrl: string;
    }

    export interface DomainConfigsRequestUrlRewriteCondition {
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the cache match settings.
         * + When `matchType` is set to **all**, this field does not need to be configured.
         * + When `matchType` is set to **file_extension**, this field value is the file suffix. The first character of the
         * value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
         * not exceed `20`.
         * + When `matchType` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
         * be separated by "," such as **&#47;test/folder01,/test/folder02**. The total number of directory paths entered must not
         * exceed `20`.
         * + When `matchType` is set to **full_path**, the value of this field is a full path. The value must start with "/".
         * It supports matching specific files in the specified directory or files with a wildcard "*".
         * The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
         * single full path cache rule, such as **&#47;test/index.html** or ***&#47;test/*.jpg**.
         * + When `matchType` is set to **home_page**, this field does not need to be configured.
         */
        matchValue: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
    }

    export interface DomainConfigsRetrievalRequestHeader {
        /**
         * Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
         */
        action: string;
        /**
         * Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
         * **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
         * **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
         * and hyphens (-), and starts with a letter.
         */
        name: string;
        /**
         * Specifies the IP address blacklist or whitelist. This field is required when `type` is
         * set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
         * by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
         * Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
         */
        value?: string;
    }

    export interface DomainConfigsSni {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the origin server domain name that the CDN node needs to access when
         * returning to the source.
         */
        serverName: string;
        status: string;
    }

    export interface DomainConfigsUrlSigning {
        /**
         * Specifies the standby authentication key contains `16` to `32` characters,
         * including letters and digits.
         */
        backupKey: string;
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.
         */
        expireTime: number;
        /**
         * Specifies the details of the authentication inheritance.
         * The inheritConfig structure is documented below.
         */
        inheritConfig: outputs.Cdn.DomainConfigsUrlSigningInheritConfig;
        /**
         * Specifies the parameter key. The value contains up to `256` characters. The value can be
         * composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
         */
        key: string;
        /**
         * Specifies the match type. Valid values are:
         * + **all**: Match all files.
         * + **file_extension**: Match by file suffix.
         * + **catalog**: Match by directory.
         * + **full_path**: Full path matching.
         * + **home_page**: Match by homepage.
         */
        matchType: string;
        /**
         * Specifies the authentication parameters. The default value is **auth_key**.
         * The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
         * The value can not start with a digit.
         */
        signArg: string;
        /**
         * Specifies the encryption algorithm type for URL authentication.
         * The default value is **md5**. The valid values are as following:
         * + **md5**
         * + **sha256**
         */
        signMethod: string;
        status: string;
        /**
         * Specifies the time format. Possible values are:
         * **dec**: Decimal, can be used in Method A, Method B and Method C2.
         * **hex**: Hexadecimal, can be used in Method C1 and Method C2.
         */
        timeFormat: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
    }

    export interface DomainConfigsUrlSigningInheritConfig {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the time type that inherits authentication settings.
         * The valid values are as follows:
         * + **sys_time**: The current system time.
         * + **parent_url_time**: The time when a user accesses the M3U8/MPD file.
         */
        inheritTimeType: string;
        /**
         * Specifies the authentication inheritance configuration.
         * The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.
         */
        inheritType: string;
        status: string;
    }

    export interface DomainConfigsUserAgentFilter {
        /**
         * Specifies whether empty user agents are included.
         * A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
         * A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
         * Possible values: **true** (included) and **false** (excluded).
         * The default value is **false** for a blacklist and **true** for a whitelist.
         */
        includeEmpty: string;
        /**
         * Specifies the blacklist and whitelist rule type. Valid values are:
         * + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
         * returned.
         * + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
         * returned for other users.
         */
        type: string;
        /**
         * Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
         * is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.
         */
        uaLists: string[];
    }

    export interface DomainConfigsVideoSeek {
        /**
         * Specifies the time-based `FLV` seek status.
         * **true**: enabled; **false**: disabled. Defaults to **false**.
         */
        enableFlvByTimeSeek: boolean;
        /**
         * Specifies the video seek status. **true**: enabled; **false**: disabled.
         */
        enableVideoSeek: boolean;
        /**
         * Specifies the video playback end parameter in user request URLs.
         * The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
         */
        endParameter?: string;
        /**
         * Specifies the video playback start parameter in user request URLs.
         * The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
         */
        startParameter?: string;
    }

    export interface DomainConfigsWebsocket {
        /**
         * Specifies whether to enable client cert settings.
         */
        enabled: boolean;
        /**
         * Specifies the duration from the time when a CDN node forwards an authentication request
         * to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
         * ranging from `50` to `3,000`. The unit is millisecond.
         */
        timeout: number;
    }

    export interface DomainSource {
        /**
         * Specifies whether the origin server is primary or standby. Valid values are as follows:
         * + **1**: Primary.
         * + **0**: Standby.
         */
        active?: number;
        /**
         * Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
         */
        httpPort: number;
        /**
         * Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
         */
        httpsPort: number;
        /**
         * Specifies the OBS bucket type. Valid values are **private** and **public**.
         * This field is required when `sourcesType` is set to **obs_bucket**.
         */
        obsBucketType: string;
        /**
         * Specifies whether to enable static website hosting for the OBS bucket.
         * This parameter is valid only when the `originType` is set to **obs_bucket**. Defaults to **false**.
         */
        obsWebHostingEnabled: boolean;
        /**
         * Specifies the unique domain name or IP address of the origin server.
         * + If `originType` is set to **ipaddr**, this field can only be set to IPv4 address.
         * + If `originType` is set to **domain**, this field can only be set to domain name.
         * + If `originType` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
         * domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
         */
        origin: string;
        /**
         * Specifies the origin server type. The valid values are as follows:
         * + **ipaddr**: Origin server IP address.
         * + **domain**: Origin server domain name.
         * + **obs_bucket**: OBS bucket domain name.
         */
        originType: string;
        /**
         * Specifies the retrieval host. Things to note when using this field are as follows:
         * + If `originType` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
         * + If `originType` is set to **obs_bucket**, the bucket's domain name will be used by default.
         */
        retrievalHost: string;
        /**
         * Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
         * A larger value indicates a larger number of times that content is pulled from this IP address.
         */
        weight: number;
    }

}

export namespace Cse {
    export interface AlarmruleAlarmAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * Specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface AlarmruleCondition {
        /**
         * Specifies the alarm severity of the condition. The value can be 1, 2, 3 or 4,
         * which indicates *critical*, *major*, *minor*, and *informational*, respectively.
         * The default value is 2.
         */
        alarmLevel: number;
        /**
         * Specifies the comparison condition of alarm thresholds. The value can be >,
         * =, <, >=, or <=.
         */
        comparisonOperator: string;
        /**
         * Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
         */
        count: number;
        /**
         * Specifies the data rollup methods. The value can be max, min, average, sum, and variance.
         */
        filter: string;
        /**
         * Specifies the metric name of the condition. The value can be a string of
         * 1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        metricName: string;
        /**
         * Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
         * and 86400.
         */
        period: number;
        /**
         * Specifies the interval for triggering an alarm if the alarm persists.
         * Possible values are as follows:
         * + **0**: Cloud Eye triggers the alarm only once;
         * + **300**: Cloud Eye triggers the alarm every 5 minutes;
         * + **600**: Cloud Eye triggers the alarm every 10 minutes;
         * + **900**: Cloud Eye triggers the alarm every 15 minutes;
         * + **1800**: Cloud Eye triggers the alarm every 30 minutes;
         * + **3600**: Cloud Eye triggers the alarm every hour;
         * + **10800**: Cloud Eye triggers the alarm every 3 hours;
         * + **21600**: Cloud Eye triggers the alarm every 6 hours;
         * + **43200**: Cloud Eye triggers the alarm every 12 hour;
         * + **86400**: Cloud Eye triggers the alarm every day.
         */
        suppressDuration?: number;
        /**
         * Specifies the data unit.
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        unit?: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+108.
         */
        value: number;
    }

    export interface AlarmruleInsufficientdataAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * Specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface AlarmruleMetric {
        /**
         * Specifies the list of metric dimensions. The structure is described below.
         */
        dimensions: outputs.Cse.AlarmruleMetricDimension[];
        /**
         * Specifies the metric name of the condition. The value can be a string of
         * 1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        metricName: string;
        /**
         * Specifies the namespace in **service.item** format. **service** and **item**
         * each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
         * Changing this creates a new resource.
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        namespace: string;
    }

    export interface AlarmruleMetricDimension {
        /**
         * Specifies the dimension name. The value can be a string of 1 to 32 characters
         * that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
         */
        name: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+108.
         */
        value?: string;
    }

    export interface AlarmruleOkAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * Specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface AlarmruleResource {
        /**
         * Specifies the list of metric dimensions. The structure is described below.
         */
        dimensions: outputs.Cse.AlarmruleResourceDimension[];
    }

    export interface AlarmruleResourceDimension {
        /**
         * Specifies the dimension name. The value can be a string of 1 to 32 characters
         * that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
         */
        name: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+108.
         */
        value: string;
    }

    export interface MicroserviceEngineConfigCenterAddress {
        /**
         * The internal access address.
         */
        private: string;
        /**
         * The public access address. This address is only set when EIP is bound.
         */
        public: string;
    }

    export interface MicroserviceEngineServiceRegistryAddress {
        /**
         * The internal access address.
         */
        private: string;
        /**
         * The public access address. This address is only set when EIP is bound.
         */
        public: string;
    }

    export interface MicroserviceInstanceDataCenter {
        /**
         * Specifies the custom availability zone name of the data center.
         * Changing this will create a new microservice instance.
         */
        availabilityZone: string;
        /**
         * Specifies the data center name.
         * Changing this will create a new microservice instance.
         */
        name: string;
        /**
         * Specifies the custom region name of the data center.
         * Changing this will create a new microservice instance.
         */
        region: string;
    }

    export interface MicroserviceInstanceHealthCheck {
        /**
         * Specifies the heartbeat interval. The unit is **s** (second).
         * Changing this will create a new microservice instance.
         */
        interval: number;
        /**
         * Specifies the maximum retries.
         * Changing this will create a new microservice instance.
         */
        maxRetries: number;
        /**
         * Specifies the heartbeat mode. The valid values are **push** and **pull**.
         * Changing this will create a new microservice instance.
         */
        mode: string;
        /**
         * Specifies the port number.
         * Changing this will create a new microservice instance.
         */
        port: number;
    }

}

export namespace Css {
    export interface ClusterBackupStrategy {
        /**
         * Specifies the IAM agency used to access OBS.
         */
        agency: string;
        /**
         * Specifies the storage path of the snapshot in the OBS bucket.
         */
        backupPath: string;
        /**
         * Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
         * bucket, only the OBS bucket is used and cannot be changed.
         */
        bucket: string;
        /**
         * Specifies the number of days to retain the generated snapshots. Snapshots are reserved
         * for seven days by default.
         */
        keepDays?: number;
        /**
         * Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
         */
        prefix?: string;
        /**
         * Specifies the time when a snapshot is automatically created everyday. Snapshots can
         * only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
         * format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
         * and "01:00 GMT+08:00".
         */
        startTime: string;
    }

    export interface ClusterClientNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterClientNodeConfigVolume;
    }

    export interface ClusterClientNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         */
        volumeType: string;
    }

    export interface ClusterColdNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterColdNodeConfigVolume;
    }

    export interface ClusterColdNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         */
        volumeType: string;
    }

    export interface ClusterEssNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterEssNodeConfigVolume;
    }

    export interface ClusterEssNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         */
        volumeType: string;
    }

    export interface ClusterKibanaPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterMasterNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterMasterNodeConfigVolume;
    }

    export interface ClusterMasterNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         */
        volumeType: string;
    }

    export interface ClusterNode {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is **1** at most.
         */
        availabilityZone: string;
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Instance IP address.
         */
        ip: string;
        /**
         * Specifies the cluster name. It contains `4` to `32` characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * The resource ID of this instance.
         */
        resourceId: string;
        /**
         * Instance specification code.
         */
        specCode: string;
        /**
         * Instance status.
         */
        status: string;
        /**
         * Node type. The options are as follows:
         * + **ess-master:** Indicates a master node.
         * + **ess-client:** Indicates a client node.
         * + **ess-cold:** Indicates a cold data node.
         * + **ess indicates:** Indicates a data node.
         */
        type: string;
    }

    export interface ClusterNodeConfig {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is **1** at most.
         */
        availabilityZone: string;
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        networkInfo: outputs.Css.ClusterNodeConfigNetworkInfo;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterNodeConfigVolume;
    }

    export interface ClusterNodeConfigNetworkInfo {
        /**
         * Specifies the security group ID.
         */
        securityGroupId: string;
        /**
         * Specifies the Subnet ID.
         * Changing this parameter will create a new resource.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID.
         * Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface ClusterNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         */
        volumeType: string;
    }

    export interface ClusterPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterVpcepEndpoint {
        /**
         * Specifies whether to enable the private domain name.
         */
        endpointWithDnsName: boolean;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelists?: string[];
    }

    export interface GetFlavorsFlavor {
        /**
         * The valid availability zones for current flavor.
         */
        availabilityZones: string;
        /**
         * The disk capacity range of an instance, in GB.
         */
        diskRange: string;
        /**
         * The ID of CSS flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the CSS flavor.
         */
        memory: number;
        /**
         * Specifies the name of the CSS flavor.
         */
        name: string;
        /**
         * Specifies the region in which to obtain the CSS flavors. If omitted, the
         * provider-level region will be used.
         */
        region: string;
        /**
         * Specifies the node instance type. The options are `ess`, `ess-cold`, `ess-master`
         * and `ess-client`.
         */
        type: string;
        /**
         * Specifies the number of vCPUs in the CSS flavor.
         */
        vcpus: number;
        /**
         * Specifies the engine version. The options are `5.5.1`, `6.2.3`, `6.5.4`, `7.1.1`,
         * `7.6.2` and `7.9.3`.
         */
        version: string;
    }

}

export namespace Cts {
    export interface NotificationFilter {
        /**
         * Specifies the relationship between multiple rules. The valid values are as follows:
         * + **AND**: Effective after all filtering conditions are met.
         * + **OR**: Effective when any one of the conditions is met.
         */
        condition: string;
        /**
         * Specifies an array of filtering rules. It consists of three parts,
         * the first part is the **key**, the second part is the **rule**, and the third part is the **value**,
         * the format is: **key != value**.
         * + The **key** can be: **api_version**, **code**, **trace_rating**, **trace_type**, **resource_id** and
         * **resource_name**.
         * When the key is **api_version**, the value needs to follow the regular constraint: **^ (a-zA-Z0-9_ -.) {1,64}$**.
         * When the key is **code**, the length range of value is from `1` to `256`.
         * When the key is **trace_rating**, the value can be **normal**, **warning** or **incident**.
         * When the key is **trace_type**, the value can be **ConsoleAction**, **ApiCall** or **SystemAction**.
         * When the key is **resource_id**, the length range of value is from `1` to `350`.
         * When the key is **resource_name**, the length range of value is from `1` to `256`.
         * + The **rule** can be: **!=** or **=**.
         */
        rules: string[];
    }

    export interface NotificationOperation {
        /**
         * Specifies the resource type.
         */
        resource: string;
        /**
         * Specifies the cloud service.
         */
        service: string;
        /**
         * Specifies an array of trace names.
         */
        traceNames: string[];
    }

    export interface NotificationOperationUser {
        /**
         * Specifies the IAM user group name.
         */
        group: string;
        /**
         * Specifies an array of IAM users in the group.
         */
        users: string[];
    }

}

export namespace Dcs {
    export interface GetFlavorsFlavor {
        /**
         * An array of available zones where the cache specification can be used.
         */
        availableZones: string[];
        /**
         * The mode of a cache engine. The valid values are as follows:
         */
        cacheMode: string;
        /**
         * The total memory of the cache, in GB.
         * + **Redis4.0, Redis5.0 and Redis6.0**: Stand-alone and active/standby type instance values:
         * `0.125`, `0.25`, `0.5`, `1`, `2`, `4`, `8`, `16`, `32` and `64`.
         * Cluster instance specifications support `4`,`8`,`16`,`24`, `32`, `48`, `64`, `96`, `128`, `192`,
         * `256`, `384`, `512`, `768` and `1024`.
         * + **Redis3.0**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         * Proxy cluster instance specifications support `64`, `128`, `256`, `512`, and `1024`.
         * + **Memcached**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         */
        capacity: number;
        /**
         * The charging modes for the specification cache instance.
         */
        chargingModes: string[];
        /**
         * The CPU architecture of cache instance.
         * Valid values *x86_64* and *aarch64*.
         */
        cpuArchitecture: string;
        /**
         * The engine of the cache instance. Valid values are *Redis* and *Memcached*.
         * Default value is *Redis*.
         */
        engine: string;
        /**
         * Supported versions of the specification.
         */
        engineVersions: string;
        /**
         * Number of IP addresses corresponding to the specifications.
         */
        ipCount: number;
        /**
         * The flavor name of the cache instance.
         */
        name: string;
    }

    export interface InstanceBackupPolicy {
        /**
         * Day in a week on which backup starts, the value ranges from `1` to `7`.
         * Where: 1 indicates Monday; 7 indicates Sunday.
         */
        backupAts: number[];
        /**
         * Backup type. Default value is `auto`. The valid values are as follows:
         * + `auto`: automatic backup.
         * + `manual`: manual backup.
         */
        backupType?: string;
        /**
         * Time at which backup starts.
         * Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.
         */
        beginAt: string;
        /**
         * Interval at which backup is performed. Default value is `weekly`.
         * Currently, only weekly backup is supported.
         */
        periodType?: string;
        /**
         * Retention time. Unit: day, the value ranges from `1` to `7`.
         * This parameter is required if the backupType is **auto**.
         */
        saveDays?: number;
    }

    export interface InstanceBandwidthInfo {
        /**
         * Indicates the bandwidth size, the unit is **GB**.
         */
        bandwidth: number;
        /**
         * Indicates the begin time of temporary increase.
         */
        beginTime: string;
        /**
         * Indicates the current time.
         */
        currentTime: string;
        /**
         * Indicates the end time of temporary increase.
         */
        endTime: string;
        /**
         * Indicates the number of increases.
         */
        expandCount: number;
        /**
         * Indicates the interval between temporary increases, the unit is **ms**.
         */
        expandEffectTime: number;
        /**
         * Indicates the time interval to the next increase, the unit is **ms**.
         */
        expandIntervalTime: number;
        /**
         * Indicates the maximum number of increases.
         */
        maxExpandCount: number;
        /**
         * Indicates the next increase time.
         */
        nextExpandTime: string;
        /**
         * Indicates whether the increase task is running.
         */
        taskRunning: boolean;
    }

    export interface InstanceParameter {
        /**
         * Specifies the ID of the configuration item.
         */
        id: string;
        /**
         * Specifies the name of the configuration item.
         */
        name: string;
        /**
         * Specifies the value of the configuration item.
         */
        value: string;
    }

    export interface InstanceWhitelist {
        /**
         * Specifies the name of IP address group.
         */
        groupName: string;
        /**
         * Specifies the list of IP address or CIDR which can be whitelisted for an instance.
         * The maximum is 20.
         */
        ipAddresses: string[];
    }

}

export namespace Dds {
    export interface DatabaseRoleInheritedPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The resources structure is documented below.
         */
        resources: outputs.Dds.DatabaseRoleInheritedPrivilegeResource[];
    }

    export interface DatabaseRoleInheritedPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
    }

    export interface DatabaseRolePrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The resources structure is documented below.
         */
        resources: outputs.Dds.DatabaseRolePrivilegeResource[];
    }

    export interface DatabaseRolePrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
    }

    export interface DatabaseRoleRole {
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
        /**
         * Specifies the name of role owned by the current role.
         * The name can contain `1` to `64` characters, only letters, digits, underscores (_), hyphens (-) and dots (.) are
         * allowed. Changing this parameter will create a new role.
         */
        name: string;
    }

    export interface DatabaseUserInheritedPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The resources structure is documented below.
         */
        resources: outputs.Dds.DatabaseUserInheritedPrivilegeResource[];
    }

    export interface DatabaseUserInheritedPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
    }

    export interface DatabaseUserPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The resources structure is documented below.
         */
        resources: outputs.Dds.DatabaseUserPrivilegeResource[];
    }

    export interface DatabaseUserPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
    }

    export interface DatabaseUserRole {
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
        /**
         * Specifies the name of role owned by the current user.
         * The name can contain `1` to `64` characters, only letters, digits, underscores (_), hyphens (-) and dots (.) are
         * allowed. Changing this parameter will create a new user.
         */
        name: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * Indicates the mapping between availability zone and status of the flavor. **key** indicates the AZ ID,
         * and **value** indicates the specification status in the AZ. Its value can be any of the following:
         * + **normal**: The specification is on sale.
         * + **unsupported**: This specification is not supported.
         * + **sellout**: The specification is sold out.
         */
        azStatus: {[key: string]: string};
        /**
         * Specifies the engine name. Value options: **DDS-Community** and **DDS-Enhanced**.
         */
        engineName: string;
        /**
         * Indicates the database versions.
         */
        engineVersions: string[];
        /**
         * Specifies the memory size in GB.
         */
        memory: string;
        /**
         * Indicates the resource specification code.
         */
        specCode: string;
        /**
         * Specifies the type of the flavor. Value options: **mongos**, **shard**, **config**,
         * **replica**, **single** and **readonly**.
         */
        type: string;
        /**
         * Specifies the number of vCPUs.
         */
        vcpus: string;
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value range is
         * from 0 to 732. If this parameter is set to 0, the automated backup policy is disabled.
         */
        keepDays: number;
        /**
         * Specifies the backup cycle. Data will be automatically backed up on the
         * selected days every week.
         * + If you set the `keepDays` to 0, this parameter is no need to set.
         * + If you set the `keepDays` within 6 days, set the parameter value to **1,2,3,4,5,6,7**, data is automatically
         * backed up on each day every week.
         * + If you set the `keepDays` between 7 and 732 days, set the parameter value to at least one day of every week.
         * For example: **1**, **3,5**.
         */
        period: string;
        /**
         * Specifies the backup time window. Automated backups will be triggered during
         * the backup time window. The value cannot be empty. It must be a valid value in the "hh:mm-HH:MM" format.
         * The current time is in the UTC format.
         * + The HH value must be 1 greater than the hh value.
         * + The values from mm and MM must be the same and must be set to **00**.
         */
        startTime: string;
    }

    export interface InstanceConfiguration {
        /**
         * Specifies the ID of the template.
         */
        id: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
    }

    export interface InstanceDatastore {
        /**
         * Specifies the storage engine of the DB instance.
         * If `version` is set to `4.0`, the value is **wiredTiger**.
         * If `version` is set to `4.2`, `4.4` or `5.0`, the value is **rocksDB**.
         */
        storageEngine?: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
        /**
         * Specifies the DB instance version. For the Community Edition, the valid
         * values are `4.0`, `4.2`, `4.4` or `5.0`.
         */
        version: string;
    }

    export interface InstanceFlavor {
        /**
         * Specifies the node quantity. Valid value:
         * + If the value of type is **mongos**, num indicates the number of mongos nodes in the cluster instance. Value ranges
         * from `2` to `16`.
         * + If the value of type is **shard**, num indicates the number of shard groups in the cluster instance. Value ranges
         * from `2` to `16`.
         * + If the value of type is **config**, num indicates the number of config groups in the cluster instance. Value can
         * only be `1`.
         * + If the value of type is **replica**, num indicates the number of replica nodes in the replica set instance. Value
         * can be `3`, `5`, or `7`.
         */
        num: number;
        /**
         * Specifies the disk size. The value must be a multiple of `10`. The unit is GB. This parameter
         * is mandatory for nodes except mongos and invalid for mongos.For a cluster instance, the storage space of a shard node
         * can be `10` to `2,000` GB, and the config storage space is `20` GB. For a replica set instance, the value ranges
         * from `10` to `3000` GB. This parameter can be updated when the value of `type` is shard or replica.
         */
        size?: number;
        /**
         * Specifies the resource specification code. In a cluster instance, multiple
         * specifications need to be specified. All specifications must be of the same series, that is, general-purpose (s6),
         * enhanced (c3), or enhanced II (c6). For example:
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.s6.large.4.config have the same specifications.
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.c3.large.4.config are not of the same specifications.
         */
        specCode: string;
        /**
         * Specifies the disk type. Valid value:
         * + **ULTRAHIGH**: SSD storage.
         * + **EXTREMEHIGH**: Extreme SSD storage.
         */
        storage?: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
    }

    export interface InstanceGroup {
        /**
         * Specifies the ID of the template.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the nodes info.
         * The nodes structure is documented below.
         */
        nodes: outputs.Dds.InstanceGroupNode[];
        /**
         * Specifies the disk size. The value must be a multiple of `10`. The unit is GB. This parameter
         * is mandatory for nodes except mongos and invalid for mongos.For a cluster instance, the storage space of a shard node
         * can be `10` to `2,000` GB, and the config storage space is `20` GB. For a replica set instance, the value ranges
         * from `10` to `3000` GB. This parameter can be updated when the value of `type` is shard or replica.
         */
        size: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
        /**
         * Indicates the disk usage.
         */
        used: string;
    }

    export interface InstanceGroupNode {
        /**
         * Specifies the ID of the template.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the private IP address of a node. This parameter is valid only for mongos nodes, replica set
         * instances, and single node instances.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node. This parameter is valid only for mongos nodes of
         * cluster instances, primary nodes and secondary nodes of replica set instances, and single node instances.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
    }

    export interface InstanceNode {
        /**
         * Specifies the ID of the template.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the private IP address of a node. This parameter is valid only for mongos nodes, replica set
         * instances, and single node instances.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node. This parameter is valid only for mongos nodes of
         * cluster instances, primary nodes and secondary nodes of replica set instances, and single node instances.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the node type. Valid value:
         * + For a cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For a replica set instance, the value is **replica**.
         */
        type: string;
    }

}

export namespace DedicatedApig {
    export interface ApiBackendParam {
        /**
         * Specifies the description of the constant or system parameter.  
         * The description contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter.  
         * The valid values are **PATH**, **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the type of the system parameter.  
         * The valid values are **frontend**, **backend** and **internal**, defaults to **internal**.
         */
        systemParamType?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the alias URN of the FunctionGraph function.  
         * The format is `{function_urn}:!{alias}`.
         */
        functionAliasUrn?: string;
        /**
         * Specifies the URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * Specifies the invocation mode of the FunctionGraph function.  
         * The valid values are **async** and **sync**, defaults to **sync**.
         */
        invocationType?: string;
        /**
         * Specifies the network architecture (framework) type of the FunctionGraph function.
         * **V1**: Non-VPC network framework.
         * **V2**: VPC network framework.
         */
        networkType?: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, defaults to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from `1` to `600,000`, defaults to `5,000`.
         */
        timeout?: number;
        /**
         * Specifies the version of the FunctionGraph function.  
         * Required if the parameter `functionAliasUrn` is omitted and this parameter is useless if the parameter
         * `functionAliasUrn` is set.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions.  
         * Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiFuncGraphPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, defaults to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the alias URN of the FunctionGraph function.  
         * The format is `{function_urn}:!{alias}`.
         */
        functionAliasUrn?: string;
        /**
         * Specifies the URN of the FunctionGraph function.
         */
        functionUrn: string;
        invocationMode?: string;
        /**
         * Specifies the invocation mode of the FunctionGraph function.  
         * The valid values are **async** and **sync**, defaults to **sync**.
         */
        invocationType?: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the network architecture (framework) type of the FunctionGraph function.
         * **V1**: Non-VPC network framework.
         * **V2**: VPC network framework.
         */
        networkType?: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, defaults to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from `1` to `600,000`, defaults to `5,000`.
         */
        timeout?: number;
        /**
         * Specifies the version of the FunctionGraph function.  
         * Required if the parameter `functionAliasUrn` is omitted and this parameter is useless if the parameter
         * `functionAliasUrn` is set.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter.  
         * The description contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter.  
         * The valid values are **PATH**, **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the type of the system parameter.  
         * The valid values are **frontend**, **backend** and **internal**, defaults to **internal**.
         */
        systemParamType?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * Specifies the cookie parameter name.
         * This parameter is required if the policy type is **cookie**.
         */
        cookieName?: string;
        /**
         * Specifies the frontend authentication parameter name.
         * This parameter is required if the policy type is **frontend_authorizer**. It consists of two parts,
         * the first part is the fixed format **$context.authorizer.frontend.**, and the second part is the
         * frontend authentication parameter name. e.g. **$context.authorizer.frontend.user_name**.
         */
        frontendAuthorizerName?: string;
        /**
         * Specifies the location of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter location must exist in the orchestration rule bound to the API.
         */
        mappedParamLocation?: string;
        /**
         * Specifies the name of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter name must exist in the orchestration rule bound to the API.
         */
        mappedParamName?: string;
        /**
         * Specifies the request parameter name.
         * This parameter is required if the policy type is **param**. The valid values are **user_age** and **X-TEST-ENUM**.
         */
        paramName?: string;
        /**
         * Specifies the backend policy type.  
         * The valid values are **param**, **source**, **system**, **cookie** and **frontend_authorizer**, defaults to **source**.
         */
        source?: string;
        /**
         * Specifies the gateway built-in parameter name.
         * This parameter is required if the policy type is **system**.
         * The valid values are **req_path** and **req_method**.
         */
        sysName?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type?: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the response content of the mock.  
         * The description contains a maximum of `2,048` characters and the angle brackets (< and >) are not allowed.
         */
        response?: string;
        /**
         * Specifies the custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiMockPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions.  
         * Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiMockPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, defaults to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the response content of the mock.  
         * The description contains a maximum of `2,048` characters and the angle brackets (< and >) are not allowed.
         */
        response?: string;
        /**
         * Specifies the custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter.  
         * The description contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter.  
         * The valid values are **PATH**, **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the type of the system parameter.  
         * The valid values are **frontend**, **backend** and **internal**, defaults to **internal**.
         */
        systemParamType?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * Specifies the cookie parameter name.
         * This parameter is required if the policy type is **cookie**.
         */
        cookieName?: string;
        /**
         * Specifies the frontend authentication parameter name.
         * This parameter is required if the policy type is **frontend_authorizer**. It consists of two parts,
         * the first part is the fixed format **$context.authorizer.frontend.**, and the second part is the
         * frontend authentication parameter name. e.g. **$context.authorizer.frontend.user_name**.
         */
        frontendAuthorizerName?: string;
        /**
         * Specifies the location of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter location must exist in the orchestration rule bound to the API.
         */
        mappedParamLocation?: string;
        /**
         * Specifies the name of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter name must exist in the orchestration rule bound to the API.
         */
        mappedParamName?: string;
        /**
         * Specifies the request parameter name.
         * This parameter is required if the policy type is **param**. The valid values are **user_age** and **X-TEST-ENUM**.
         */
        paramName?: string;
        /**
         * Specifies the backend policy type.  
         * The valid values are **param**, **source**, **system**, **cookie** and **frontend_authorizer**, defaults to **source**.
         */
        source?: string;
        /**
         * Specifies the gateway built-in parameter name.
         * This parameter is required if the policy type is **system**.
         * The valid values are **req_path** and **req_method**.
         */
        sysName?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type?: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiPublishmentHistory {
        /**
         * Specifies the description of the current publishment.
         */
        description: string;
        /**
         * Specifies the version ID of the current publishment.
         */
        versionId: string;
    }

    export interface ApiRequestParam {
        /**
         * Specifies the default value of the request parameter.
         * The value contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        default: string;
        /**
         * Specifies the description of the constant or system parameter.  
         * The description contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        description: string;
        /**
         * Specifies the enumerated value(s).
         * Use commas to separate multiple enumeration values, such as **VALUE_A,VALUE_B**.
         */
        enumeration: string;
        /**
         * Specifies the example value of the request parameter.  
         * The example contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        example: string;
        /**
         * Specifies the location of the backend parameter.  
         * The valid values are **PATH**, **QUERY** and **HEADER**.
         */
        location?: string;
        /**
         * Specifies the maximum value or size of the request parameter.
         */
        maximum: number;
        /**
         * Specifies the minimum value or size of the request parameter.
         */
        minimum: number;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the list of orchestration rule IDs which parameter used.  
         * The order of the IDs determines the priority of the rules, and the priority decreases according to the order of the
         * list elements.
         */
        orchestrations?: string[];
        /**
         * Specifies whether to transparently transfer the parameter.
         */
        passthrough: boolean;
        /**
         * Specifies whether the request parameter is required.
         */
        required: boolean;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type?: string;
        /**
         * Specifies whether to enable the parameter validation.
         * + **1**: enable
         * + **2**: disable (by default)
         */
        validEnable: number;
    }

    export interface ApiWeb {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the backend service address.  
         * The value which consists of a domain name or IP address, and a port number, with not more than `255` characters.
         * The backend service address must be in the format "{host name}:{Port number}", for example, `apig.example.com:7443`.
         * If the port number is not specified, the default HTTPS port `443`, or the default HTTP port `80` is used.
         * The backend service address can contain environment variables, each starting with a letter and consisting of `3` to
         * `32` characters. Only letters, digits, hyphens (-), and underscores (_) are allowed.
         */
        backendAddress?: string;
        /**
         * Specifies the proxy host header.  
         * The host header can be customized for requests to be forwarded to cloud servers through the VPC channel.
         * By default, the original host header of the request is used.
         */
        hostHeader?: string;
        /**
         * Specifies the backend request address, which can contain a maximum of `512` characters and
         * must comply with URI specifications.
         * + The address can contain request parameters enclosed with brackets ({}).
         * + The address can contain special characters, such as asterisks (*), percent signs (%), hyphens (-) and
         * underscores (_) and must comply with URI specifications.
         * + The address can contain environment variables, each starting with a letter and consisting of `3` to `32` characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed in environment variables.
         */
        path: string;
        /**
         * Specifies the backend request method of the API.  
         * The valid types are **GET**, **POST**, **PUT**, **DELETE**, **HEAD**, **PATCH**, **OPTIONS** and **ANY**.
         */
        requestMethod?: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, defaults to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the number of retry attempts to request the backend service.
         * The valid value ranges from `-1` to `10`, defaults to `-1`.
         * `-1` indicates that idempotent APIs will retry once and non-idempotent APIs will not retry.
         * **POST** and **PATCH** are not-idempotent.
         * **GET**, **HEAD**, **PUT**, **OPTIONS** and **DELETE** are idempotent.
         */
        retryCount?: number;
        /**
         * Specifies whether to enable two-way authentication, defaults to **false**.
         */
        sslEnable?: boolean;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from `1` to `600,000`, defaults to `5,000`.
         */
        timeout?: number;
        /**
         * Specifies the VPC channel ID.  
         * This parameter and `backendAddress` are alternative.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the backend service address.  
         * The value which consists of a domain name or IP address, and a port number, with not more than `255` characters.
         * The backend service address must be in the format "{host name}:{Port number}", for example, `apig.example.com:7443`.
         * If the port number is not specified, the default HTTPS port `443`, or the default HTTP port `80` is used.
         * The backend service address can contain environment variables, each starting with a letter and consisting of `3` to
         * `32` characters. Only letters, digits, hyphens (-), and underscores (_) are allowed.
         */
        backendAddress?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiWebPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions.  
         * Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiWebPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, defaults to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the proxy host header.  
         * The host header can be customized for requests to be forwarded to cloud servers through the VPC channel.
         * By default, the original host header of the request is used.
         */
        hostHeader?: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the backend request address, which can contain a maximum of `512` characters and
         * must comply with URI specifications.
         * + The address can contain request parameters enclosed with brackets ({}).
         * + The address can contain special characters, such as asterisks (*), percent signs (%), hyphens (-) and
         * underscores (_) and must comply with URI specifications.
         * + The address can contain environment variables, each starting with a letter and consisting of `3` to `32` characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed in environment variables.
         */
        path: string;
        /**
         * Specifies the backend request method of the API.  
         * The valid types are **GET**, **POST**, **PUT**, **DELETE**, **HEAD**, **PATCH**, **OPTIONS** and **ANY**.
         */
        requestMethod: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, defaults to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the number of retry attempts to request the backend service.
         * The valid value ranges from `-1` to `10`, defaults to `-1`.
         * `-1` indicates that idempotent APIs will retry once and non-idempotent APIs will not retry.
         * **POST** and **PATCH** are not-idempotent.
         * **GET**, **HEAD**, **PUT**, **OPTIONS** and **DELETE** are idempotent.
         */
        retryCount?: number;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from `1` to `600,000`, defaults to `5,000`.
         */
        timeout?: number;
        /**
         * Specifies the VPC channel ID.  
         * This parameter and `backendAddress` are alternative.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter.  
         * The description contains a maximum of `255` characters and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter.  
         * The valid values are **PATH**, **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name.  
         * The valid length is limited from `3` to `64`, only letters, digits and underscores (_) are allowed.
         * It must start with a letter.
         */
        name: string;
        /**
         * Specifies the type of the system parameter.  
         * The valid values are **frontend**, **backend** and **internal**, defaults to **internal**.
         */
        systemParamType?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * Specifies the cookie parameter name.
         * This parameter is required if the policy type is **cookie**.
         */
        cookieName?: string;
        /**
         * Specifies the frontend authentication parameter name.
         * This parameter is required if the policy type is **frontend_authorizer**. It consists of two parts,
         * the first part is the fixed format **$context.authorizer.frontend.**, and the second part is the
         * frontend authentication parameter name. e.g. **$context.authorizer.frontend.user_name**.
         */
        frontendAuthorizerName?: string;
        /**
         * Specifies the location of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter location must exist in the orchestration rule bound to the API.
         */
        mappedParamLocation?: string;
        /**
         * Specifies the name of a parameter generated after orchestration.
         * This parameter is required if the policy type is **orchestration**.
         * The generated parameter name must exist in the orchestration rule bound to the API.
         */
        mappedParamName?: string;
        /**
         * Specifies the request parameter name.
         * This parameter is required if the policy type is **param**. The valid values are **user_age** and **X-TEST-ENUM**.
         */
        paramName?: string;
        /**
         * Specifies the backend policy type.  
         * The valid values are **param**, **source**, **system**, **cookie** and **frontend_authorizer**, defaults to **source**.
         */
        source?: string;
        /**
         * Specifies the gateway built-in parameter name.
         * This parameter is required if the policy type is **system**.
         * The valid values are **req_path** and **req_method**.
         */
        sysName?: string;
        /**
         * Specifies the condition type of the backend policy.  
         * The valid values are **Equal**, **Enumerated** and **Matching**, defaults to **Equal**.
         * When the `sysName` is **req_method**, the valid values are **Equal** and **Enumerated**.
         */
        type?: string;
        /**
         * Specifies the value of the backend policy.  
         * For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface CustomAuthorizerIdentity {
        /**
         * Specifies the parameter location, which support **HEADER** and **QUERY**.
         */
        location: string;
        /**
         * Specifies the name of the parameter to be verified.
         * The parameter includes front-end and back-end parameters.
         */
        name: string;
        /**
         * Specifies the parameter verification expression.
         * If omitted, the custom authorizer will not perform verification.
         * The valid value is range form `1` to `2,048`.
         */
        validation?: string;
    }

    export interface GetEnvironmentsEnvironment {
        /**
         * Time when the APIG environment was created, in RFC-3339 format.
         */
        createTime: string;
        /**
         * The description about the API environment.
         */
        description: string;
        /**
         * ID of the APIG environment.
         */
        id: string;
        /**
         * Specifies the name of the API environment. The API environment name consists of 3 to 64
         * characters, starting with a letter. Only letters, digits and underscores (_) are allowed.
         */
        name: string;
    }

    export interface GroupEnvironment {
        /**
         * Specifies the environment ID of the associated group.
         */
        environmentId: string;
        /**
         * Specifies an array of one or more environment variables.  
         * The object structure is documented below.
         */
        variables: outputs.DedicatedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * The variable ID.
         */
        id: string;
        /**
         * Specifies the domain name. The valid must comply with the domian name specifications.
         */
        name: string;
        /**
         * Specifies the variable value.  
         * The valid length is limited from `1` to `255` characters.
         * Only letters, digits and special characters (_-/.:) are allowed.
         */
        value: string;
        /**
         * @deprecated Use 'id' instead
         */
        variableId: string;
    }

    export interface GroupUrlDomain {
        /**
         * Specifies whether to enable redirection from `HTTP` to `HTTPS`.
         * The default value is `false`.
         */
        isHttpRedirectToHttps: boolean;
        /**
         * Specifies the minimum TLS version that can be used to access the domain name,
         * the default value is `TLSv1.2`.
         * The valid values are as follows:
         * + **TLSv1.1**
         * + **TLSv1.2**
         */
        minSslVersion: string;
        /**
         * Specifies the domain name. The valid must comply with the domian name specifications.
         */
        name: string;
    }

    export interface InstanceCustomIngressPort {
        /**
         * The ID of the custom ingress port.
         */
        id: string;
        /**
         * Specified port of the custom ingress port.
         * The valid value is range form `1,024` to `49,151`.
         */
        port: number;
        /**
         * Specified protocol of the custom ingress port.  
         * The valid values are as follows:
         * + **HTTP**
         * + **HTTPS**
         */
        protocol: string;
        /**
         * The current status of the custom ingress port.
         * + **normal**
         * + **abnormal**
         */
        status: string;
    }

    export interface ResponseRule {
        /**
         * Specifies the body template of the API response rule, e.g.
         * `{\"code\":\"$context.authorizer.frontend.code\",\"message\":\"$context.authorizer.frontend.message\"}`
         */
        body: string;
        /**
         * Specifies the error type of the API response rule.
         * The valid values and the related default status code are as follows:
         * + **ACCESS_DENIED**: (**403**) Access denied.
         * + **AUTH_FAILURE**: (**401**) Authentication failed.
         * + **AUTH_HEADER_MISSING**: (**401**) The identity source is missing.
         * + **AUTHORIZER_CONF_FAILURE**: (**500**) There has been a custom authorizer error.
         * + **AUTHORIZER_FAILURE**: (**500**) Custom authentication failed.
         * + **AUTHORIZER_IDENTITIES_FAILURE**: (**401**) The identity source of the custom authorizer is invalid.
         * + **BACKEND_TIMEOUT**: (**504**) Communication with the backend service timed out.
         * + **BACKEND_UNAVAILABLE**: (**502**) The backend service is unavailable.
         * + **NOT_FOUND**: (**404**) No API is found.
         * + **REQUEST_PARAMETERS_FAILURE**: (**400**) The request parameters are incorrect.
         * + **THROTTLED**: (**429**) The request was rejected due to request throttling.
         * + **UNAUTHORIZED**: (**401**) The app you are using has not been authorized to call the API.
         * + **DEFAULT_4XX**: (**NONE**) Another 4XX error occurred.
         * + **DEFAULT_5XX**: (**NONE**) Another 5XX error occurred.
         * + **THIRD_AUTH_CONF_FAILURE**: (**500**) Third-party authorizer configuration error.
         * + **THIRD_AUTH_FAILURE**: (**401**) Third-party authentication failed.
         * + **THIRD_AUTH_IDENTITIES_FAILURE**: (**401**) Identity source of the third-party authorizer is invalid.
         */
        errorType: string;
        /**
         * Specifies the configuration of the custom response headers.  
         * The headers structure is documented below.
         */
        headers?: outputs.DedicatedApig.ResponseRuleHeader[];
        /**
         * Specifies the HTTP status code of the API response rule.
         * The valid value is range from `200` to `599`.
         */
        statusCode: number;
    }

    export interface ResponseRuleHeader {
        /**
         * Specifies the key name of the response header.
         * The valid length is limited from `1` to `128`, only English letters, digits and hyphens (-) are allowed.
         */
        key: string;
        /**
         * Specifies the value for the specified response header key.
         * The valid length is limited from `1` to `1,024`.
         */
        value: string;
    }

    export interface ThrottlingPolicyAppThrottle {
        /**
         * ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * Specifies the maximum number of times an API can be accessed within a specified
         * period.
         */
        maxApiRequests: number;
        /**
         * Specifies the object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface ThrottlingPolicyUserThrottle {
        /**
         * ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * Specifies the maximum number of times an API can be accessed within a specified
         * period.
         */
        maxApiRequests: number;
        /**
         * Specifies the object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface VpcChannelMember {
        /**
         * Specifies the ECS ID for each backend servers.
         * Required if the `memberType` is **ECS**.
         * This parameter and `ipAddress` are alternative.
         */
        id?: string;
        /**
         * Specifies the IP address each backend servers.
         * Required if the `memberType` is **EIP**.
         */
        ipAddress?: string;
        /**
         * Specifies the backend server weight.
         * The valid value ranges from `1` to `100`, defaults to `1`.
         */
        weight?: number;
    }

}

export namespace DedicatedElb {
    export interface ActiveStandbyPoolHealthmonitor {
        /**
         * Specifies the interval between health checks, in seconds. The value range is from
         * `1` to `50`. Changing this parameter will create a new resource.
         */
        delay: number;
        /**
         * Specifies the domain name that HTTP requests are sent to during the health
         * check. The value can contain only digits, letters, hyphens (-), and periods (.) and must start with a digit or letter.
         * The value is left blank by default, indicating that the virtual IP address of the load balancer is used as the
         * destination address of HTTP requests. This parameter is available only when `type` is set to **HTTP**. The length
         * range of value is from `1` to `100`. Changing this parameter will create a new resource.
         */
        domainName: string;
        /**
         * Specifies the expected HTTP status code. This parameter will take
         * effect only when `type` is set to **HTTP** or **HTTPS**. The default value is 200. Multiple status codes can be
         * queried in the format of expected_codes=xxx&expected_codes=xxx. The length range of value is from `1` to `64`.
         * Value options:
         * + A specific value, for example, **200**
         * + A list of values that are separated with commas (,), for example, **200**, **202**
         * + A value range, for example, **200-204**
         */
        expectedCodes: string;
        /**
         * Specifies the HTTP method. The value can be **GET**, **HEAD**, **POST**.
         * Default to **GET**. This parameter is available when `type` is set to **HTTP** or **HTTPS**.
         */
        httpMethod: string;
        /**
         * The health check ID.
         */
        id: string;
        /**
         * Specifies the number of consecutive health checks when the health check
         * result of a backend server changes from **OFFLINE** to **ONLINE**. The value range is from `1` to `10`. Changing
         * this parameter will create a new resource.
         */
        maxRetries: number;
        /**
         * Specifies the number of consecutive health checks when the health check
         * result of a backend server changes from ONLINE to OFFLINE. The value range is from `1` to `10`. Defaults to `3`.
         * Changing this parameter will create a new resource.
         */
        maxRetriesDown: number;
        /**
         * Specifies the port used for the health check. If this parameter is left
         * blank, a port of the backend server will be used by default. The value range is from `1` to `65,535`. Changing this
         * parameter will create a new resource.
         */
        monitorPort: number;
        /**
         * Specifies the health check name. The length range of value is from `1` to `255`.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the maximum time required for waiting for a response from the health
         * check, in seconds. It is recommended that you set the value less than that of parameter `delay`. The value range is
         * from `1` to `50`. Changing this parameter will create a new resource.
         */
        timeout: number;
        /**
         * Specifies the health check protocol. Value options: **TCP**, **UDP_CONNECT**,
         * **HTTP**, and **HTTPS**.
         * + If the protocol of the backend server is **QUIC**, the value can only be **UDP_CONNECT**.
         * + If the protocol of the backend server is **UDP**, the value can only be **UDP_CONNECT**.
         * + If the protocol of the backend server is **TCP**, the value can only be **TCP**, **HTTP**, or **HTTPS**.
         * + If the protocol of the backend server is **HTTP**, the value can only be **TCP**, **HTTP**, or **HTTPS**.
         * + If the protocol of the backend server is **HTTPS**, the value can only be **TCP**, **HTTP**, or **HTTPS**.
         */
        type: string;
        /**
         * Specifies the HTTP request path for the health check. The value must start
         * with a slash (/), and the default value is /. The value can contain letters, digits, hyphens (-), slashes (/),
         * periods (.), percentage signs (%), question marks (?), pound signs (#), ampersand signs (&), and the extended character
         * set **_;~!()*[]@$^:',+**. The length range of value is from `1` to `80`. Changing this parameter will create a new
         * resource.
         */
        urlPath: string;
    }

    export interface ActiveStandbyPoolMember {
        /**
         * Specifies the private IP address bound to the member.
         * + If `subnetId` is left blank, IP as a Backend is enabled. In this case, the IP address must be an **IPv4** address.
         * + If `subnetId` is not left blank, the IP address can be **IPv4** or **IPv6**. It must be in the subnet specified
         * by `subnetId` and can only be bound to the primary NIC of the backend server.
         */
        address: string;
        /**
         * The health check ID.
         */
        id: string;
        /**
         * The ID of the ECS used as the member.
         */
        instanceId: string;
        /**
         * Specifies the IP address version supported by active-standby pool.
         * The value can be **dualstack**, **v6**, or **v4**. Changing this parameter will create a new resource.
         */
        ipVersion: string;
        /**
         * The type of the member.
         */
        memberType: string;
        /**
         * Specifies the health check name. The length range of value is from `1` to `255`.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * The health status of the member.
         */
        operatingStatus: string;
        /**
         * Specifies the port used by the member to receive requests. It is mandatory
         * if `anyPortEnable` is **false**, and it does not take effect if `anyPortEnable` is set to **true**. The value range
         * is from `1` to `65,535`. Changing this parameter will create a new resource.
         */
        protocolPort: number;
        /**
         * Specifies the type of the member. Value options:
         * + **master**: active backend server.
         * + **slave**: standby backend server.
         */
        role: string;
        /**
         * Specifies the ID of the IPv4 or IPv6 subnet where the member resides.
         * + The IPv4 or IPv6 subnet must be in the same VPC as the subnet of the load balancer.
         * + If this parameter is not passed, IP as a Backend has been enabled for the load balancer. In this case, IP as backend
         * servers must use private IPv4 addresses, and the protocol of the active-standby pool must be **TCP**, **HTTP**, or
         * **HTTPS**.
         */
        subnetId: string;
    }

    export interface GetActiveStandbyPoolsPool {
        /**
         * Whether to enable Forward to same Port for a pool.
         */
        anyPortEnable: boolean;
        /**
         * Whether to enable delayed logout.
         */
        connectionDrainEnabled: boolean;
        /**
         * The timeout of the delayed logout in seconds.
         */
        connectionDrainTimeout: number;
        /**
         * Specifies supplementary information about the active-standby pool.
         */
        description: string;
        /**
         * The health check configured for the active-standby pool.
         * The healthmonitor structure is documented below.
         */
        healthmonitors: outputs.DedicatedElb.GetActiveStandbyPoolsPoolHealthmonitor[];
        /**
         * The health check ID.
         */
        id: string;
        /**
         * The IDs of the listeners with which the active-standby pool is associated.
         * The listeners structure is documented below.
         */
        listeners: outputs.DedicatedElb.GetActiveStandbyPoolsPoolListener[];
        /**
         * The IDs of the load balancers with which the active-standby pool is associated.
         * The loadbalancers structure is documented below.
         */
        loadbalancers: outputs.DedicatedElb.GetActiveStandbyPoolsPoolLoadbalancer[];
        /**
         * The backend servers in the active-standby pool.
         * The members structure is documented below.
         */
        members: outputs.DedicatedElb.GetActiveStandbyPoolsPoolMember[];
        /**
         * Specifies the name of the active-standby pool.
         */
        name: string;
        /**
         * Specifies the protocol used by the active-standby pool to receive requests from the
         * load balancer. Value options: **TCP**, **UDP**, **QUIC** or **TLS**.
         */
        protocol: string;
        /**
         * Specifies the type of the active-standby pool.
         * The valid values are as follows:
         * + **instance**: Any type of backend servers can be added.
         * + **ip**: Only IP as backend servers can be added.
         */
        type: string;
        /**
         * Specifies the ID of the VPC where the active-standby pool works.
         */
        vpcId: string;
    }

    export interface GetActiveStandbyPoolsPoolHealthmonitor {
        /**
         * The interval between health checks, in seconds.
         */
        delay: number;
        /**
         * The domain name that HTTP requests are sent to during the health check.
         */
        domainName: string;
        /**
         * The expected HTTP status code.
         */
        expectedCodes: string;
        /**
         * The HTTP method.
         */
        httpMethod: string;
        /**
         * The health check ID.
         */
        id: string;
        /**
         * The number of consecutive health checks when the health check result of a backend server changes from
         * **OFFLINE** to **ONLINE**.
         */
        maxRetries: number;
        /**
         * The number of consecutive health checks when the health check result of a backend server changes
         * from **ONLINE** to **OFFLINE**.
         */
        maxRetriesDown: number;
        /**
         * The port used for the health check.
         */
        monitorPort: number;
        /**
         * Specifies the name of the active-standby pool.
         */
        name: string;
        /**
         * The maximum time required for waiting for a response from the health check, in seconds.
         */
        timeout: number;
        /**
         * Specifies the type of the active-standby pool.
         * The valid values are as follows:
         * + **instance**: Any type of backend servers can be added.
         * + **ip**: Only IP as backend servers can be added.
         */
        type: string;
        /**
         * The HTTP request path for the health check.
         */
        urlPath: string;
    }

    export interface GetActiveStandbyPoolsPoolListener {
        /**
         * The health check ID.
         */
        id: string;
    }

    export interface GetActiveStandbyPoolsPoolLoadbalancer {
        /**
         * The health check ID.
         */
        id: string;
    }

    export interface GetActiveStandbyPoolsPoolMember {
        /**
         * The private IP address bound to the member.
         */
        address: string;
        /**
         * The health check ID.
         */
        id: string;
        /**
         * The ID of the ECS used as the member.
         */
        instanceId: string;
        /**
         * The IP version supported by the member.
         */
        ipVersion: string;
        /**
         * The type of the member.
         */
        memberType: string;
        /**
         * Specifies the name of the active-standby pool.
         */
        name: string;
        /**
         * The health status of the member.
         */
        operatingStatus: string;
        /**
         * The port used by the member to receive requests.
         */
        protocolPort: number;
        /**
         * The active-standby status of the member.
         */
        role: string;
        /**
         * The ID of the IPv4 or IPv6 subnet where the member resides.
         */
        subnetId: string;
    }

    export interface GetAllMembersMember {
        /**
         * Specifies the IP address of the backend server.
         * Multiple IP addresses can be queried.
         */
        address: string;
        /**
         * Indicates the time when a backend server was added.
         */
        createdAt: string;
        /**
         * Indicates the backend server ID.
         */
        id: string;
        /**
         * Specifies the IP address version supported by the backend server group.
         * The value can be **v4** or **v6**.
         * Multiple versions can be queried.
         */
        ipVersion: string;
        /**
         * Specifies the ID of the load balancer with which the load balancer is associated.
         * Multiple IDs can be queried.
         */
        loadbalancerId: string;
        /**
         * Indicates the type of the backend server.
         */
        memberType: string;
        /**
         * Specifies the backend server name.
         * Multiple IDs can be queried.
         */
        name: string;
        /**
         * Specifies the operating status of the backend server.
         * Value options:
         * + **ONLINE**: The backend server is running normally.
         * + **NO_MONITOR**: No health check is configured for the backend server group to which the backend server belongs.
         * + **OFFLINE**: The cloud server used as the backend server is stopped or does not exist.
         * Multiple statuses can be queried.
         */
        operatingStatus: string;
        /**
         * Specifies the ID of the backend server group to which the backend server belongs.
         * Multiple IDs can be queried.
         */
        poolId: string;
        /**
         * Indicates the ID of the project where the backend server is used.
         */
        projectId: string;
        /**
         * Specifies the port used by the backend servers.
         * Multiple ports can be queried.
         */
        protocolPort: number;
        /**
         * Indicates why health check fails.
         */
        reasons: outputs.DedicatedElb.GetAllMembersMemberReason[];
        /**
         * Indicates the health status of the backend server.
         */
        statuses: outputs.DedicatedElb.GetAllMembersMemberStatus[];
        /**
         * Specifies the ID of the subnet where the backend server works.
         * Multiple IDs can be queried.
         */
        subnetCidrId: string;
        /**
         * Indicates the time when a backend server was updated.
         */
        updatedAt: string;
        /**
         * Specifies the weight of the backend server.
         * Multiple weights can be queried.
         */
        weight: number;
    }

    export interface GetAllMembersMemberReason {
        /**
         * Indicates the expected HTTP status code.
         */
        expectedResponse: string;
        /**
         * Indicates the returned HTTP status code in the response.
         */
        healthcheckResponse: string;
        /**
         * Indicates the code of the health check failures.
         */
        reasonCode: string;
    }

    export interface GetAllMembersMemberStatus {
        /**
         * Indicates the listener ID.
         */
        listenerId: string;
        /**
         * Specifies the operating status of the backend server.
         * Value options:
         * + **ONLINE**: The backend server is running normally.
         * + **NO_MONITOR**: No health check is configured for the backend server group to which the backend server belongs.
         * + **OFFLINE**: The cloud server used as the backend server is stopped or does not exist.
         * Multiple statuses can be queried.
         */
        operatingStatus: string;
        /**
         * Indicates why health check fails.
         */
        reasons: outputs.DedicatedElb.GetAllMembersMemberStatusReason[];
    }

    export interface GetAllMembersMemberStatusReason {
        /**
         * Indicates the expected HTTP status code.
         */
        expectedResponse: string;
        /**
         * Indicates the returned HTTP status code in the response.
         */
        healthcheckResponse: string;
        /**
         * Indicates the code of the health check failures.
         */
        reasonCode: string;
    }

    export interface GetAvailabilityZonesAvailabilityZone {
        /**
         * Indicates the AZs list.
         * The list structure is documented below.
         */
        lists: outputs.DedicatedElb.GetAvailabilityZonesAvailabilityZoneList[];
    }

    export interface GetAvailabilityZonesAvailabilityZoneList {
        /**
         * Indicates the AZ code. The value can be:
         * + **0**: indicates center.
         * + **21**: indicates homezone.
         */
        category: number;
        /**
         * Indicates the AZ code.
         */
        code: string;
        /**
         * Indicates the type of the flavor that is not sold out. The value can be:
         * + **L4**: indicates the flavor at Layer 4 (flavor for network load balancing).
         * + **L7**: indicates the flavor at Layer 7 (flavor for application load balancing).
         */
        protocols: string[];
        /**
         * Specifies the public border group.
         */
        publicBorderGroup: string;
        /**
         * Indicates the AZ status. The value can only be **ACTIVE**.
         */
        state: string;
    }

    export interface GetFeatureConfigurationsConfig {
        /**
         * Indicates the configuration creator.
         */
        caller: string;
        /**
         * Indicates the creation time.
         */
        createdAt: string;
        /**
         * Indicates the feature configuration description.
         */
        description: string;
        /**
         * Specifies the feature name.
         */
        feature: string;
        /**
         * Indicates the ID of the configuration.
         */
        id: string;
        /**
         * Indicates the service. The value is fixed at **ELB**.
         */
        service: string;
        /**
         * Indicates whether to enable feature configuration.
         * The value can be:
         * + **true**: The feature configuration has taken effect.
         * + **false**: The feature configuration does not take effect.
         */
        switch: boolean;
        /**
         * Indicates the type of the feature configuration value.
         */
        type: string;
        /**
         * Indicates the update time.
         */
        updatedAt: string;
        /**
         * Indicates the feature configuration value.
         * For example, the value **true** or **false** indicates that the feature is enabled or disabled.
         * The feature value of the quota is an integer, indicating that the quota is limited.
         */
        value: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * Specifies the bandwidth size(Mbit/s) in the flavor.
         */
        bandwidth: number;
        /**
         * Specifies the cps in the flavor.
         */
        cps: number;
        /**
         * ID of the flavor.
         */
        id: string;
        /**
         * Specifies the maximum connections in the flavor.
         */
        maxConnections: number;
        /**
         * Specifies the flavor name.
         */
        name: string;
        /**
         * Specifies the qps in the L7 flavor.
         */
        qps: number;
        /**
         * Specifies the flavor type. Values options:
         * + **L4**: indicates Layer-4 flavor.
         * + **L7**: indicates Layer-7 flavor.
         * + **L4_elastic**: indicates minimum Layer-4 flavor for elastic scaling.
         * + **L7_elastic**: indicates minimum Layer-7 flavor for elastic scaling.
         * + **L4_elastic_max**: indicates maximum Layer-4 flavor for elastic scaling.
         * + **L7_elastic_max**: indicates maximum Layer-7 flavor for elastic scaling
         */
        type: string;
    }

    export interface GetIpgroupsIpgroup {
        /**
         * The time when the IP address group was created.
         */
        createdAt: string;
        /**
         * Specifies the description of the IP address group.
         */
        description: string;
        /**
         * The listener ID.
         */
        id: string;
        /**
         * The IP addresses or CIDR blocks in the IP address group. The ipList structure is
         * documented below.
         */
        ipLists: outputs.DedicatedElb.GetIpgroupsIpgroupIpList[];
        /**
         * The IDs of listeners with which the IP address group is associated. The listeners
         * structure is documented below.
         */
        listeners: outputs.DedicatedElb.GetIpgroupsIpgroupListener[];
        /**
         * Specifies the name of the IP address group.
         */
        name: string;
        /**
         * The project ID of the IP address group.
         */
        projectId: string;
        /**
         * The time when the IP address group was updated.
         */
        updatedAt: string;
    }

    export interface GetIpgroupsIpgroupIpList {
        /**
         * Specifies the description of the IP address group.
         */
        description: string;
        /**
         * The IP addresses.
         */
        ip: string;
    }

    export interface GetIpgroupsIpgroupListener {
        /**
         * The listener ID.
         */
        id: string;
    }

    export interface GetL7policiesL7policy {
        /**
         * Specifies the requests are forwarded. The value can be one of the following:
         * + **REDIRECT_TO_POOL**: Requests are forwarded to another backend server group.
         * + **REDIRECT_TO_LISTENER**: Requests are redirected to an HTTPS listener.
         * + **REDIRECT_TO_URL**: Requests are redirected to another URL.
         * + **FIXED_RESPONSE**: A fixed response body is returned.
         */
        action: string;
        /**
         * The time when the forwarding policy was created.
         */
        createdAt: string;
        /**
         * Specifies the supplementary information about the forwarding policy.
         */
        description: string;
        /**
         * The configuration of the page that will be returned.
         * The fixedResponseConfig structure is documented below.
         */
        fixedResponseConfigs: outputs.DedicatedElb.GetL7policiesL7policyFixedResponseConfig[];
        /**
         * The forwarding rule ID.
         */
        id: string;
        /**
         * Specifies the ID of the listener to which the forwarding policy is added.
         */
        listenerId: string;
        /**
         * Specifies the forwarding policy name.
         */
        name: string;
        /**
         * Specifies the forwarding policy priority.
         */
        priority: number;
        /**
         * Specifies the ID of the listener to which requests are redirected.
         */
        redirectListenerId: string;
        /**
         * Specifies the ID of the backend server group to which requests will be forwarded.
         */
        redirectPoolId: string;
        /**
         * The backend server group that the requests are forwarded to.
         * The redirectPoolsExtendConfig structure is documented below.
         */
        redirectPoolsExtendConfigs: outputs.DedicatedElb.GetL7policiesL7policyRedirectPoolsExtendConfig[];
        /**
         * The URL to which requests are forwarded. The redirectUrlConfig
         * structure is documented below.
         */
        redirectUrlConfigs: outputs.DedicatedElb.GetL7policiesL7policyRedirectUrlConfig[];
        /**
         * The forwarding rules in the forwarding policy. The rules structure is documented below.
         */
        rules: outputs.DedicatedElb.GetL7policiesL7policyRule[];
        /**
         * The time when the forwarding policy was updated.
         */
        updatedAt: string;
    }

    export interface GetL7policiesL7policyFixedResponseConfig {
        /**
         * The format of the response body.
         */
        contentType: string;
        /**
         * The content of the response message body.
         */
        messageBody: string;
        /**
         * The status code returned after the requests are redirected.
         */
        statusCode: string;
    }

    export interface GetL7policiesL7policyRedirectPoolsExtendConfig {
        /**
         * The URL for the backend server group that requests are forwarded to.
         * The rewriteUrlConfig structure is documented below.
         */
        rewriteUrlConfigs: outputs.DedicatedElb.GetL7policiesL7policyRedirectPoolsExtendConfigRewriteUrlConfig[];
        /**
         * Whether to enable URL redirection.
         */
        rewriteUrlEnabled: boolean;
    }

    export interface GetL7policiesL7policyRedirectPoolsExtendConfigRewriteUrlConfig {
        /**
         * The url host.
         */
        host: string;
        /**
         * The URL path.
         */
        path: string;
        /**
         * The URL query character string.
         */
        query: string;
    }

    export interface GetL7policiesL7policyRedirectUrlConfig {
        /**
         * The url host.
         */
        host: string;
        /**
         * The URL path.
         */
        path: string;
        /**
         * The port that requests are redirected to.
         */
        port: string;
        /**
         * The protocol for redirection.The value can be **HTTP**, **HTTPS**, or **${protocol}**.
         */
        protocol: string;
        /**
         * The URL query character string.
         */
        query: string;
        /**
         * The status code returned after the requests are redirected.
         */
        statusCode: string;
    }

    export interface GetL7policiesL7policyRule {
        /**
         * The forwarding rule ID.
         */
        id: string;
    }

    export interface GetL7rulesL7rule {
        /**
         * Specifies how requests are matched with the domain names or URL. Values options:
         * **EQUAL_TO**, **REGEX**, **STARTS_WITH**.
         */
        compareType: string;
        /**
         * The matching conditions of the forwarding rule. The conditions structure is
         * documented below.
         */
        conditions: outputs.DedicatedElb.GetL7rulesL7ruleCondition[];
        /**
         * The time when the forwarding rule was created.
         */
        createdAt: string;
        /**
         * The ID of the forwarding policy.
         */
        id: string;
        /**
         * Specifies the match type. Value options: **HOST_NAME**, **PATH**, **METHOD**, **HEADER**,
         * **QUERY_STRING**, **SOURCE_IP**, **COOKIE**.
         */
        type: string;
        /**
         * The time when the forwarding rule was updated.
         */
        updatedAt: string;
        /**
         * Specifies the value of the match content.
         */
        value: string;
    }

    export interface GetL7rulesL7ruleCondition {
        /**
         * The key of match item.
         */
        key: string;
        /**
         * Specifies the value of the match content.
         */
        value: string;
    }

    export interface GetListenersListener {
        /**
         * Whether to enable advanced forwarding.
         */
        advancedForwardingEnabled: boolean;
        /**
         * The ID of the CA certificate used by the listener.
         */
        caCertificate: string;
        /**
         * The ID of the default backend server group.
         */
        defaultPoolId: string;
        /**
         * Specifies the description of the ELB listener.
         */
        description: string;
        /**
         * Whether to transparently transmit the load balancer EIP to backend servers.
         */
        forwardEip: boolean;
        /**
         * Whether to rewrite the X-Forwarded-Host header.
         */
        forwardHost: boolean;
        /**
         * Whether to transparently transmit the listening port of the load balancer to backend servers.
         */
        forwardPort: boolean;
        /**
         * Whether to transparently transmit the source port of the client to backend servers.
         */
        forwardRequestPort: boolean;
        /**
         * Whether to use HTTP/2 if you want the clients to use HTTP/2 to communicate with the listener.
         */
        http2Enable: boolean;
        /**
         * The listener ID.
         */
        id: string;
        /**
         * The idle timeout duration, in seconds.
         */
        idleTimeout: number;
        /**
         * Specifies the ID of the load balancer that the listener is added to.
         */
        loadbalancerId: string;
        /**
         * Specifies the name of the ELB listener.
         */
        name: string;
        /**
         * The reason for update protection.
         */
        protectionReason: string;
        /**
         * The protection status for update.
         */
        protectionStatus: string;
        /**
         * Specifies the protocol of the ELB listener. Value options:
         * **TCP**, **UDP**, **HTTP**, **HTTPS** or **QUIC**.
         */
        protocol: string;
        /**
         * Specifies the port used by the listener.
         */
        protocolPort: number;
        /**
         * The timeout duration for waiting for a response from a client, in seconds.
         */
        requestTimeout: number;
        /**
         * The timeout duration for waiting for a response from a backend server, in seconds.
         */
        responseTimeout: number;
        /**
         * The ID of the server certificate used by the listener.
         */
        serverCertificate: string;
        /**
         * The IDs of SNI certificates (server certificates with domain names) used by the listener.
         */
        sniCertificates: string[];
        /**
         * The security policy used by the listener.
         */
        tlsCiphersPolicy: string;
    }

    export interface GetLoadbalancerFeatureConfigurationsFeature {
        /**
         * Specifies the feature name.
         */
        feature: string;
        /**
         * Specifies the type of the feature configuration value.
         */
        type: string;
        /**
         * Specifies the feature value.
         * For example, the value **true** or **false** indicates that the feature is enabled or disabled.
         * The feature value of the quota is an integer, indicating that the quota is limited.
         */
        value: string;
    }

    export interface GetLoadbalancersLoadbalancer {
        /**
         * Whether the current load balancer enables elastic expansion.
         */
        autoscalingEnabled: boolean;
        /**
         * The list of AZs where the load balancer is created.
         */
        availabilityZones: string[];
        /**
         * Lists the IDs of subnets on the downstream plane.
         */
        backendSubnets: string[];
        /**
         * Whether to enable IP as a Backend Server.
         */
        crossVpcBackend: boolean;
        /**
         * Specifies the description of the ELB load balancer.
         */
        description: string;
        /**
         * Specifies the enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * The flavor ID of the gateway load balancer.
         */
        gwFlavorId: string;
        /**
         * The load balancer ID.
         */
        id: string;
        /**
         * The private IPv4 address bound to the load balancer.
         */
        ipv4Address: string;
        /**
         * The ID of the port bound to the private IPv4 address of the load balancer.
         */
        ipv4PortId: string;
        /**
         * Specifies the ID of the IPv4 subnet where the load balancer resides.
         */
        ipv4SubnetId: string;
        /**
         * The IPv6 address bound to the load balancer.
         */
        ipv6Address: string;
        /**
         * Specifies the ID of the port bound to the IPv6 address of the load balancer.
         */
        ipv6NetworkId: string;
        /**
         * Specifies the ID of a flavor at Layer 4.
         */
        l4FlavorId: string;
        /**
         * Specifies the ID of a flavor at Layer 7.
         */
        l7FlavorId: string;
        /**
         * The type of the load balancer.
         */
        loadbalancerType: string;
        /**
         * The minimum seven-layer specification ID (specification type L7_elastic) for elastic expansion
         * and contraction
         */
        minL7FlavorId: string;
        /**
         * Specifies the name of the ELB load balancer.
         */
        name: string;
        /**
         * The reason for update protection.
         */
        protectionReason: string;
        /**
         * The protection status for update.
         */
        protectionStatus: string;
        /**
         * Specifies whether the load balancer is a dedicated load balancer, Value options:
         * **dedicated**, **share**.
         */
        type: string;
        /**
         * Specifies the ID of the VPC where the load balancer resides.
         */
        vpcId: string;
    }

    export interface GetLogtanksLogtank {
        /**
         * The log ID.
         */
        id: string;
        /**
         * Specifies the ID of a load balancer
         */
        loadbalancerId: string;
        /**
         * Specifies the log group ID.
         */
        logGroupId: string;
        /**
         * Specifies the log topic ID.
         */
        logTopicId: string;
    }

    export interface GetMonitorsMonitor {
        /**
         * Specifies the domain name to which HTTP requests are sent during the health check.
         * The value can be digits, letters, hyphens (-), or periods (.) and must start with a digit or letter.
         */
        domainName: string;
        /**
         * The health check ID.
         */
        id: string;
        /**
         * Specifies the interval between health checks, in seconds.  
         * The value ranges from `1` to `50`.
         */
        interval: number;
        /**
         * Specifies the number of consecutive health checks when the health check result of a
         * backend server changes from **OFFLINE** to **ONLINE**.
         */
        maxRetries: number;
        /**
         * Specifies the number of consecutive health checks when the health check result of
         * a backend server changes from **ONLINE** to **OFFLINE**. The value ranges from `1` to `10`.
         */
        maxRetriesDown: number;
        /**
         * Specifies the health check name.
         */
        name: string;
        /**
         * Specifies the ID of backend server groups for which the health check is configured.
         */
        poolId: string;
        /**
         * Specifies the port used for the health check.
         */
        port: number;
        /**
         * Specifies the health check protocol. The value can be **TCP**, **UDP_CONNECT**,
         * **HTTP**, **HTTPS**, **GRPC** or **TLS**.
         */
        protocol: string;
        /**
         * Specifies the expected HTTP status code. This parameter will take effect only when
         * type is set to **HTTP** or **HTTPS**.Value options:
         * + A specific value, for example, **200**
         * + A list of values that are separated with commas (,), for example, **200**, **202**
         * + A value range, for example, **200**-**204**
         */
        statusCode: string;
        /**
         * Specifies the maximum time required for waiting for a response from the health check, in
         * seconds.
         */
        timeout: number;
        /**
         * Specifies the HTTP request path for the health check. The value must start with a slash
         * (/), and the default value is **&#47;**. This parameter is available only when type is set to **HTTP**.
         */
        urlPath: string;
    }

    export interface GetPoolsPool {
        /**
         * Whether to enable delayed logout.
         */
        connectionDrainEnabled: boolean;
        /**
         * The timeout of the delayed logout in seconds.
         */
        connectionDrainTimeout: number;
        /**
         * Specifies the description of the ELB pool.
         */
        description: string;
        /**
         * Specifies the health monitor ID of the ELB pool.
         */
        healthmonitorId: string;
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
        /**
         * The IP version of the LB pool.
         */
        ipVersion: string;
        /**
         * Specifies the method of the ELB pool. Value options: **ROUND_ROBIN**,
         * **LEAST_CONNECTIONS**, **SOURCE_IP** or **QUIC_CID**.
         */
        lbMethod: string;
        /**
         * The listener list. The object structure is documented below.
         */
        listeners: outputs.DedicatedElb.GetPoolsPoolListener[];
        /**
         * The loadbalancer list. The object structure is documented below.
         */
        loadbalancers: outputs.DedicatedElb.GetPoolsPoolLoadbalancer[];
        /**
         * The member list. The object structure is documented below.
         */
        members: outputs.DedicatedElb.GetPoolsPoolMember[];
        /**
         * The minimum healthy member count.
         */
        minimumHealthyMemberCount: number;
        /**
         * Specifies the name of the ELB pool.
         */
        name: string;
        /**
         * Indicates whether connections in the same session will be processed by the same pool member or not.
         * The object structure is documented below.
         */
        persistences: outputs.DedicatedElb.GetPoolsPoolPersistence[];
        /**
         * The reason for update protection.
         */
        protectionReason: string;
        /**
         * Specifies the protection status for update.
         * Value options: **nonProtection**, **consoleProtection**.
         */
        protectionStatus: string;
        /**
         * Specifies the protocol of the ELB pool. Value options: **TCP**, **UDP**, **HTTP**,
         * **HTTPS**, **QUIC**, **GRPC** or **TLS**.
         */
        protocol: string;
        /**
         * The slow start duration, in seconds.
         */
        slowStartDuration: number;
        /**
         * Whether to enable slow start.
         */
        slowStartEnabled: boolean;
        /**
         * Specifies the type of the backend server group. Value options: **instance**, **ip**.
         */
        type: string;
        /**
         * Specifies the ID of the VPC where the backend server group works.
         */
        vpcId: string;
    }

    export interface GetPoolsPoolListener {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolMember {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately.
         */
        cookieName: string;
        /**
         * The stickiness duration, in minutes.
         */
        timeout: number;
        /**
         * Specifies the type of the backend server group. Value options: **instance**, **ip**.
         */
        type: string;
    }

    export interface GetSecurityPoliciesSecurityPolicy {
        /**
         * The cipher suites supported by the security policy.
         */
        ciphers: string[];
        /**
         * The time when the custom security policy was created.
         */
        createdAt: string;
        /**
         * Specifies the description of the security policy.
         */
        description: string;
        /**
         * The listener ID.
         */
        id: string;
        /**
         * The IDs of listeners with which the security policy is associated.
         * The listeners structure is documented below.
         */
        listeners: outputs.DedicatedElb.GetSecurityPoliciesSecurityPolicyListener[];
        /**
         * Specifies the name of the security policy.
         */
        name: string;
        /**
         * The TLS protocols supported by the security policy.
         */
        protocols: string[];
        /**
         * Specifies the type of the security policy. Value options: **system**, **custom**.
         */
        type: string;
        /**
         * The time when the custom security policy was updated.
         */
        updatedAt: string;
    }

    export interface GetSecurityPoliciesSecurityPolicyListener {
        /**
         * The listener ID.
         */
        id: string;
    }

    export interface IpgroupIpList {
        /**
         * Human-readable description for the ip.
         */
        description?: string;
        /**
         * IP address or CIDR block.
         */
        ip: string;
    }

    export interface L7policyFixedResponseConfig {
        /**
         * The format of the response body. Value options: **text/plain**, **text/css**,
         * **text/html**, **application/javascript**, or **application/json**. Defaults to: **text/plain**.
         */
        contentType: string;
        /**
         * The header parameters to be added.
         * The insertHeadersConfig structure is documented below.
         */
        insertHeadersConfig?: outputs.DedicatedElb.L7policyFixedResponseConfigInsertHeadersConfig;
        /**
         * The content of the response message body.
         */
        messageBody?: string;
        /**
         * The header parameters to be removed.
         * The removeHeadersConfig structure is documented below.
         */
        removeHeadersConfig?: outputs.DedicatedElb.L7policyFixedResponseConfigRemoveHeadersConfig;
        /**
         * The fixed HTTP status code configured in the forwarding rule. The value can be
         * any integer in the range of **200299**, **400499**, or **500599**.
         */
        statusCode: string;
        /**
         * The traffic limit config of the policy.
         * The trafficLimitConfig structure is documented below.
         */
        trafficLimitConfig?: outputs.DedicatedElb.L7policyFixedResponseConfigTrafficLimitConfig;
    }

    export interface L7policyFixedResponseConfigInsertHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyFixedResponseConfigInsertHeadersConfigConfig[];
    }

    export interface L7policyFixedResponseConfigInsertHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
        /**
         * The value of the parameter. The value can contain `1` to `128`, only printable
         * characters in the range of ASCII code value 32<=ch<=127, asterisks (*) and question marks (?) are allowed, and it
         * cannot start or end with a space characters. If the value of `valueType` is **SYSTEM_DEFINED**, the value options is:
         * **CLIENT-PORT**, **CLIENT-IP**, **ELB-PROTOCOL**, **ELB-ID**, **ELB-PORT**, **ELB-EIP**, **ELB-VIP**.
         */
        value: string;
        /**
         * The value type of the parameter. Value options: **USER_DEFINED**,
         * **REFERENCE_HEADER**, **SYSTEM_DEFINED**.
         */
        valueType: string;
    }

    export interface L7policyFixedResponseConfigRemoveHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyFixedResponseConfigRemoveHeadersConfigConfig[];
    }

    export interface L7policyFixedResponseConfigRemoveHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
    }

    export interface L7policyFixedResponseConfigTrafficLimitConfig {
        /**
         * The qps buffer.  
         * The valid value is range form `0` to `100,000`. When qps exceeds the limit, 503 will not be
         * returned, and requests that allow local burst size increases are supported.
         */
        burst?: number;
        /**
         * The single source qps of the policy.  
         * The valid value is range form `0` to `100,000`, `0` indicates no limit.
         * If the value of `qps` is not `0`, then the value of `perSourceIpQps` must less than the value of `qps`.
         * If the `protocol` of the listener that the policy associated with is **QUIC**, then `perSourceIpQps` is not
         * supported, the value should be `0` or empty.
         */
        perSourceIpQps?: number;
        /**
         * The overall qps of the policy.  
         * The valid value is range form `0` to `100,000`, `0` indicates no limit.
         */
        qps?: number;
    }

    export interface L7policyRedirectPoolsConfig {
        /**
         * The ID of the backend server group.
         */
        poolId: string;
        /**
         * The weight of the backend server group.
         */
        weight: number;
    }

    export interface L7policyRedirectPoolsExtendConfig {
        /**
         * The header parameters to be added.
         * The insertHeadersConfig structure is documented below.
         */
        insertHeadersConfig?: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigInsertHeadersConfig;
        /**
         * The header parameters to be removed.
         * The removeHeadersConfig structure is documented below.
         */
        removeHeadersConfig?: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigRemoveHeadersConfig;
        /**
         * The rewrite url config. This parameter is mandatory when `rewriteUrlEnabled`
         * is set to **true**.
         * The rewriteUrlConfig structure is documented below.
         */
        rewriteUrlConfig: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigRewriteUrlConfig;
        /**
         * Whether the rewrite url is enabled.
         */
        rewriteUrlEnabled: boolean;
        /**
         * The traffic limit config of the policy.
         * The trafficLimitConfig structure is documented below.
         */
        trafficLimitConfig?: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigTrafficLimitConfig;
    }

    export interface L7policyRedirectPoolsExtendConfigInsertHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig[];
    }

    export interface L7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
        /**
         * The value of the parameter. The value can contain `1` to `128`, only printable
         * characters in the range of ASCII code value 32<=ch<=127, asterisks (*) and question marks (?) are allowed, and it
         * cannot start or end with a space characters. If the value of `valueType` is **SYSTEM_DEFINED**, the value options is:
         * **CLIENT-PORT**, **CLIENT-IP**, **ELB-PROTOCOL**, **ELB-ID**, **ELB-PORT**, **ELB-EIP**, **ELB-VIP**.
         */
        value: string;
        /**
         * The value type of the parameter. Value options: **USER_DEFINED**,
         * **REFERENCE_HEADER**, **SYSTEM_DEFINED**.
         */
        valueType: string;
    }

    export interface L7policyRedirectPoolsExtendConfigRemoveHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig[];
    }

    export interface L7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
    }

    export interface L7policyRedirectPoolsExtendConfigRewriteUrlConfig {
        /**
         * The host name that requests are redirected to. The value can contain only letters,
         * digits, hyphens (-), and periods (.) and must start with a letter or digit. Defaults to **${host}**, indicating
         * that the host of the request will be used.
         */
        host: string;
        /**
         * The path that requests are redirected to. The value can contain only letters, digits,
         * and special characters _~';@^- %#&$.*+?,=!:|/()[]{} and must start with a slash (/).
         * Defaults to **${path}**, indicating that the path of the request will be used.
         */
        path: string;
        /**
         * The query string set in the URL for redirection. The value is case-sensitive and can
         * contain only letters, digits, and special characters !$&'()*+,-./:;=?@^_\`. Defaults to **${query}**, indicating that
         * the query string of the request will be used.
         * For example, in the URL `https://www.xxx.com:8080/elb?type=loadbalancer`, **${query}** indicates **type=loadbalancer**.
         * If this parameter is set to **${query}&name=my_name**, the URL will be redirected to
         * URL `https://www.xxx.com:8080/elb?type=loadbalancer&name=my_name`.
         */
        query?: string;
    }

    export interface L7policyRedirectPoolsExtendConfigTrafficLimitConfig {
        /**
         * The qps buffer.  
         * The valid value is range form `0` to `100,000`. When qps exceeds the limit, 503 will not be
         * returned, and requests that allow local burst size increases are supported.
         */
        burst?: number;
        /**
         * The single source qps of the policy.  
         * The valid value is range form `0` to `100,000`, `0` indicates no limit.
         * If the value of `qps` is not `0`, then the value of `perSourceIpQps` must less than the value of `qps`.
         * If the `protocol` of the listener that the policy associated with is **QUIC**, then `perSourceIpQps` is not
         * supported, the value should be `0` or empty.
         */
        perSourceIpQps?: number;
        /**
         * The overall qps of the policy.  
         * The valid value is range form `0` to `100,000`, `0` indicates no limit.
         */
        qps?: number;
    }

    export interface L7policyRedirectPoolsStickySessionConfig {
        /**
         * Whether enable config session persistence between backend server groups.
         */
        enable: boolean;
        /**
         * The timeout of the session persistence.
         */
        timeout: number;
    }

    export interface L7policyRedirectUrlConfig {
        /**
         * The host name that requests are redirected to. The value can contain only letters,
         * digits, hyphens (-), and periods (.) and must start with a letter or digit. Defaults to **${host}**, indicating
         * that the host of the request will be used.
         */
        host: string;
        /**
         * The header parameters to be added.
         * The insertHeadersConfig structure is documented below.
         */
        insertHeadersConfig?: outputs.DedicatedElb.L7policyRedirectUrlConfigInsertHeadersConfig;
        /**
         * The path that requests are redirected to. The value can contain only letters, digits,
         * and special characters _~';@^- %#&$.*+?,=!:|/()[]{} and must start with a slash (/).
         * Defaults to **${path}**, indicating that the path of the request will be used.
         */
        path: string;
        /**
         * The  port that requests are redirected to. Defaults to **${port}**, indicating that
         * the port of the request will be used.
         */
        port: string;
        /**
         * The protocol for redirection. Value options: **HTTP**, **HTTPS**, **${protocol}**.
         * Defaults to **${protocol}**, indicating that the path of the request will be used.
         */
        protocol: string;
        /**
         * The query string set in the URL for redirection. The value is case-sensitive and can
         * contain only letters, digits, and special characters !$&'()*+,-./:;=?@^_\`. Defaults to **${query}**, indicating that
         * the query string of the request will be used.
         * For example, in the URL `https://www.xxx.com:8080/elb?type=loadbalancer`, **${query}** indicates **type=loadbalancer**.
         * If this parameter is set to **${query}&name=my_name**, the URL will be redirected to
         * URL `https://www.xxx.com:8080/elb?type=loadbalancer&name=my_name`.
         */
        query?: string;
        /**
         * The header parameters to be removed.
         * The removeHeadersConfig structure is documented below.
         */
        removeHeadersConfig?: outputs.DedicatedElb.L7policyRedirectUrlConfigRemoveHeadersConfig;
        /**
         * The fixed HTTP status code configured in the forwarding rule. The value can be
         * any integer in the range of **200299**, **400499**, or **500599**.
         */
        statusCode: string;
    }

    export interface L7policyRedirectUrlConfigInsertHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyRedirectUrlConfigInsertHeadersConfigConfig[];
    }

    export interface L7policyRedirectUrlConfigInsertHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
        /**
         * The value of the parameter. The value can contain `1` to `128`, only printable
         * characters in the range of ASCII code value 32<=ch<=127, asterisks (*) and question marks (?) are allowed, and it
         * cannot start or end with a space characters. If the value of `valueType` is **SYSTEM_DEFINED**, the value options is:
         * **CLIENT-PORT**, **CLIENT-IP**, **ELB-PROTOCOL**, **ELB-ID**, **ELB-PORT**, **ELB-EIP**, **ELB-VIP**.
         */
        value: string;
        /**
         * The value type of the parameter. Value options: **USER_DEFINED**,
         * **REFERENCE_HEADER**, **SYSTEM_DEFINED**.
         */
        valueType: string;
    }

    export interface L7policyRedirectUrlConfigRemoveHeadersConfig {
        /**
         * The list of request header parameters to be removed.
         * The removeHeaderConfigs structure is documented below.
         */
        configs: outputs.DedicatedElb.L7policyRedirectUrlConfigRemoveHeadersConfigConfig[];
    }

    export interface L7policyRedirectUrlConfigRemoveHeadersConfigConfig {
        /**
         * The parameter name of the removed request header. The value can contain `1` to `40`
         * characters, only a-z, digits, hyphens (-) and underscore (_) are allowed, and it can not be the following characters:
         * **connection**, **upgrade**, **content-length**, **transfer-encoding**, **keep-alive**, **te**, **host**, **cookie**,
         * **remoteip**, **authority**, **x-forwarded-host**, **x-forwarded-for**, **x-forwarded-for-port**,
         * **x-forwarded-tls-certificate-id**, **x-forwarded-tls-protocol**, **x-forwarded-tls-cipher**, **x-forwarded-elb-ip**,
         * **x-forwarded-port**, **x-forwarded-elb-id**, **x-forwarded-elb-vip**, **x-real-ip**, **x-forwarded-proto**,
         * **x-nuwa-trace-ne-in**, **x-nuwa-trace-ne-out**.
         */
        key: string;
    }

    export interface L7ruleCondition {
        /**
         * Specifies the key of match item.
         * + If `type` is set to **HOST_NAME**, **PATH**, **METHOD**, or **SOURCE_IP**, this parameter is left blank.
         * + If `type` is set to **HEADER**, it indicates the name of the HTTP header parameter. It can contain 1 to 40
         * characters, including letters, digits, hyphens (-), and underscores (_).
         * + If `type` is set to **QUERY_STRING**, it indicates the name of the query parameter. It is case-sensitive and can
         * contain 1 to 128 characters. Spaces, square brackets ([]), curly brackets ({}), angle brackets (<>), backslashes (),
         * double quotation marks (" "), pound signs (#), ampersands (&), vertical bars (|), percent signs (%), and tildes (~)
         * are not supported.
         */
        key?: string;
        /**
         * Specifies the value of the match item.
         * + If `type` is set to **HOST_NAME**, it indicates the domain name, which can contain 1 to 128 characters, including
         * letters, digits, hyphens (-), periods (.), and asterisks (), and must start with a letter, digit, or asterisk ().
         * If you want to use a wildcard domain name, enter an asterisk (*) as the leftmost label of the domain name.
         * + If `type` is set to **PATH**, it indicates the request path, which can contain 1 to 128 characters. If
         * `compareType` is set to **STARTS_WITH** or **EQUAL_TO** for the forwarding rule, the value must start with a
         * slash (/) and can contain only letters, digits, and special characters _~';@^-%#&$.*+?,=!:|/()[]{}.
         * + If `type` is set to **HEADER**, it indicates the value of the HTTP header parameter. The value can contain 1 to 128
         * characters. Asterisks (*) and question marks (?)are allowed, but spaces and double quotation marks are not allowed.
         * An asterisk can match zero or more characters, and a question mark can match 1 character.
         * + If `type` is set to **QUERY_STRING**, it indicates the value of the query parameter. The value is case-sensitive
         * and can contain 1 to 128 characters. Spaces, square brackets ([]), curly brackets ({}), angle brackets (<>),
         * backslashes (), double quotation marks (""), pound signs (#), ampersands (&), vertical bars (|), percent signs (%),
         * and tildes (~) are not supported. Asterisks (*)and question marks (?) are allowed. An asterisk can match zero or
         * more characters, and a question mark can match 1 character.
         * + If `type` is set to **METHOD**, it indicates the HTTP method. The value can be **GET**, **PUT**, **POST**,
         * **DELETE**, **PATCH**, **HEAD**, or **OPTIONS**.
         * + If `type` is set to **SOURCE_IP**, it indicates the source IP address of the request. The value is an **IPv4** or
         * **IPv6** CIDR block, for example, 192.168.0.2/32 or 2049::49/64.
         */
        value: string;
    }

    export interface ListenerPortRange {
        /**
         * Specifies the end port. Changing this creates a new listener.
         */
        endPort: number;
        /**
         * Specifies the start port. Changing this creates a new listener.
         */
        startPort: number;
    }

    export interface PoolPersistence {
        /**
         * Specifies the cookie name. The value can contain only letters, digits,
         * hyphens (-), underscores (_), and periods (.). It is required if `type` of `persistence` is set to **APP_COOKIE**.
         */
        cookieName?: string;
        /**
         * Specifies the sticky session timeout duration in minutes. This parameter is
         * invalid when `type` is set to **APP_COOKIE**. The value range varies depending on the protocol of the backend server
         * group:
         * + When the protocol of the backend server group is **TCP** or **UDP**, the value ranges from `1` to `60`, and
         * defaults to `1`.
         * + When the protocol of the backend server group is **HTTP** or **HTTPS**, the value ranges from `1` to `1,440`,
         * and defaults to `1,440`.
         */
        timeout: number;
        /**
         * Specifies the sticky session type. Value options: **SOURCE_IP**,
         * **HTTP_COOKIE**, and **APP_COOKIE**.
         */
        type: string;
    }

    export interface SecurityPolicyListener {
        /**
         * The listener id.
         */
        id: string;
    }
}

export namespace Dew {
    export interface GetKeypairsKeypair {
        /**
         * Specifies the fingerprint of the keypair.
         */
        fingerprint: string;
        /**
         * Indicates whether the private key is managed by HuaweiCloud.
         */
        isManaged: boolean;
        /**
         * Specifies the name of the keypair.
         */
        name: string;
        /**
         * Specifies the imported OpenSSH-formatted public key.
         */
        publicKey: string;
        /**
         * Indicates the scope of keypair. The value can be **account**or **user**.
         */
        scope: string;
    }

}

export namespace Dis {
    export interface StreamPartition {
        /**
         * Possible value range of the hash key used by each partition.
         */
        hashRange: string;
        /**
         * The ID of the partition.
         */
        id: string;
        /**
         * Sequence number range of each partition.
         */
        sequenceNumberRange: string;
        /**
         * The status of the partition.
         */
        status: string;
    }

}

export namespace Dli {
    export interface QueueScalingPolicy {
        /**
         * Specifies the effective time of the queue scaling policy.
         * The value can be set only by hour.
         */
        impactStartTime: string;
        /**
         * Specifies the expiration time of the queue scaling policy.
         * The value can be set only by hour.
         */
        impactStopTime: string;
        /**
         * Specifies the maximum number of CUs allowed by the scaling policy.
         * The number must be a multiple of `4`.
         */
        maxCu: number;
        /**
         * Specifies the minimum number of CUs allowed by the scaling policy.
         * The number must be a multiple of `4`.
         */
        minCu: number;
        /**
         * Specifies the priority of the queue scaling policy.
         * The valid value ranges from `1` to `100`. The larger value means the higher priority.
         */
        priority: number;
    }

    export interface QueueSparkDriver {
        /**
         * Specifies the maximum number of tasks that can be concurrently executed by a spark driver.
         * The valid value ranges from `1` to `32`.
         */
        maxConcurrent?: number;
        /**
         * Specifies the maximum number of spark drivers that can be started on the queue.
         * If the `cuCount` is `16`, the value can only be `2`.
         * If The `cuCount` is greater than `16`, the minimum value is `2`, the maximum value is the number of queue CUs
         * divided by `16`.
         */
        maxInstance?: number;
        /**
         * Specifies the maximum number of spark drivers to be pre-started on the queue.
         * The minimum value is `0`. If the `cuCount` is less than `32`, the maximum value is `1`.
         * If the `cuCount` is greater than or equal to `32`, the maximum value is the number of queue CUs divided by `16`.
         */
        maxPrefetchInstance?: string;
    }

    export interface SparkJobDependentPackage {
        /**
         * Specifies the user group name.  
         * Only letters, digits, dots (.), hyphens (-) and underscores (_) are allowed.
         * Changing this parameter will submit a new spark job.
         */
        groupName: string;
        /**
         * Specifies the user group resource for details.
         * Changing this parameter will submit a new spark job.
         * The object structure is documented below.
         */
        packages: outputs.Dli.SparkJobDependentPackagePackage[];
    }

    export interface SparkJobDependentPackagePackage {
        /**
         * Specifies the resource name of the package.
         * Changing this parameter will submit a new spark job.
         */
        packageName: string;
        /**
         * Specifies the resource type of the package.
         * Changing this parameter will submit a new spark job.
         */
        type: string;
    }

    export interface SqlJobConf {
        /**
         * Sets the job running timeout interval. If the timeout interval
         * expires, the job is canceled. Unit: `ms`. Changing this parameter will create a new resource.
         */
        dliSqlJobTimeout?: number;
        /**
         * Specifies whether DDL and DCL statements are executed
         * asynchronously. The value true indicates that asynchronous execution is enabled. Default value is `false`.
         * Changing this parameter will create a new resource.
         */
        dliSqlSqlasyncEnabled?: boolean;
        /**
         * Maximum size of the table that
         * displays all working nodes when a connection is executed. You can set this parameter to -1 to disable the display.
         * Default value is `209715200`. Changing this parameter will create a new resource.
         */
        sparkSqlAutoBroadcastJoinThreshold?: number;
        /**
         * Path of bad records. Changing this parameter will create
         * a new resource.
         */
        sparkSqlBadRecordsPath?: string;
        /**
         * In dynamic mode, Spark does not delete
         * the previous partitions and only overwrites the partitions without data during execution. Default value is `false`.
         * Changing this parameter will create a new resource.
         */
        sparkSqlDynamicPartitionOverwriteEnabled?: boolean;
        /**
         * Maximum number of bytes to be packed into a
         * single partition when a file is read. Default value is `134217728`. Changing this parameter will create a new
         * resource.
         */
        sparkSqlFilesMaxPartitionBytes?: number;
        /**
         * Maximum number of records to be written
         * into a single file. If the value is zero or negative, there is no limit. Default value is `0`.
         * Changing this parameter will create a new resource.
         */
        sparkSqlMaxRecordsPerFile?: number;
        /**
         * Default number of partitions used to filter
         * data for join or aggregation. Default value is `4096`. Changing this parameter will create a new resource.
         */
        sparkSqlShufflePartitions?: number;
    }

    export interface TableColumn {
        /**
         * Specifies the description of column. Changing this parameter will
         * create a new resource.
         */
        description?: string;
        /**
         * Specifies whether the column is a partition column. The value
         * `true` indicates a partition column, and the value false indicates a non-partition column. The default value
         * is false. Changing this parameter will create a new resource.
         */
        isPartition?: boolean;
        /**
         * Specifies the name of column. Changing this parameter will create a new
         * resource.
         */
        name: string;
        /**
         * Specifies data type of column. Changing this parameter will create a new
         * resource.
         */
        type: string;
    }

}

export namespace Dms {
    export interface GetFlavorsFlavor {
        /**
         * The list of supported CPU architectures.
         */
        archTypes: string[];
        /**
         * The list of supported billing modes.
         */
        chargingModes: string[];
        /**
         * The flavor ID.
         */
        id: string;
        /**
         * The list of supported disk IO types.
         * The object structure is documented below.
         */
        ios: outputs.Dms.GetFlavorsFlavorIo[];
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorProperty[];
        /**
         * The list of features supported by the current specification.
         * The object structure is documented below.
         */
        supportFeatures: outputs.Dms.GetFlavorsFlavorSupportFeature[];
        /**
         * Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
         */
        type: string;
        /**
         * The underlying VM specification.
         */
        vmSpecification: string;
    }

    export interface GetFlavorsFlavorIo {
        /**
         * Specifies the list of availability zones with available resources.
         */
        availabilityZones: string[];
        /**
         * Specifies the disk IO encoding.
         * + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
         * + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
         */
        storageSpecCode: string;
        /**
         * Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
         */
        type: string;
        /**
         * The list of unavailability zones with available resources.
         */
        unavailabilityZones: string[];
    }

    export interface GetFlavorsFlavorProperty {
        /**
         * The flavor ID alias.
         */
        flavorAlias: string;
        /**
         * The maximum bandwidth per broker.
         */
        maxBandwidthPerBroker: number;
        /**
         * The maximum number of brokers.
         */
        maxBroker: number;
        /**
         * The maximum number of consumers per broker.
         */
        maxConsumerPerBroker: number;
        /**
         * The maximum number of partitions per broker.
         */
        maxPartitionPerBroker: number;
        /**
         * The maximum storage per node. The unit is GB.
         */
        maxStoragePerNode: number;
        /**
         * The maximum TPS per broker.
         */
        maxTpsPerBroker: number;
        /**
         * The minimum number of brokers.
         */
        minBroker: number;
        /**
         * The minimum storage per node. The unit is GB.
         */
        minStoragePerNode: number;
    }

    export interface GetFlavorsFlavorSupportFeature {
        /**
         * The function name, e.g. **connector_obs**.
         */
        name: string;
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorSupportFeatureProperty[];
    }

    export interface GetFlavorsFlavorSupportFeatureProperty {
        /**
         * The maximum number of nodes for the dump function.
         */
        maxNode: number;
        /**
         * The maximum number of tasks for the dump function.
         */
        maxTask: number;
        /**
         * The minimum number of nodes for the dump function.
         */
        minNode: number;
        /**
         * The minimum number of tasks for the dump function.
         */
        minTask: number;
    }

    export interface GetInstancesInstance {
        /**
         * The access username.
         */
        accessUser: string;
        /**
         * The list of AZ names.
         */
        availabilityZones: string[];
        /**
         * The IP address for instance connection.
         */
        connectAddress: string;
        /**
         * Indicates the Access information of cross-VPC. The structure is documented below.
         */
        crossVpcAccesses: outputs.Dms.GetInstancesInstanceCrossVpcAccess[];
        /**
         * The instance description.
         */
        description: string;
        /**
         * Whether to dumping is enabled.
         */
        dumping: boolean;
        /**
         * Whether to enable automatic topic creation.
         */
        enableAutoTopic: boolean;
        /**
         * Whether public access to the instance is enabled.
         */
        enablePublicIp: boolean;
        /**
         * The authentication mechanisms to use after SASL is enabled.
         */
        enabledMechanisms: string[];
        /**
         * The kafka engine version.
         */
        engineVersion: string;
        /**
         * Specifies the enterprise project ID to which all instances of the list
         * belong.
         */
        enterpriseProjectId: string;
        /**
         * The instance ID.
         */
        id: string;
        /**
         * The time at which a maintenance time window starts, the format is `HH:mm`.
         */
        maintainBegin: string;
        /**
         * The time at which a maintenance time window ends, the format is `HH:mm`.
         */
        maintainEnd: string;
        /**
         * The connection address of the Kafka manager of an instance.
         */
        managementConnectAddress: string;
        /**
         * The username for logging in to the Kafka Manager.
         */
        managerUser: string;
        /**
         * @deprecated typo in manegement_connect_address, please use "management_connect_address" instead.
         */
        manegementConnectAddress: string;
        /**
         * Specifies the kafka instance name for data-source queries.
         */
        name: string;
        /**
         * The subnet ID to which the instance belongs.
         */
        networkId: string;
        /**
         * The maximum number of topics in the DMS kafka instance.
         */
        partitionNum: number;
        /**
         * The port number.
         */
        port: number;
        /**
         * The product ID used by the instance.
         */
        productId: string;
        /**
         * The instance public access address.
         * The format of each connection address is `{IP address}:{port}`.
         */
        publicConnAddresses: string;
        /**
         * The IDs of the elastic IP address (EIP).
         */
        publicIpIds: string[];
        /**
         * The resource specifications identifier.
         */
        resourceSpecCode: string;
        /**
         * The action to be taken when the memory usage reaches the disk capacity threshold.
         */
        retentionPolicy: string;
        /**
         * The security group ID associated with the instance.
         */
        securityGroupId: string;
        /**
         * The protocol to use after SASL is enabled.
         */
        securityProtocol: string;
        /**
         * Whether the Kafka SASL_SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * Specifies the kafka instance status for data-source queries.
         */
        status: string;
        /**
         * The message storage capacity, in GB unit.
         */
        storageSpace: number;
        /**
         * The storage I/O specification.
         */
        storageSpecCode: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The instance type.
         */
        type: string;
        /**
         * The used message storage space, in GB unit.
         */
        usedStorageSpace: number;
        /**
         * The user ID who created the instance.
         */
        userId: string;
        /**
         * The username who created the instance.
         */
        userName: string;
        /**
         * The VPC ID to which the instance belongs.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceCrossVpcAccess {
        /**
         * The advertised IP Address.
         */
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listener_ip" instead.
         */
        lisenterIp: string;
        /**
         * The listener IP address.
         */
        listenerIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address.
         */
        portId: string;
    }

    export interface KafkaInstanceCrossVpcAccess {
        /**
         * The advertised IP Address or domain name.
         */
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listener_ip" instead.
         */
        lisenterIp: string;
        /**
         * The listener IP address.
         */
        listenerIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address.
         */
        portId: string;
    }

    export interface KafkaInstanceParameter {
        /**
         * Specifies the parameter name. Static parameter needs to restart the instance to take effect.
         */
        name: string;
        /**
         * Specifies the parameter value.
         */
        value: string;
    }

    export interface KafkaInstancePortProtocol {
        /**
         * The private plain address.
         */
        privatePlainAddress: string;
        /**
         * The private plain domain name.
         */
        privatePlainDomainName: string;
        /**
         * Whether the private plain enabled.
         */
        privatePlainEnable: boolean;
        /**
         * The private sasl plaintext address.
         */
        privateSaslPlaintextAddress: string;
        /**
         * The private sasl plaintext domain name.
         */
        privateSaslPlaintextDomainName: string;
        /**
         * Whether the private sasl plaintext enabled.
         */
        privateSaslPlaintextEnable: boolean;
        /**
         * The private sasl ssl address.
         */
        privateSaslSslAddress: string;
        /**
         * The private sasl ssl domain name.
         */
        privateSaslSslDomainName: string;
        /**
         * Whether the private sasl ssl enabled.
         */
        privateSaslSslEnable: boolean;
        /**
         * The public plain address.
         */
        publicPlainAddress: string;
        /**
         * The public plain domain name.
         */
        publicPlainDomainName: string;
        /**
         * Whether the public plain enabled.
         */
        publicPlainEnable: boolean;
        /**
         * The public sasl plaintext address.
         */
        publicSaslPlaintextAddress: string;
        /**
         * The public sasl plaintext domain name.
         */
        publicSaslPlaintextDomainName: string;
        /**
         * Whether the public sasl plaintext enabled.
         */
        publicSaslPlaintextEnable: boolean;
        /**
         * The public sasl ssl address.
         */
        publicSaslSslAddress: string;
        /**
         * The public sasl ssl domain name.
         */
        publicSaslSslDomainName: string;
        /**
         * Whether the public sasl ssl enabled.
         */
        publicSaslSslEnable: boolean;
    }

    export interface KafkaPermissionsPolicy {
        /**
         * Specifies the permissions type. The value can be:
         * + **all**: publish and subscribe permissions.
         * + **pub**: publish permissions.
         * + **sub**: subscribe permissions.
         */
        accessPolicy: string;
        /**
         * Specifies the username.
         */
        userName: string;
    }

    export interface KafkaTopicConfig {
        /**
         * Specifies the configuration name.
         */
        name: string;
        /**
         * Specifies the configuration value.
         */
        value: string;
    }
}

export namespace Dns {
    export interface ZoneRouter {
        /**
         * Specifies the ID of the associated VPC.
         */
        routerId: string;
        /**
         * Specifies the region of the VPC.
         */
        routerRegion: string;
    }

}

export namespace Drs {
    export interface JobAlarmNotify {
        /**
         * Specifies the Delay threshold between the source and destination database,
         * in seconds. Value ranges from `1` to `3,600`. Default is `0` and no notifications will be sent to recipient. If
         * the delay exceeds a specified value and lasts for 6 minutes, DRS will notify specified recipients. This option is
         * available only for **full+incremental** tasks.
         */
        delayTime: number;
        /**
         * Specifies the RPO delay threshold, in seconds.  
         * Value ranges from `1` to `3,600`. Default is `0` and no notifications will be sent to recipient.
         * If the RPO delay between the service database and the DRS instance exceeds a specified value and lasts for `6`
         * minutes, DRS will notify specified recipients.
         */
        rpoDelay: number;
        /**
         * Specifies the RTO delay threshold, in seconds.  
         * Value ranges from `1` to `3,600`. Default is `0` and no notifications will be sent to recipient.
         * If the RTO delay between the DRS instance and the DR database exceeds a specified value and lasts for `6` minutes,
         * DRS will notify specified recipients.
         */
        rtoDelay: number;
        /**
         * Specifies the SMN topic URN which is subscribed.
         */
        topicUrn: string;
    }

    export interface JobDestinationDb {
        /**
         * Specifies the engine type of database. Changing this parameter will
         * create a new resource. The options are as follows: **mysql**, **mongodb**, **gaussdbv5**, **taurus**, **gaussdbv5ha**,
         * **kafka**, **postgresql**.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the kafka security authentication info.
         * Changing this parameter will create a new resource.
         * The kafkaSecurityConfig structure is documented below.
         */
        kafkaSecurityConfig?: outputs.Drs.JobDestinationDbKafkaSecurityConfig;
        /**
         * Specifies the name of database.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password?: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port?: number;
        /**
         * Specifies the region which the database belongs when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * The security group ID to which the databese instance belongs.
         */
        securityGroupId: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is **true** and the certificate file suffix is **.p12**. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is **down**. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user?: string;
        /**
         * Specifies vpc ID of database.
         * Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface JobDestinationDbKafkaSecurityConfig {
        /**
         * Specifies whether to use token authentication. It is valid only when
         * the security protocol is set to **SASL_SSL** or **SASL_PLAINTEXT** and the SASL mechanism is set to **SCRAM-SHA-256**
         * or **SCRAM-SHA-512**. Defaults to false. Changing this parameter will create a new resource.
         */
        delegationTokens?: boolean;
        /**
         * Specifies Whether to enable two-way SSL authentication.
         * Defaults to false. Changing this parameter will create a new resource.
         */
        enableKeyStore?: boolean;
        /**
         * Specifies the host name endpoint identification algorithm, which
         * specifies the endpoint identification algorithm for verifying the server host name using the server certificate.
         * If it is not specified, host name verification is disabled. The corresponding field for Kafka is
         * **ssl.endpoint.identification.algorithm**. Changing this parameter will create a new resource.
         */
        endpointAlgorithm?: string;
        /**
         * Specifies the keystore private key password. It is mandatory when
         * two-way SSL authentication is enabled and `setPrivateKeyPassword` is set to **true**.
         * Changing this parameter will create a new resource.
         */
        keyPassword?: string;
        /**
         * Specifies the keystore certificate. It is mandatory when two-way SSL
         * authentication is enabled. Changing this parameter will create a new resource.
         */
        keyStoreKey?: string;
        /**
         * Specifies the keystore certificate name. It is mandatory when
         * two-way SSL authentication is enabled. Changing this parameter will create a new resource.
         */
        keyStoreKeyName?: string;
        /**
         * Specifies the keystore certificate password. It is mandatory when
         * a password is set for the keystore certificate. Changing this parameter will create a new resource.
         */
        keyStorePassword?: string;
        /**
         * Specifies the SASL mechanism used for client connection.
         * The value can be **GSSAPI**, **PLAIN**, **SCRAM-SHA-256**, **SCRAM-SHA-512**.
         * Changing this parameter will create a new resource.
         */
        saslMechanism?: string;
        /**
         * Specifies whether to set the keystore private key password.
         * Defaults to false. Changing this parameter will create a new resource.
         */
        setPrivateKeyPassword?: boolean;
        /**
         * Specifies the value of the security certificate after Base64 transcoding.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStoreKey?: string;
        /**
         * Specifies the certificate name.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStoreKeyName?: string;
        /**
         * Specifies the certificate password.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStorePassword?: string;
        /**
         * Specifies the type of a task with an EIP bound.
         * Valid values are **master** and **slave**.
         * + In a primary/standby task, **master** indicates the primary task, and **slave** indicates the standby task.
         * + In other cases, the value is fixed to **master**.
         */
        type?: string;
    }

    export interface JobLimitSpeed {
        /**
         * Specifies the time to end speed limit, this time is UTC time. The input must
         * end at 59 minutes, the format is **hh:mm**, for example: 15:59. Changing this parameter will create a new resource.
         */
        endTime: string;
        /**
         * Specifies the transmission speed, the value range is 1 to 9999, unit: **MB/s**.
         * Changing this parameter will create a new resource.
         */
        speed: string;
        /**
         * Specifies the time to start speed limit, this time is UTC time. The start
         * time is the whole hour, if there is a minute, it will be ignored, the format is **hh:mm**, and the hour number
         * is two digits, for example: 01:00. Changing this parameter will create a new resource.
         */
        startTime: string;
    }

    export interface JobPolicyConfig {
        /**
         * Specifies the incremental conflict policy.
         */
        conflictPolicy?: string;
        /**
         * Specifies Whether to export data in snapshot mode in the PostgreSQL
         * full migration or synchronization phase. Defaults to **false**.
         * Changing this parameter will create a new resource.
         */
        exportSnapshot?: boolean;
        /**
         * Specifies the file and position, The value is in the format of
         * **File_name.file_number:Event_position**. Changing this parameter will create a new resource.
         */
        fileAndPosition?: string;
        /**
         * Specifies the DDL filtering policy. Valid value is **drop_database**.
         * For MySQL synchronization, this parameter can only be set to **drop_database**.
         * Changing this parameter will create a new resource.
         */
        filterDdlPolicy?: string;
        /**
         * Specifies the gtid set. Enter a maximum of 2048 characters. Chinese
         * characters and the following special characters are not allowed: < > & " ' / \\.
         * Changing this parameter will create a new resource.
         */
        gtidSet?: string;
        /**
         * Specifies the object synchronization scope, indicating whether to
         * synchronize normal indexes. If it's **true**, all indexes will be synchronized, otherwise, only primary key or unique
         * indexes are synchronized. Changing this parameter will create a new resource.
         */
        indexTrans?: boolean;
        /**
         * Specifies whether to fill the materialized view in the
         * PostgreSQL full migration or synchronization phase. Defaults to **false**.
         * Changing this parameter will create a new resource.
         */
        isFillMaterializedView?: boolean;
        /**
         * Specifies the data format delivered to Kafka.
         * Valid values are **json**, **avro** and **json_c**. Defaults to **json**.
         * + The value can be **json** and **json_c** for synchronization from MySQL to Kafka and from GaussDB(for MySQL) to Kafka.
         * + The value can be **json** and **avro** for synchronization from GaussDB Primary/Standby to Kafka.
         */
        kafkaDataFormat?: string;
        /**
         * Specifies the policy for synchronizing topics to the Kafka partitions.
         * It is mandatory when the destination database is Kafka.
         * + Valid values are as follows:
         * - **0**: Partitions are differentiated by the hash values of *database_name.schema_name.table_name*.
         * - **1**: Topics are synchronized to partition 0.
         * - **2**: Partitions are identified by the hash values of the primary key.
         * - **3**: Partitions are differentiated by the hash values of *database_name.schema_name*.
         * - **5**: Partitions are differentiated by the hash values of non-primary-key columns
         */
        partitionPolicy?: string;
        /**
         * Specifies the number of partitions. The value ranges from **1** to
         * **2147483647**. It can be specified if `policy_config.0.topic_policy` is set to **1**, **2**, or **3**.
         * Defaults to **1**. Changing this parameter will create a new resource.
         */
        partitionsNum?: string;
        /**
         * Specifies the number of replicas. The value ranges from **1** to
         * **32767**. It can be specified if `policy_config.0.topic_policy` is set to **1**, **2**, or **3**.
         * Defaults to **1**. Changing this parameter will create a new resource.
         */
        replicationFactor?: string;
        /**
         * Specifies the replication slot name. It is mandatory for primary and standby
         * tasks from GaussDB Primary/Standby to Kafka. Changing this parameter will create a new resource.
         */
        slotName?: string;
        /**
         * Specifies the topic name. It is mandatory when `policy_config.0.topic_policy`
         * is set to **0**. Ensure that the topic exists. Changing this parameter will create a new resource.
         */
        topic?: string;
        /**
         * Specifies the topic name format.
         * Valid value are as follows:
         * + If `policy_config.0.topic_policy` is set to **1**, the topic name supports the database and table names as variables.
         * Other characters are considered as constants. Replace **$database$** with the database name and **$tablename$** with the
         * table name. Defaults to **$database$-$tablename$**.
         * + If `policy_config.0.topic_policy` is set to **2**, the topic name supports the database name as a variable. Other
         * characters are regarded as constants. Defaults to **$database$**.
         * + If `policy_config.0.topic_policy` is set to **3**, the topic name supports the names of database, schema, and table
         * as variables. Other characters are considered as constants. **$database$** indicates the database name, **$schema$**
         * indicates the schema name, and **$tablename$** indicates the table name. The default value is **$database$-$schema$-$tablename$**.
         */
        topicNameFormat?: string;
        /**
         * Specifies the topic synchronization policy. It is mandatory when
         * destination database is Kafka.
         * + Values for synchronization from MySQL to Kafka and from GaussDB(for MySQL) to Kafka:
         * - **0**: A specified topic.
         * - **1**: Auto-generated topics.
         */
        topicPolicy?: string;
    }

    export interface JobPublicIpList {
        /**
         * Specifies the ID of a specified EIP.
         * Changing this parameter will create a new resource.
         */
        id: string;
        /**
         * Specifies public IP.
         * Changing this parameter will create a new resource.
         */
        publicIp: string;
        /**
         * Specifies the type of a task with an EIP bound.
         * Valid values are **master** and **slave**.
         * + In a primary/standby task, **master** indicates the primary task, and **slave** indicates the standby task.
         * + In other cases, the value is fixed to **master**.
         */
        type: string;
    }

    export interface JobSourceDb {
        /**
         * Specifies the engine type of database. Changing this parameter will
         * create a new resource. The options are as follows: **mysql**, **mongodb**, **gaussdbv5**, **taurus**, **gaussdbv5ha**,
         * **kafka**, **postgresql**.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the kafka security authentication info.
         * Changing this parameter will create a new resource.
         * The kafkaSecurityConfig structure is documented below.
         */
        kafkaSecurityConfig?: outputs.Drs.JobSourceDbKafkaSecurityConfig;
        /**
         * Specifies the name of database.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password?: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port?: number;
        /**
         * Specifies the region which the database belongs when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * The security group ID to which the databese instance belongs.
         */
        securityGroupId: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is **true**. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is **true** and the certificate file suffix is **.p12**. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is **down**. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user?: string;
        /**
         * Specifies vpc ID of database.
         * Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface JobSourceDbKafkaSecurityConfig {
        /**
         * Specifies whether to use token authentication. It is valid only when
         * the security protocol is set to **SASL_SSL** or **SASL_PLAINTEXT** and the SASL mechanism is set to **SCRAM-SHA-256**
         * or **SCRAM-SHA-512**. Defaults to false. Changing this parameter will create a new resource.
         */
        delegationTokens?: boolean;
        /**
         * Specifies Whether to enable two-way SSL authentication.
         * Defaults to false. Changing this parameter will create a new resource.
         */
        enableKeyStore?: boolean;
        /**
         * Specifies the host name endpoint identification algorithm, which
         * specifies the endpoint identification algorithm for verifying the server host name using the server certificate.
         * If it is not specified, host name verification is disabled. The corresponding field for Kafka is
         * **ssl.endpoint.identification.algorithm**. Changing this parameter will create a new resource.
         */
        endpointAlgorithm?: string;
        /**
         * Specifies the keystore private key password. It is mandatory when
         * two-way SSL authentication is enabled and `setPrivateKeyPassword` is set to **true**.
         * Changing this parameter will create a new resource.
         */
        keyPassword?: string;
        /**
         * Specifies the keystore certificate. It is mandatory when two-way SSL
         * authentication is enabled. Changing this parameter will create a new resource.
         */
        keyStoreKey?: string;
        /**
         * Specifies the keystore certificate name. It is mandatory when
         * two-way SSL authentication is enabled. Changing this parameter will create a new resource.
         */
        keyStoreKeyName?: string;
        /**
         * Specifies the keystore certificate password. It is mandatory when
         * a password is set for the keystore certificate. Changing this parameter will create a new resource.
         */
        keyStorePassword?: string;
        /**
         * Specifies the SASL mechanism used for client connection.
         * The value can be **GSSAPI**, **PLAIN**, **SCRAM-SHA-256**, **SCRAM-SHA-512**.
         * Changing this parameter will create a new resource.
         */
        saslMechanism?: string;
        /**
         * Specifies whether to set the keystore private key password.
         * Defaults to false. Changing this parameter will create a new resource.
         */
        setPrivateKeyPassword?: boolean;
        /**
         * Specifies the value of the security certificate after Base64 transcoding.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStoreKey?: string;
        /**
         * Specifies the certificate name.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStoreKeyName?: string;
        /**
         * Specifies the certificate password.
         * It is mandatory when the security protocol is set to **SSL** or **SASL_SSL**.
         * Changing this parameter will create a new resource.
         */
        trustStorePassword?: string;
        /**
         * Specifies the type of a task with an EIP bound.
         * Valid values are **master** and **slave**.
         * + In a primary/standby task, **master** indicates the primary task, and **slave** indicates the standby task.
         * + In other cases, the value is fixed to **master**.
         */
        type?: string;
    }

    export interface JobTable {
        /**
         * Specifies the name of database to which the tables belong.
         */
        database: string;
        /**
         * Specifies the names of table which belong to a same datebase.
         */
        tableNames: string[];
    }

}

export namespace Dws {
    export interface ClusterElb {
        /**
         * The ID of the ELB load balancer.
         */
        id: string;
        /**
         * Cluster name, which must be unique and contains 4 to 64 characters, which
         * consist of letters, digits, hyphens(-), or underscores(_) only and must start with a letter.
         * Changing this creates a new cluster resource.
         */
        name: string;
        /**
         * The private endpoint of the ELB load balancer.
         */
        privateEndpoint: string;
        /**
         * The private IP address of the ELB load balancer.
         */
        privateIp: string;
        /**
         * The IPv6 address of the ELB load balancer.
         */
        privateIpV6: string;
        /**
         * The information about public IP.
         */
        publicIp: string;
        /**
         * The VPC ID.
         * Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface ClusterEndpoint {
        /**
         * Private network connection information.
         */
        connectInfo: string;
        /**
         * JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
    }

    export interface ClusterMaintainWindow {
        /**
         * Maintenance time in each week in the unit of day.  
         * The valid values are **Mon**, **Tue**, **Wed**, **Thu**, **Fri**,
         * **Sat**, and **Sun**.
         */
        day: string;
        /**
         * Maintenance end time in HH:mm format. The time zone is GMT+0.
         */
        endTime: string;
        /**
         * Maintenance start time in HH:mm format. The time zone is GMT+0.
         */
        startTime: string;
    }

    export interface ClusterPublicEndpoint {
        /**
         * JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
        /**
         * Public network connection information.
         */
        publicConnectInfo: string;
    }

    export interface ClusterPublicIp {
        /**
         * The EIP ID.
         */
        eipId?: string;
        /**
         * The bind type of public IP.  
         * The valid value are **auto_assign**, **not_use**, and **bind_existing**. Defaults to **not_use**.
         */
        publicBindType: string;
    }

    export interface ClusterVolume {
        /**
         * The capacity size, in GB.
         */
        capacity: string;
        /**
         * The volume type. Value options are as follows:
         * + **SSD**: Ultra-high I/O. The solid-state drive (SSD) is used.
         * + **SAS**: High I/O. The SAS disk is used.
         * + **SATA**: Common I/O. The SATA disk is used.
         */
        type: string;
    }

    export interface GetFlaovrsFlavor {
        /**
         * The list of availability zones.
         */
        availabilityZones: string[];
        /**
         * The type of datastore.  
         * The options are as follows:
         * - **dws**: OLAP, elastic scaling, unlimited scaling of compute and storage capacity.
         * - **hybrid**: a single data warehouse used for transaction and analytics workloads,
         * in single-node or cluster mode.
         * - **stream**: built-in time series operators; up to 40:1 compression ratio; applicable to IoT services.
         */
        datastoreType: string;
        /**
         * The version of datastore.
         */
        datastoreVersion: string;
        /**
         * The ElasticVolumeSpec structure is documented below.
         */
        elasticVolumeSpecs: outputs.Dws.GetFlaovrsFlavorElasticVolumeSpec[];
        /**
         * The name of the dws node flavor.  
         * It is referenced by `nodeType` in `huaweicloud.Dws.getFlaovrs`.
         */
        flavorId: string;
        /**
         * The ram of the dws node flavor in GB.
         */
        memory: number;
        /**
         * The default disk size in GB.
         */
        size: number;
        /**
         * The vcpus of the dws node flavor.
         */
        vcpus: number;
        /**
         * Disk type.  
         * The options are as follows:
         * - **LOCAL_DISK**:common I/O disk.
         * - **SSD**: ultra-high I/O disk.
         */
        volumetype: string;
    }

    export interface GetFlaovrsFlavorElasticVolumeSpec {
        /**
         * Maximum disk size.
         */
        maxSize: number;
        /**
         * Minimum disk size.
         */
        minSize: number;
        /**
         * Disk size increment step.
         */
        step: number;
    }

}

export namespace Ecs {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the number of vCPUs in the ECS flavor.
         */
        cpuCoreCount: number;
        /**
         * Specifies the generation of an ECS type. For example, **s3** indicates
         * the general-purpose third-generation ECSs. For details, see
         * [ECS Specifications](https://support.huaweicloud.com/intl/en-us/productdesc-ecs/ecs_01_0014.html).
         */
        generation: string;
        /**
         * The ID of the flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the ECS flavor.
         */
        memorySize: number;
        /**
         * Specifies the ECS flavor type. Possible values are as follows:
         * + **normal**: General computing
         * + **computingv3**: General computing-plus
         * + **highmem**: Memory-optimized
         * + **saphana**: Large-memory HANA ECS
         * + **diskintensive**: Disk-intensive
         */
        performanceType: string;
        /**
         * Specifies the storage type.
         */
        storageType: string;
    }

    export interface GetInstanceNetwork {
        /**
         * Specifies the IPv4 addresses of the ECS.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * The network ID to attach to the server.
         */
        uuid: string;
    }

    export interface GetInstanceSchedulerHint {
        /**
         * The server group ID where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * Whether the volume is the system disk.
         */
        isSysVolume: boolean;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }

    export interface GetInstancesInstance {
        /**
         * Specifies the availability zone where the instance is located.
         * Please following [reference](https://developer.huaweicloud.com/intl/en-us/endpoint?ECS) for this argument.
         */
        availabilityZone: string;
        /**
         * The charging mode of the instance. Valid values are **prePaid**, **postPaid** and **spot**.
         */
        chargingMode: string;
        /**
         * Specifies the enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * The expired time of prePaid instance, in UTC format.
         */
        expiredTime: string;
        /**
         * Specifies the flavor ID.
         */
        flavorId: string;
        /**
         * Specifies the flavor name of the instance.
         */
        flavorName: string;
        /**
         * The instance ID in UUID format.
         */
        id: string;
        /**
         * Specifies the image ID of the instance.
         */
        imageId: string;
        /**
         * The image name of the instance.
         */
        imageName: string;
        /**
         * Specifies the key pair that is used to authenticate the instance.
         */
        keyPair: string;
        /**
         * Specifies the instance name, which can be queried with a regular expression.
         * The instance name supports fuzzy matching query too.
         */
        name: string;
        /**
         * An array of one or more networks to attach to the instance.
         * The network object structure is documented below.
         */
        networks: outputs.Ecs.GetInstancesInstanceNetwork[];
        /**
         * The EIP address that is associated to the instance.
         */
        publicIp: string;
        /**
         * The scheduler with hints on how the instance should be launched.
         * The scheduler hints structure is documented below.
         */
        schedulerHints: outputs.Ecs.GetInstancesInstanceSchedulerHint[];
        /**
         * An array of one or more security group IDs to associate with the instance.
         */
        securityGroupIds: string[];
        /**
         * Specifies the status of the instance. The valid values are as follows:
         * + **ACTIVE**: The instance is running properly.
         * + **SHUTOFF**: The instance has been properly stopped.
         * + **ERROR**: An error has occurred on the instance.
         */
        status: string;
        /**
         * The system disk volume ID.
         */
        systemDiskId: string;
        /**
         * Specifies the tags to qurey the instances.
         */
        tags: {[key: string]: string};
        /**
         * The user data (information after encoding) configured during instance creation.
         */
        userData: string;
        /**
         * An array of one or more disks to attach to the instance.
         * The volume attached object structure is documented below.
         */
        volumeAttacheds: outputs.Ecs.GetInstancesInstanceVolumeAttached[];
    }

    export interface GetInstancesInstanceNetwork {
        /**
         * Specifies the IPv4 addresses of the ECS.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * The network ID to attach to the server.
         */
        uuid: string;
    }

    export interface GetInstancesInstanceSchedulerHint {
        /**
         * The server group ID where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstancesInstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * Whether the volume is the system disk.
         */
        isSysVolume: boolean;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }

    export interface GetServergroupsServergroup {
        /**
         * The server group ID in UUID format.
         */
        id: string;
        /**
         * An array of one or more instance ID attached to the server group.
         */
        members: string[];
        /**
         * Specifies the server group name.
         */
        name: string;
        /**
         * The set of policies for the server group.
         */
        policies: string[];
    }

    export interface InstanceBandwidth {
        /**
         * Specifies the bandwidth billing mode. The value can be *traffic* or *bandwidth*.
         * Changing this creates a new instance.
         */
        chargeMode?: string;
        /**
         * Specifies the additional EIP information.
         * Changing this creates a new instance.
         */
        extendParam?: {[key: string]: string};
        /**
         * Specifies the **shared** bandwidth id. This parameter is mandatory when
         * `shareType` is set to **WHOLE**. Changing this creates a new instance.
         */
        id?: string;
        /**
         * Specifies the bandwidth sharing type. Changing this creates a new instance.
         * Possible values are as follows:
         * + **PER**: Dedicated bandwidth
         * + **WHOLE**: Shared bandwidth
         */
        shareType: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size?: number;
    }

    export interface InstanceDataDisk {
        /**
         * Specifies the data disk DSS pool ID. This field is used
         * only for dedicated storage. Changing this parameter will create a new resource.
         */
        dssPoolId?: string;
        /**
         * Specifies the IOPS(Input/Output Operations Per Second) for the disk.
         * The field is valid and required when `type` is set to **GPSSD2** or **ESSD2**.
         */
        iops?: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the disk.
         * Changing this creates a new instance.
         */
        kmsKeyId?: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size: number;
        /**
         * Specifies the EVS snapshot ID or ID of the original data disk contained in
         * the full-ECS image. Changing this creates a new instance.
         */
        snapshotId?: string;
        /**
         * Specifies the throughput for the disk. The Unit is MiB/s.
         * The field is valid and required when `type` is set to **GPSSD2**.
         */
        throughput?: number;
        /**
         * Specifies the ECS data disk type. Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceNetwork {
        /**
         * Specifies if this network should be used for provisioning access.
         * Accepts true or false. Defaults to false.
         */
        accessNetwork?: boolean;
        /**
         * Specifies a fixed IPv4 address to be used on this network.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * Specifies whether the IPv6 function is enabled for the nic.
         * Defaults to false. Changing this creates a new instance.
         */
        ipv6Enable?: boolean;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * Specifies whether the ECS processes only traffic that is destined specifically
         * for it. This function is enabled by default but should be disabled if the ECS functions as a SNAT server or has a
         * virtual IP address bound to it.
         */
        sourceDestCheck?: boolean;
        /**
         * Specifies the network UUID to attach to the instance.
         */
        uuid: string;
    }

    export interface InstanceSchedulerHint {
        /**
         * Specifies the ID of DeH.
         * This parameter takes effect only when the value of tenancy is dedicated. Changing this creates a new instance.
         */
        dehId?: string;
        faultDomain?: string;
        /**
         * Specifies a UUID of a Server Group.
         * The instance will be placed into that group. Changing this creates a new instance.
         */
        group: string;
        /**
         * Specifies the tenancy specifies whether the ECS is to be created on a
         * Dedicated Host
         * (DeH) or in a shared pool. Changing this creates a new instance.
         */
        tenancy?: string;
    }

    export interface InstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the disk.
         * Changing this creates a new instance.
         */
        kmsKeyId: string;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size: number;
        /**
         * Specifies the ECS data disk type. Changing this creates a new instance.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }
}

export namespace Eip {
    export interface GetBandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
         */
        type: string;
    }

    export interface GetEipsEip {
        /**
         * The bandwidth id of the EIP.
         */
        bandwidthId: string;
        /**
         * The bandwidth name of the EIP.
         */
        bandwidthName: string;
        /**
         * The bandwidth share type of the EIP.
         */
        bandwidthShareType: string;
        /**
         * The bandwidth size of the EIP.
         */
        bandwidthSize: number;
        /**
         * The create time of the EIP.
         */
        createdAt: string;
        /**
         * Specifies the enterprise project ID which the desired EIP belongs to.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the EIP.
         */
        id: string;
        /**
         * Specifies ip version of the desired EIP. The options are:
         * + `4`: IPv4.
         * + `6`: IPv6.
         */
        ipVersion: number;
        /**
         * The name of the EIP.
         */
        name: string;
        /**
         * The port id bound to the EIP.
         */
        portId: string;
        /**
         * The private ip address of the EIP.
         */
        privateIp: string;
        /**
         * The public ip address of the EIP.
         */
        publicIp: string;
        /**
         * The public ipv6 address of the EIP.
         */
        publicIpv6: string;
        /**
         * The status of the EIP.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired EIP.
         */
        tags: {[key: string]: string};
        /**
         * The type of the EIP.
         */
        type: string;
    }

}

export namespace Elb {
    export interface GetListenersListener {
        /**
         * The maximum number of connections allowed for the listener.
         */
        connectionLimit: number;
        /**
         * The ID of the default pool with which the ELB listener is associated.
         */
        defaultPoolId: string;
        /**
         * The ID of the server certificate used by the listener.
         */
        defaultTlsContainerRef: string;
        /**
         * The description of the ELB listener.
         */
        description: string;
        /**
         * Whether the ELB listener uses HTTP/2.
         */
        http2Enable: boolean;
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
        /**
         * Listener list.
         * The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetListenersListenerLoadbalancer[];
        /**
         * The listener name.
         */
        name: string;
        /**
         * The listener protocol.  
         * The valid values are **TCP**, **UDP**, **HTTP** and **TERMINATED_HTTPS**.
         */
        protocol: string;
        /**
         * The front-end listening port of the listener.  
         * The valid value is range from `1` to `65535`.
         */
        protocolPort: number;
        /**
         * List of the SNI certificate (server certificates with a domain name) IDs used by the listener.
         */
        sniContainerRefs: string[];
    }

    export interface GetListenersListenerLoadbalancer {
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
    }

    export interface GetPoolsPool {
        /**
         * Specifies the description of the ELB pool.
         */
        description: string;
        /**
         * Specifies the health monitor ID of the ELB pool.
         */
        healthmonitorId: string;
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
        /**
         * Specifies the method of the ELB pool. Must be one of ROUND_ROBIN, LEAST_CONNECTIONS,
         * or SOURCE_IP.
         */
        lbMethod: string;
        /**
         * The listener list. The object structure is documented below.
         */
        listeners: outputs.Elb.GetPoolsPoolListener[];
        /**
         * The loadbalancer list. The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetPoolsPoolLoadbalancer[];
        /**
         * The member list. The object structure is documented below.
         */
        members: outputs.Elb.GetPoolsPoolMember[];
        /**
         * Specifies the name of the ELB pool.
         */
        name: string;
        /**
         * Indicates whether connections in the same session will be processed by the same pool member or not.
         * The object structure is documented below.
         */
        persistences: outputs.Elb.GetPoolsPoolPersistence[];
        /**
         * Specifies the protocol of the ELB pool. This can either be TCP, UDP or HTTP.
         */
        protocol: string;
    }

    export interface GetPoolsPoolListener {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolMember {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately.
         */
        cookieName: string;
        /**
         * The type of persistence mode.
         */
        type: string;
    }

    export interface PoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately. Required
         * if `type = APP_COOKIE`.
         */
        cookieName?: string;
        /**
         * Specifies the sticky session timeout duration in minutes. This parameter is
         * invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
         * + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
         * + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
         */
        timeout: number;
        /**
         * The type of persistence mode. The current specification supports SOURCE_IP,
         * HTTP_COOKIE, and APP_COOKIE.
         */
        type: string;
    }
}

export namespace Evs {
    export interface GetVolumesVolume {
        /**
         * The disk attachment information. Structure is documented below.
         */
        attachments: outputs.Evs.GetVolumesVolumeAttachment[];
        /**
         * Specifies the availability zone for the disks.
         */
        availabilityZone: string;
        /**
         * Whether the disk is bootable.
         */
        bootable: boolean;
        /**
         * The time when the disk was created.
         */
        createAt: string;
        /**
         * The disk description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID for filtering.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        /**
         * the IOPS(Input/Output Operations Per Second) of the volume. Only valid when `volumeType` is **GPSSD2** or
         * **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the name for the disks. This field will undergo a fuzzy matching query, the
         * query result is for all disks whose names contain this value.
         */
        name: string;
        /**
         * The service type, such as EVS, DSS or DESS.
         */
        serviceType: string;
        /**
         * Specifies whether the disk is shareable.
         */
        shareable: boolean;
        /**
         * The disk size, in GB.
         */
        size: number;
        /**
         * Specifies the disk status. The valid values are as following:
         * + **FREEZED**
         * + **BIND_ERROR**
         * + **BINDING**
         * + **PENDING_DELETE**
         * + **PENDING_CREATE**
         * + **NOTIFYING**
         * + **NOTIFY_DELETE**
         * + **PENDING_UPDATE**
         * + **DOWN**
         * + **ACTIVE**
         * + **ELB**
         * + **ERROR**
         * + **VPN**
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired disk.
         */
        tags: {[key: string]: string};
        /**
         * The throughput of the system disk. Only valid when `volumeType` is **GPSSD2**.
         */
        throughput: number;
        /**
         * The time when the disk was updated.
         */
        updateAt: string;
        /**
         * The disk type. Valid values are as follows:
         * + **SAS**: High I/O type.
         * + **SSD**: Ultra-high I/O type.
         * + **GPSSD**: General purpose SSD type.
         * + **ESSD**: Extreme SSD type.
         * + **GPSSD2**: General purpose SSD V2 type.
         * + **ESSD2**: Extreme SSD V2 type.
         */
        volumeType: string;
        /**
         * The unique identifier used when attaching the disk.
         */
        wwn: string;
    }

    export interface GetVolumesVolumeAttachment {
        /**
         * The time when the disk was attached.
         */
        attachedAt: string;
        /**
         * The ID of the attachment information.
         */
        attachedMode: string;
        /**
         * The device name to which the disk is attached.
         */
        deviceName: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        /**
         * Specifies the server ID to which the disks are attached.
         */
        serverId: string;
    }

    export interface VolumeAttachment {
        /**
         * The device name.
         */
        device: string;
        /**
         * The ID of the attachment information.
         */
        id: string;
        /**
         * The ID of the server to which the disk is attached.
         */
        instanceId: string;
    }

}

export namespace FunctionGraph {
    export interface FunctionCustomImage {
        /**
         * Specifies the command line arguments used to start the SWR image.  
         * If multiple arguments are separated by commas (,). e.g. `-args,value`.
         * If this parameter is not specified, the CMD in the image configuration will be used by default.
         */
        args?: string;
        /**
         * Specifies the startup commands of the SWR image.  
         * Multiple commands are separated by commas (,). e.g. `/bin/sh`.
         * If this parameter is not specified, the entrypoint or CMD in the image configuration will be used by default.
         */
        command?: string;
        /**
         * Specifies the URL of SWR image, the URL must start with `swr.`.
         */
        url: string;
        userGroupId?: string;
        userId?: string;
        /**
         * Specifies the working directory of the SWR image.  
         * If not specified, the default value is `/`.
         * Currently, the folder path can only be set to `/` and it cannot be created or modified.
         */
        workingDir: string;
    }

    export interface FunctionFuncMount {
        /**
         * Specifies the function access path.
         */
        localMountPath: string;
        /**
         * Specifies the ID of the mounted resource (corresponding cloud service).
         */
        mountResource: string;
        /**
         * Specifies the remote mount path, e.g. **192.168.0.12:/data**.
         */
        mountSharePath: string;
        /**
         * Specifies the mount type.
         * + **sfs**
         * + **sfsTurbo**
         * + **ecs**
         */
        mountType: string;
        /**
         * The mount status.
         */
        status: string;
    }

    export interface FunctionNetworkController {
        /**
         * Specifies whether to disable the public network access.
         */
        disablePublicNetwork?: boolean;
        /**
         * Specifies the configuration of the VPCs that can trigger the function.  
         * The triggerAccessVpcs structure is documented below.
         */
        triggerAccessVpcs: outputs.FunctionGraph.FunctionNetworkControllerTriggerAccessVpc[];
    }

    export interface FunctionNetworkControllerTriggerAccessVpc {
        /**
         * Specifies the ID of the VPC that can trigger the function.
         */
        vpcId: string;
    }

    export interface FunctionReservedInstance {
        /**
         * Specifies the number of reserved instance to which the policy belongs.  
         * The valid value is range from `0` to `1,000`.
         */
        count: number;
        /**
         * Specifies whether to enable the idle mode.  
         * Defaults to **false**.
         * If this parameter is enabled, reserved instances are initialized and the mode change needs some time to take effect.
         * You will still be billed at the price of reserved instances for non-idle mode in this period.
         */
        idleMode?: boolean;
        /**
         * Specifies the version name or alias name.
         */
        qualifierName: string;
        /**
         * Specifies the qualifier type of reserved instance.  
         * The valid values are as follows:
         * + **version**
         * + **alias**
         */
        qualifierType: string;
        /**
         * Specifies the auto scaling policies for reserved instance.  
         * The tacticsConfig structure is documented below.
         */
        tacticsConfig?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfig;
    }

    export interface FunctionReservedInstanceTacticsConfig {
        /**
         * Specifies the list of scheduled policy configurations.  
         * The cronConfigs structure is documented below.
         */
        cronConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigCronConfig[];
        /**
         * Specifies the list of metric policy configurations.  
         * The metricConfigs structure is documented below.
         */
        metricConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigMetricConfig[];
    }

    export interface FunctionReservedInstanceTacticsConfigCronConfig {
        /**
         * Specifies the number of reserved instance to which the policy belongs.  
         * The valid value is range from `0` to `1,000`.
         */
        count: number;
        /**
         * Specifies the cron expression.  
         * For the syntax, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
         */
        cron: string;
        /**
         * Specifies the expiration timestamp of the policy. The unit is `s`, e.g. **1740560074**.
         */
        expiredTime: number;
        /**
         * Specifies the name of metric policy.  
         * The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
         * allowed. The name must start with a letter and ending with a letter or digit.
         */
        name: string;
        /**
         * Specifies the effective timestamp of policy. The unit is `s`, e.g. **1740560074**.
         */
        startTime: number;
    }

    export interface FunctionReservedInstanceTacticsConfigMetricConfig {
        /**
         * Specifies the minimun of traffic.  
         * The valid value is range from `0` to `1,000`.
         */
        min: number;
        /**
         * Specifies the name of metric policy.  
         * The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
         * allowed. The name must start with a letter and ending with a letter or digit.
         */
        name: string;
        /**
         * Specifies the metric policy threshold.  
         * The valid value is range from `1` to `99`.
         */
        threshold: number;
        /**
         * Specifies the type of metric policy.  
         * The valid value is as follows:
         * + **Concurrency**: Reserved instance usage.
         */
        type: string;
    }

    export interface FunctionVersion {
        /**
         * Specifies the aliases management for specified version.  
         * The aliases structure is documented below.
         */
        aliases?: outputs.FunctionGraph.FunctionVersionAliases;
        /**
         * Specifies the description of the version alias.
         */
        description?: string;
        /**
         * Specifies the name of metric policy.  
         * The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
         * allowed. The name must start with a letter and ending with a letter or digit.
         */
        name: string;
    }

    export interface FunctionVersionAliases {
        /**
         * Specifies the rule grayscale configuration of the version
         * alias, in JSON format.
         */
        additionalVersionStrategy?: string;
        /**
         * Specifies the percentage grayscale configuration of the version
         * alias, in JSON format.
         */
        additionalVersionWeights?: string;
        /**
         * Specifies the description of the version alias.
         */
        description?: string;
        /**
         * Specifies the name of metric policy.  
         * The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
         * allowed. The name must start with a letter and ending with a letter or digit.
         */
        name: string;
    }

    export interface GetDependenciesPackage {
        /**
         * The unique ID of the dependency package.
         */
        etag: string;
        /**
         * The file name of the stored dependency package.
         */
        fileName: string;
        /**
         * The ID of the dependency package version.
         */
        id: string;
        /**
         * The OBS bucket path where the dependency package is located (FunctionGraph serivce side).
         */
        link: string;
        /**
         * Specifies the name of the dependency package.
         */
        name: string;
        /**
         * The owner of the dependency package.
         */
        owner: string;
        /**
         * Specifies the runtime of the dependency package.  
         * The valid values are as follows:
         * + **Java8**
         * + **Java11**
         * + **Node.js6.10**
         * + **Node.js8.10**
         * + **Node.js10.16**
         * + **Node.js12.13**
         * + **Node.js14.18**
         * + **Node.js16.17**
         * + **Node.js18.15**
         * + **Python2.7**
         * + **Python3.6**
         * + **Python3.9**
         * + **Python3.10**
         * + **Go1.x**
         * + **C#(.NET Core 2.0)**
         * + **C#(.NET Core 2.1)**
         * + **C#(.NET Core 3.1)**
         * + **Custom**
         * + **PHP7.3**
         * + **Cangjie1.0**
         * + **http**
         * + **Custom Image**
         */
        runtime: string;
        /**
         * The size of the dependency package.
         */
        size: number;
        /**
         * The list of the versions for the dependency package.
         * The versions structure is documented below.
         */
        versions: outputs.FunctionGraph.GetDependenciesPackageVersion[];
    }

    export interface GetDependenciesPackageVersion {
        /**
         * The ID of the dependency package version.
         */
        id: string;
        /**
         * The dependency package version.
         */
        version: number;
    }

    export interface TriggerApig {
        /**
         * Specifies the API name. Changing this will create a new trigger resource.
         */
        apiName: string;
        /**
         * Specifies the API environment name.
         * Changing this will create a new trigger resource.
         */
        envName: string;
        /**
         * Specifies the ID of the APIG group to which the API belongs.
         * Changing this will create a new trigger resource.
         */
        groupId: string;
        /**
         * Specifies the ID of the APIG dedicated instance to which the API belongs.
         * Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
         */
        instanceId?: string;
        /**
         * Specifies the request protocol of the API. The valid value are
         * **HTTP** and **HTTPS**. Default to **HTTPS**. Changing this will create a new trigger resource.
         */
        requestProtocol?: string;
        /**
         * Specifies the security authentication mode. The valid values
         * are **NONE**, **APP** and **IAM**, default to **IAM**. Changing this will create a new trigger resource.
         */
        securityAuthentication?: string;
        /**
         * Specifies the timeout for request sending. The valid value is range form
         * `1` to `60,000`, default to `5,000`. Changing this will create a new trigger resource.
         */
        timeout?: number;
    }

    export interface TriggerDis {
        /**
         * Specifies the maximum volume of data that can be obtained for a single
         * request, in Byte. Only the records with a size smaller than this value can be obtained.
         * The valid value is range from `1,024` to `4,194,304`.
         * Changing this will create a new trigger resource.
         */
        maxFetchBytes: number;
        /**
         * Specifies the interval at which data is pulled from the specified stream.
         * The valid value is range from `2` to `60,000`.
         * Changing this will create a new trigger resource.
         */
        pullPeriod: number;
        /**
         * Specifies the determines whether to pull data only after the data pulled
         * in the last period has been processed.
         * Changing this will create a new trigger resource.
         */
        serialEnable: boolean;
        /**
         * Specifies the type of starting position for DIS queue.
         * The valid values are as follows:
         * + **TRIM_HORIZON**: Starts reading from the earliest data stored in the partitions.
         * + **LATEST**: Starts reading from the latest data stored in the partitions.
         * Changing this will create a new trigger resource.
         */
        startingPosition: string;
        /**
         * Specifies the name of the DIS stream resource.
         * Changing this will create a new trigger resource.
         */
        streamName: string;
    }

    export interface TriggerKafka {
        /**
         * Specifies the The number of messages consumed from the topic each time.
         * The valid value is range from `1` to `1,000`. Defaults to `100`.
         * Changing this will create a new trigger resource.
         */
        batchSize?: number;
        /**
         * Specifies the ID of the APIG dedicated instance to which the API belongs.
         * Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
         */
        instanceId: string;
        /**
         * Specifies the password for logging in to the Kafka Manager.
         * Changing this will create a new trigger resource.
         */
        password?: string;
        /**
         * Specifies one or more topic IDs of DMS kafka instance.
         * Changing this will create a new trigger resource.
         */
        topicIds: string[];
        /**
         * Specifies the username for logging in to the Kafka Manager.
         * Changing this will create a new trigger resource.
         */
        userName?: string;
    }

    export interface TriggerLts {
        /**
         * Specifies the log group ID.
         * Changing this will create a new trigger resource.
         */
        logGroupId: string;
        /**
         * Specifies the log stream ID.
         * Changing this will create a new trigger resource.
         */
        logTopicId: string;
    }

    export interface TriggerObs {
        /**
         * Specifies the OBS bucket name.
         * Changing this will create a new trigger resource.
         */
        bucketName: string;
        /**
         * Specifies the event notification name.
         * Changing this will create a new trigger resource.
         */
        eventNotificationName: string;
        /**
         * Specifies the events that can trigger functions.
         * Changing this will create a new trigger resource.
         * The valid values are as follows:
         * + **ObjectCreated**, **Put**, **Post**, **Copy** and **CompleteMultipartUpload**.
         * + **ObjectRemoved**, **Delete** and **DeleteMarkerCreated**.
         */
        events: string[];
        /**
         * Specifies the prefix to limit notifications to objects beginning with this keyword.
         * Changing this will create a new trigger resource.
         */
        prefix?: string;
        /**
         * Specifies the suffix to limit notifications to objects ending with this keyword.
         * Changing this will create a new trigger resource.
         */
        suffix?: string;
    }

    export interface TriggerSmn {
        /**
         * Specifies the Uniform Resource Name (URN) for SMN topic.
         * Changing this will create a new trigger resource.
         */
        topicUrn: string;
    }

    export interface TriggerTimer {
        /**
         * Specifies the event used by the timer to trigger the function.
         * Changing this will create a new trigger resource.
         */
        additionalInformation?: string;
        /**
         * Specifies the trigger name, which can contains of `1` to `64` characters.
         * The name must start with a letter, only letters, digits, hyphens (-) and underscores (_) are allowed.
         * Changing this will create a new trigger resource.
         */
        name: string;
        /**
         * Specifies the time schedule.
         * For the rate type, schedule is composed of time and time unit.
         * The time unit supports minutes (m), hours (h) and days (d).
         * For the corn expression, please refer to the HuaweiCloud
         * [document](https://support.huaweicloud.com/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
         * Changing this will create a new trigger resource.
         */
        schedule: string;
        /**
         * Specifies the type of the time schedule.
         * The valid values are **Rate** and **Cron**.
         * Changing this will create a new trigger resource.
         */
        scheduleType: string;
    }

}

export namespace GaussDB {
    export interface GetMysqlFlavorsFlavor {
        /**
         * Indicates the flavor status in each availability zone.
         */
        azStatus: {[key: string]: string};
        /**
         * Indicates the memory size in GB.
         */
        memory: string;
        /**
         * Indicates the database mode.
         */
        mode: string;
        /**
         * The name of the gaussdb mysql flavor.
         */
        name: string;
        /**
         * Indicates the arch type of the flavor.
         */
        type: string;
        /**
         * Indicates the CPU size.
         */
        vcpus: string;
        /**
         * Specifies the database version. Only "8.0" is supported now.
         */
        version: string;
    }

    export interface GetMysqlInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetMysqlInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetMysqlInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }

    export interface GetMysqlInstancesInstance {
        /**
         * Indicates the availability zone mode: "single" or "multi".
         */
        availabilityZoneMode: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDB.GetMysqlInstancesInstanceBackupStrategy[];
        /**
         * Indicates the configuration ID.
         */
        configurationId: string;
        /**
         * Indicates the creation time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        createdAt: string;
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDB.GetMysqlInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the description of the instance.
         */
        description: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the start time for a maintenance window.
         */
        maintainBegin: string;
        /**
         * Indicates the end time for a maintenance window.
         */
        maintainEnd: string;
        /**
         * Indicates the availability zone where the master node resides.
         */
        masterAvailabilityZone: string;
        /**
         * Indicates the instance mode.
         */
        mode: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDB.GetMysqlInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the private domain name.
         */
        privateDnsName: string;
        /**
         * Indicates the prefix of the private domain name.
         */
        privateDnsNamePrefix: string;
        /**
         * Indicates the private IP address of the DB instance.
         */
        privateWriteIp: string;
        /**
         * Indicates the count of read replicas.
         */
        readReplicas: number;
        /**
         * The region in which to obtain the instances. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the time zone.
         */
        timeZone: string;
        /**
         * Indicates the Update time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        updatedAt: string;
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetMysqlInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetMysqlInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetMysqlInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }

    export interface MysqlInstanceAutoScaling {
        /**
         * Specifies the average CPU usage (%). It is mandatory when `status` is set to
         * **ON**. Value options: **50100**.
         */
        enlargeThreshold: number;
        /**
         * Indicates the ID of an auto-scaling policy.
         */
        id: string;
        /**
         * Specifies the maximum specifications. It is mandatory when the instance specifications
         * are automatically scaled up or down.
         */
        maxFlavor: string;
        /**
         * Specifies the maximum number of read replicas. It is mandatory when read
         * replicas are automatically added or deleted.
         */
        maxReadOnlyCount: number;
        /**
         * Indicates the minimum specifications.
         */
        minFlavor: string;
        /**
         * Indicates the minimum number of read replicas.
         */
        minReadOnlyCount: number;
        /**
         * Specifies the observation period, in seconds. During the entire observation period,
         * if the average CPU usage is greater than or equal to the preset value, a scale-up is triggered. It is mandatory when
         * `status` is set to **ON**. Value options: **300**, **600**, **900** or **1800**.
         */
        monitorCycle: number;
        /**
         * Specifies the read weights of read replicas. It is mandatory when read replicas
         * are automatically added or deleted.
         */
        readOnlyWeight: number;
        /**
         * Specifies whether auto-down is enabled. It is mandatory when `status` is set to
         * **ON**. Value options:
         * + **true**: enabled.
         * + **false**: disabled.
         */
        reduceEnabled: boolean;
        /**
         * Specifies the auto-scaling policy.
         * The scalingStrategy structure is documented below.
         */
        scalingStrategy: outputs.GaussDB.MysqlInstanceAutoScalingScalingStrategy;
        /**
         * Specifies the silent period, in seconds. It indicates the minimum interval between
         * two auto scale-up operations or two scale-down operations. It is mandatory when `status` is set to **ON**. Value
         * options: **300**,  **600**, **1800**, **3600**, **7200**, **10800**, **86400** or **604800**.
         */
        silenceCycle: number;
        /**
         * Indicates the start time of the silent period.
         */
        silenceStartAt: string;
        /**
         * Specifies whether auto-scaling is enabled. Value options:
         * + **ON**: enabled.
         * + **OFF**: disabled.
         */
        status: string;
    }

    export interface MysqlInstanceAutoScalingScalingStrategy {
        /**
         * Specifies whether instance specifications can be automatically scaled up or down.
         * Value options:
         * + **ON**: Yes
         * + **OFF**: No
         */
        flavorSwitch: string;
        /**
         * Specifies whether read replicas can be automatically added or deleted. To use
         * this function, ensure that there is only one proxy instance.
         * Value options:
         * + **ON**: Yes
         * + **OFF**: No
         */
        readOnlySwitch: string;
    }

    export interface MysqlInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files.  
         * The value ranges from `0` to `35`. If this parameter is set to `0`, the automated backup policy is not set.
         * If this parameter is not transferred, the automated backup policy is enabled by default.
         * Backup files are stored for seven days by default.
         */
        keepDays?: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: **08:00-09:00**, **03:00-04:00**.
         */
        startTime: string;
    }

    export interface MysqlInstanceDatastore {
        /**
         * Specifies the database engine. Only "gaussdb-mysql" is supported now.
         * Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the database version. Only "8.0" is supported now.
         * Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface MysqlInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the ID of an auto-scaling policy.
         */
        id: string;
        /**
         * Specifies the name of the parameter.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Specifies whether auto-scaling is enabled. Value options:
         * + **ON**: enabled.
         * + **OFF**: disabled.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }

    export interface MysqlInstanceParameter {
        /**
         * Specifies the name of the parameter.
         */
        name: string;
        /**
         * Specifies the value of the parameter.
         */
        value: string;
    }

    export interface MysqlProxyAccessControlIpList {
        /**
         * Specifies the description.
         * The description contains a maximum of `50` characters and the angle brackets (< and >) are not allowed.
         */
        description: string;
        /**
         * Specifies the IP address or CIDR block.
         */
        ip: string;
    }

    export interface MysqlProxyMasterNodeWeight {
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Specifies the weight assigned to the node.
         * + If `routeMode` is `0`, the value is `0` to `1,000`.
         * + If `routeMode` is `1`, the value for the primary node is `0` and the value for read replicas is `0` or `1`.
         * + If `routeMode` is `2`, the value for the primary node is `1` and the value for read replicas is `0` or `1`.
         */
        weight: number;
    }

    export interface MysqlProxyNode {
        /**
         * Indicates the proxy node AZ.
         */
        azCode: string;
        /**
         * Indicates whether the proxy node is frozen. The values can be:
         * + **0**: unfrozen.
         * + **1**: frozen.
         * + **2**: deleted after being frozen.
         */
        frozenFlag: number;
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Specifies the name of the parameter.
         */
        name: string;
        /**
         * Indicates the proxy node role. The values can be:
         * + **master**: primary node.
         * + **slave**: read replica.
         */
        role: string;
        /**
         * Indicates the proxy node status. The values can be:
         * + **ACTIVE**: The node is available.
         * + **ABNORMAL**: The node is abnormal.
         * + **FAILED**: The node fails.
         * + **DELETED**: The node has been deleted.
         */
        status: string;
    }

    export interface MysqlProxyParameter {
        /**
         * Specifies the parent tag type of the parameter.
         */
        elemType: string;
        /**
         * Specifies the name of the parameter.
         */
        name: string;
        /**
         * Specifies the value of the parameter.
         */
        value: string;
    }

    export interface MysqlProxyReadonlyNodesWeight {
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Specifies the weight assigned to the node.
         * + If `routeMode` is `0`, the value is `0` to `1,000`.
         * + If `routeMode` is `1`, the value for the primary node is `0` and the value for read replicas is `0` or `1`.
         * + If `routeMode` is `2`, the value for the primary node is `1` and the value for read replicas is `0` or `1`.
         */
        weight: number;
    }
}

export namespace GaussDBforNoSQL {
    export interface CassandraInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * 0 to 35. If this parameter is set to 0, the automated backup policy is not set. If this parameter is not transferred,
         * the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface CassandraInstanceDatastore {
        /**
         * Specifies the database engine. Only "GeminiDB-Cassandra" is supported now.
         * Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only "rocksDB" is supported now.
         * Changing this parameter will create a new resource.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         * Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface CassandraInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The value
         * must be `4` to `64` characters in length and start with a letter. It is case-sensitive and can contain only letters,
         * digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface GetCassandraFlavorsFlavor {
        /**
         * Indicates the flavor status in each availability zone.
         */
        azStatus: {[key: string]: string};
        /**
         * Specifies the memory size of the flavors.
         */
        memory: string;
        /**
         * Indicates the spec code of the flavor.
         */
        name: string;
        /**
         * Specifies the count of vcpus of the flavors.
         */
        vcpus: string;
        /**
         * Specifies the engine version of the flavors.
         */
        version: string;
    }

    export interface GetCassandraInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetCassandraInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetCassandraInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface GetCassandraInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceBackupStrategy[];
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the instance mode.
         */
        mode: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the count of the nodes.
         */
        nodeNum: number;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the list of private IP address of the nodes.
         */
        privateIps: string[];
        /**
         * The region in which to obtain the instance. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the key/value tags of the instance.
         */
        tags: {[key: string]: string};
        /**
         * Indicates the size of the volume.
         */
        volumeSize: number;
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetCassandraInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetCassandraInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetCassandraInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface GetNosqlFlavorsFlavor {
        /**
         * All available zones (on sale) for current flavor.
         */
        availabilityZones: string[];
        /**
         * Specifies the type of the database engine. The valid values are as follows:
         * + **cassandra**: The default value and means to query GaussDB (for Cassandra) instance specifications.
         * + **redis**: Means to query GaussDB (for Redis) instance specifications.
         * + **mongodb**: Means to query GaussDB (for Mongo) instance specifications.
         * + **influxdb**: Means to query GaussDB (for Influx) instance specifications.
         */
        engine: string;
        /**
         * Specifies the version of the database engine.
         */
        engineVersion: string;
        /**
         * Specifies the memory size in gigabytes (GB).
         */
        memory: string;
        /**
         * The spec code of the flavor.
         */
        name: string;
        /**
         * Specifies the number of vCPUs.
         */
        vcpus: string;
    }

    export interface GetRedisInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetRedisInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetRedisInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface InfluxInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * `0` to `35`. If this parameter is set to `0`, the automated backup policy is not set. If this parameter is not
         * transferred, the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface InfluxInstanceDatastore {
        /**
         * Specifies the database engine. Only **influxdb** is supported now.
         * Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only **rocksDB** is supported now.
         * Changing this parameter will create a new resource.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         * Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface InfluxInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The
         * value must be `4` to `64` characters in length and start with a letter. It is case-sensitive and can contain only
         * letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface MongoInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * `0` to `35`. If this parameter is set to `0`, the automated backup policy is not set. If this parameter is not
         * transferred, the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface MongoInstanceDatastore {
        /**
         * Specifies the database engine. Only **mongodb** is supported now.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only **rocksDB** is supported now.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface MongoInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The
         * value must be `4` to `64` characters in length and start with a letter. It is case-sensitive and can contain only
         * letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface RedisInstanceAvailabilityZoneDetail {
        /**
         * Specifies the primary AZ, it must be a single AZ and be
         * different from the standby AZ. Changing this parameter will create a new resource.
         */
        primaryAvailabilityZone: string;
        /**
         * Specifies the standby AZ, it must be a single AZ and be
         * different from the primary AZ. Changing this parameter will create a new resource.
         */
        secondaryAvailabilityZone: string;
    }

    export interface RedisInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * 0 to 35. If this parameter is set to `0`, the automated backup policy is not set. If this parameter is not transferred,
         * the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be `1` greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: **08:00-09:00**, **03:00-04:00**.
         */
        startTime: string;
    }

    export interface RedisInstanceDatastore {
        /**
         * Specifies the database engine. Only "redis" is supported now.
         * Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only "rocksDB" is supported now.
         * Changing this parameter will create a new resource.
         */
        storageEngine: string;
        /**
         * Specifies the database version. Only "5.0" is supported now.
         * Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface RedisInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The value
         * must be `4` to `64` characters in length and start with a letter. It is case-sensitive and can contain only letters,
         * digits, hyphens (-), and underscores (_). Chinese characters must be in UTF-8 or Unicode format.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the public IP address of a node.
         */
        publicIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }
}

export namespace GaussDBforOpenGauss {
    export interface GetOpengaussInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetOpengaussInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetOpengaussInstanceHa {
        /**
         * Indicates the replication mode.
         */
        replicationMode: string;
    }

    export interface GetOpengaussInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates whether the node support reduce.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetOpengaussInstanceVolume {
        /**
         * Indicates the volume size. For ECS deployment: The value is from (Number of shards x 40 GB) to (Number of
         * shards x 24 TB) and must be a multiple of (Number of shards x 4 GB).
         */
        size: number;
        /**
         * Indicates the volume type. Value options: **ULTRAHIGH**, **ESSD**.
         */
        type: string;
    }

    export interface GetOpengaussInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceBackupStrategy[];
        /**
         * Indicates the count of coordinator node.
         */
        coordinatorNum: number;
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the instance ha information. Structure is documented below.
         */
        has: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceHa[];
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the maintenance window.
         */
        maintenanceWindow: string;
        /**
         * Indicates the port for MySQL compatibility.
         */
        mysqlCompatibilityPort: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the list of private IP address of the nodes.
         */
        privateIps: string[];
        /**
         * Indicates the public IP address of the DB instance.
         */
        publicIps: string[];
        /**
         * The region in which to obtain the instance. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the replica num.
         */
        replicaNum: number;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the sharding num.
         */
        shardingNum: number;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the switch strategy.
         */
        switchStrategy: string;
        /**
         * Indicates the default username.
         */
        timeZone: string;
        /**
         * Indicates the volume type.
         */
        type: string;
        /**
         * Indicates the volume information. Structure is documented below.
         */
        volumes: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceVolume[];
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetOpengaussInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetOpengaussInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetOpengaussInstancesInstanceHa {
        /**
         * Indicates the replication mode.
         */
        replicationMode: string;
    }

    export interface GetOpengaussInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates whether the node support reduce.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetOpengaussInstancesInstanceVolume {
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Indicates the volume type.
         */
        type: string;
    }

    export interface OpengaussInstanceAdvanceFeature {
        /**
         * Specifies the name of the advance feature.
         */
        name: string;
        /**
         * Specifies the value of the advance feature.
         */
        value: string;
    }

    export interface OpengaussInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * `0` to `732`. If this parameter is set to `0`, the automated backup policy is not set.
         * If this parameter is not transferred, the automated backup policy is enabled by default.
         */
        keepDays?: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the **hh:mm-HH:MM** format. The current time is in the UTC format. The
         * **HH** value must be `1` greater than the **hh** value. The values of mm and MM must be the same and must be set to
         * **00**. Example value: **08:00-09:00**, **23:00-00:00**.
         */
        startTime: string;
    }

    export interface OpengaussInstanceDatastore {
        /**
         * Specifies the database engine. Only **GaussDB(for openGauss)** is supported
         * now. Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the database version. Defaults to the latest version. Please
         * reference to the API docs for valid options. Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface OpengaussInstanceHa {
        /**
         * Specifies the database consistency mode.
         * The valid values are **strong** and **eventual**, not case-sensitive.
         * Changing this parameter will create a new resource.
         */
        consistency: string;
        /**
         * Specifies the product type of the instance. Value options:
         * + **enterprise**: The instance of the enterprise edition will be created.
         * + **basic**: The instance of the basic edition will be created.
         * + **ecology**: The instance of the ecosystem edition will be created.
         */
        instanceMode: string;
        /**
         * Specifies the deployment model.
         * The valid values are **enterprise** and **centralization_standard**.
         * Changing this parameter will create a new resource.
         */
        mode: string;
        /**
         * Specifies the database replication mode.
         * Only **sync** is supported now. Changing this parameter will create a new resource.
         */
        replicationMode: string;
    }

    export interface OpengaussInstanceNode {
        /**
         * Specifies the availability zone information, can be three same or
         * different az like **cn-north-4a,cn-north-4a,cn-north-4a**. Changing this parameter will create a new resource.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the advance feature.
         */
        name: string;
        /**
         * Indicates the private IP address of the node.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         * + **master**.
         * + **slave**.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface OpengaussInstanceParameter {
        /**
         * Specifies the name of the advance feature.
         */
        name: string;
        /**
         * Specifies the value of the advance feature.
         */
        value: string;
    }

    export interface OpengaussInstanceVolume {
        /**
         * Specifies the volume size (in gigabytes). The valid value is range form `40` to `4,000`.
         */
        size: number;
        /**
         * Specifies the volume type. Only **ULTRAHIGH** is supported now.
         * Changing this parameter will create a new resource.
         */
        type: string;
    }
}

export namespace Iam {
    export interface AclIpCidr {
        /**
         * Specifies the IPv4 CIDR block, for example, **192.168.0.0/24**.
         */
        cidr: string;
        /**
         * Specifies a description about an IP address range. This parameter can contain a
         * maximum of 255 characters and the following characters are not allowed:**@#%^&*<>\\**.
         */
        description?: string;
    }

    export interface AclIpRange {
        /**
         * Specifies a description about an IP address range. This parameter can contain a
         * maximum of 255 characters and the following characters are not allowed:**@#%^&*<>\\**.
         */
        description?: string;
        /**
         * Specifies the Ip address range, for example, **0.0.0.0-255.255.255.0**.
         */
        range: string;
    }

    export interface AgencyProjectRole {
        /**
         * Specifies the name of project.
         */
        project: string;
        /**
         * Specifies an array of role names.
         */
        roles: string[];
    }

    export interface GetAgenciesAgency {
        /**
         * The time when the agency was created.
         */
        createdAt: string;
        /**
         * The supplementary information about the agency.
         */
        description: string;
        /**
         * The validity period of an agency.
         */
        duration: string;
        /**
         * The expiration time of agency.
         */
        expiredAt: string;
        /**
         * The agency ID.
         */
        id: string;
        /**
         * Specifies the name of agency. The name is a string of 1 to 64 characters.
         */
        name: string;
        /**
         * Specifies the ID of delegated user domain.
         */
        trustDomainId: string;
        /**
         * The name of delegated user domain.
         */
        trustDomainName: string;
    }

    export interface GetGroupUser {
        /**
         * Specifies the description of the identity group.
         */
        description: string;
        /**
         * Indicates the whether the IAM user is enabled.
         */
        enabled: boolean;
        /**
         * Specifies the ID of the identity group.
         */
        id: string;
        /**
         * Specifies the name of the identity group.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * If this value is not set, the password will not expire.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
        /**
         * Indicates the password strength. The value can be high, mid, or low.
         */
        passwordStrength: string;
    }

    export interface GetPermissionsPermission {
        /**
         * Specifies the service catalog of the permission.
         */
        catalog: string;
        /**
         * The description of the permission.
         */
        description: string;
        /**
         * The description of the permission in Chinese.
         */
        descriptionCn: string;
        /**
         * The permission ID.
         */
        id: string;
        /**
         * Specifies the permission name or filter condition.
         * + Permission name: For example, if you set this parameter to **ECS FullAccess**, information about the permission will
         * be returned.
         * + Filter condition: For example, if you set this parameter to **Administrator**, all administrator permissions that
         * meet the conditions will be returned.
         */
        name: string;
        /**
         * The content of the permission.
         */
        policy: string;
    }

    export interface GetProjectsProject {
        /**
         * Whether the IAM project is enabled.
         */
        enabled: boolean;
        /**
         * The IAM project ID.
         */
        id: string;
        /**
         * Specifies the IAM project name to query.
         */
        name: string;
    }

    export interface GetProvidersIdentityProvider {
        /**
         * The description of the identity provider.
         */
        description: string;
        /**
         * The identity provider ID which equals the identity provider name.
         */
        id: string;
        /**
         * The links of identity provider.
         */
        links: outputs.Iam.GetProvidersIdentityProviderLink[];
        /**
         * The list of federated user IDs configured for the identity provider.
         */
        remoteIds: string[];
        /**
         * Specifies the single sign-on type of the identity provider.
         */
        ssoType: string;
        /**
         * Specifies the status of the identity provider. The value can be **true** or **false**
         */
        status: boolean;
    }

    export interface GetProvidersIdentityProviderLink {
        /**
         * The protocol resource link.
         */
        protocols: string;
        /**
         * The identity provider resource link.
         */
        self: string;
    }

    export interface GetUsersUser {
        /**
         * Indicates the description of the IAM user.
         */
        description: string;
        /**
         * Specifies the status of the IAM user, the default value is **true**.
         */
        enabled: boolean;
        /**
         * Indicates the user groups to which an IAM user belongs.
         */
        groups: string[];
        /**
         * Indicates the ID of the User.
         */
        id: string;
        /**
         * Specifies the IAM user name.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * If this value is not set, the password will not expire.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
    }

    export interface GetVirtualMfaDevicesVirtualMfaDevice {
        /**
         * The virtual MFA device serial number.
         */
        serialNumber: string;
        /**
         * Specifies the user ID to which the virtual MFA device belongs.
         */
        userId: string;
    }

    export interface ProtectionPolicySelfManagement {
        /**
         * Specifies whether to allow IAM users to manage access keys by themselves.
         */
        accessKey?: boolean;
        /**
         * Specifies whether to allow IAM users to change their email addresses.
         */
        email?: boolean;
        /**
         * Specifies whether to allow IAM users to change their mobile numbers.
         */
        mobile?: boolean;
        /**
         * Specifies whether to allow IAM users to change their passwords.
         */
        password?: boolean;
    }

    export interface ProviderAccessConfig {
        /**
         * Specifies the access type of the identity provider.
         * Available options are:
         * + **program**: programmatic access only.
         * + **program_console**: programmatic access and management console access.
         */
        accessType: string;
        /**
         * Specifies the authorization endpoint of the OpenID Connect identity
         * provider. This field is required only if the access type is set to `programConsole`.
         */
        authorizationEndpoint: string;
        /**
         * Specifies the ID of a client registered with the OpenID Connect identity provider.
         */
        clientId: string;
        /**
         * Specifies the URL of the identity provider.
         * This field corresponds to the iss field in the ID token.
         */
        providerUrl: string;
        /**
         * Response mode.
         * Valid values is *form_post* and *fragment*, default value is *form_post*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseMode?: string;
        /**
         * Response type. Valid values is *id_token*, default value is *id_token*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseType?: string;
        /**
         * Specifies the scopes of authorization requests. It is an array of one or more scopes.
         * Valid values are *openid*, *email*, *profile* and other values defined by you.
         * This field is required only if the access type is set to `programConsole`.
         */
        scopes: string[];
        /**
         * Public key used to sign the ID token of the OpenID Connect identity provider.
         * This field is required only if the protocol is set to *oidc*.
         */
        signingKey: string;
    }

    export interface ProviderConversionConversionRule {
        /**
         * Specifies the federated user information on the cloud platform.
         */
        locals: outputs.Iam.ProviderConversionConversionRuleLocal[];
        /**
         * Specifies Federated user information in the IDP system.
         */
        remotes: outputs.Iam.ProviderConversionConversionRuleRemote[];
    }

    export interface ProviderConversionConversionRuleLocal {
        /**
         * Specifies the user group to which the federated user belongs on the cloud platform.
         */
        group?: string;
        /**
         * Specifies the name of a federated user on the cloud platform.
         */
        username?: string;
    }

    export interface ProviderConversionConversionRuleRemote {
        /**
         * Specifies the attribute in the IDP assertion.
         */
        attribute: string;
        /**
         * Specifies the condition of conversion rule.
         * Available options are:
         * + `anyOneOf`: The rule is matched only if the specified strings appear in the attribute type.
         * + `notAnyOf`: The rule is matched only if the specified strings do not appear in the attribute type.
         */
        condition?: string;
        /**
         * Specifies the rule is matched only if the specified strings appear in the attribute type.
         */
        values?: string[];
    }

    export interface ProviderConversionRule {
        /**
         * The federated user information on the cloud platform.
         */
        locals: outputs.Iam.ProviderConversionRuleLocal[];
        /**
         * The description of the identity provider.
         */
        remotes: outputs.Iam.ProviderConversionRuleRemote[];
    }

    export interface ProviderConversionRuleLocal {
        /**
         * The user group to which the federated user belongs on the cloud platform.
         */
        group: string;
        /**
         * The name of a federated user on the cloud platform.
         */
        username: string;
    }

    export interface ProviderConversionRuleRemote {
        /**
         * The attribute in the IDP assertion.
         */
        attribute: string;
        /**
         * The condition of conversion rule.
         */
        condition: string;
        /**
         * The rule is matched only if the specified strings appear in the attribute type.
         */
        values: string[];
    }
}

export namespace Iec {
    export interface GetBandwidthsBandwidth {
        /**
         * The charging mode of the bandwidth.
         */
        chargeMode: string;
        /**
         * The ID of the bandwidth.
         */
        id: string;
        /**
         * The line name of the bandwidth.
         */
        line: string;
        /**
         * The name of the bandwidth.
         */
        name: string;
        /**
         * Whether the bandwidth is shared or exclusive.
         */
        shareType: string;
        /**
         * The size of the bandwidth.
         */
        size: number;
        /**
         * The status of the bandwidth.
         */
        status: string;
    }

    export interface GetEipsEip {
        /**
         * The ID of bandwidth.
         */
        bandwidthId: string;
        /**
         * The name of bandwidth.
         */
        bandwidthName: string;
        /**
         * Whether the bandwidth is shared or exclusive.
         */
        bandwidthShareType: string;
        /**
         * The size of bandwidth.
         */
        bandwidthSize: number;
        /**
         * The ID of elastic IP.
         */
        id: string;
        /**
         * The version of elastic IP address.
         */
        ipVersion: number;
        /**
         * Specifies the ID of the port.
         */
        portId: string;
        /**
         * The address of private IP.
         */
        privateIp: string;
        /**
         * The address of elastic IP.
         */
        publicIp: string;
        /**
         * The status elastic IP.
         */
        status: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The id of the iec flavor.
         */
        id: string;
        /**
         * The memory of the iec flavor.
         */
        memory: number;
        /**
         * Specifies the flavor name, which can be queried with a regular expression.
         */
        name: string;
        /**
         * The vcpus of the iec flavor.
         */
        vcpus: number;
    }

    export interface GetImagesImage {
        /**
         * The id of the iec images.
         */
        id: string;
        /**
         * Specifies the image Name, which can be queried with a regular expression.
         */
        name: string;
        /**
         * Specifies the os type of the iec image.
         * "Linux", "Windows" and "Other" are supported.
         */
        osType: string;
        /**
         * The status of the iec images.
         */
        status: string;
    }

    export interface GetNetwork_aclNetwork {
        subnetId: string;
        vpcId: string;
    }

    export interface GetSecurityGroupSecurityGroupRule {
        /**
         * The description for the IEC security group rules.
         */
        description: string;
        /**
         * The direction of the IEC security group rules.
         */
        direction: string;
        /**
         * The layer 3 protocol type.
         */
        ethertype: string;
        /**
         * The ID of the IEC security group rules.
         */
        id: string;
        /**
         * The higher part of the allowed port range.
         */
        portRangeMax: number;
        /**
         * The lower part of the allowed port range.
         */
        portRangeMin: number;
        /**
         * The layer 4 protocol type.
         */
        protocol: string;
        /**
         * The remote group id of the IEC security group rules.
         */
        remoteGroupId: string;
        /**
         * The remote CIDR of the IEC security group rules.
         */
        remoteIpPrefix: string;
        /**
         * The id of the IEC security group rules.
         */
        securityGroupId: string;
    }

    export interface GetServerCoverageSite {
        /**
         * The operator of the IEC site.
         */
        operator: string;
        /**
         * The ID of IEC site.
         */
        siteId: string;
        /**
         * The located information of the IEC site. It contains area, province and city.
         */
        siteInfo: string;
    }

    export interface GetServerNic {
        /**
         * The IPv4 address of the server on that network.
         */
        address: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
    }

    export interface GetServerVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: string;
        /**
         * The device name in the IEC server.
         */
        device: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }

    export interface GetSitesSite {
        /**
         * Specifies the area of the IEC sites located.
         */
        area: string;
        /**
         * Specifies the city of the IEC sites located.
         */
        city: string;
        /**
         * The ID of the EIP line.
         */
        id: string;
        /**
         * An array of one or more EIP lines. The object structure is documented below.
         */
        lines: outputs.Iec.GetSitesSiteLine[];
        /**
         * The name of the EIP line.
         */
        name: string;
        /**
         * Specifies the province of the IEC sites located.
         */
        province: string;
        /**
         * The status of the IEC service site.
         */
        status: string;
    }

    export interface GetSitesSiteLine {
        /**
         * The ID of the EIP line.
         */
        id: string;
        /**
         * The supported IP version.
         */
        ipVersion: string;
        /**
         * The name of the EIP line.
         */
        name: string;
        /**
         * The operator information of the EIP line.
         */
        operator: string;
    }

    export interface GetVpcSubnetsSubnet {
        /**
         * Indicates the cidr block of the subnet.
         */
        cidr: string;
        /**
         * Indicates the DNS server address list of the subnet.
         */
        dnsLists: string[];
        /**
         * Indicates the gateway of the subnet.
         */
        gatewayIp: string;
        /**
         * Indicates the ID of the subnet.
         */
        id: string;
        /**
         * Indicates the name of the subnet.
         */
        name: string;
        /**
         * Specifies the ID of the IEC site.
         */
        siteId: string;
        /**
         * Indicates the located information of the iec site. It contains area, province and city.
         */
        siteInfo: string;
        /**
         * Indicates the status of the subnet.
         */
        status: string;
    }

    export interface NetworkAclNetwork {
        /**
         * Specifies the id of the iec subnet.
         */
        subnetId: string;
        /**
         * Specifies the id of the iec vpc.
         */
        vpcId: string;
    }

    export interface SecurityGroupSecurityGroupRule {
        /**
         * Specifies the description of the iec security group. description must be
         * 0 to 64 characters in length, and does not contain angle brackets (<) and (>). Changing this parameter will creates a
         * new iec security group resource.
         */
        description: string;
        /**
         * The direction of the iec security group rules.
         */
        direction: string;
        /**
         * The layer 3 protocol type.
         */
        ethertype: string;
        /**
         * The id of the iec security group rules.
         */
        id: string;
        /**
         * The higher part of the allowed port range.
         */
        portRangeMax: number;
        /**
         * The lower part of the allowed port range.
         */
        portRangeMin: number;
        /**
         * The layer 4 protocol type.
         */
        protocol: string;
        /**
         * The remote group id of the iec security group rules.
         */
        remoteGroupId: string;
        /**
         * The remote CIDR of the iec security group rules.
         */
        remoteIpPrefix: string;
        /**
         * The id of the iec security group rules.
         */
        securityGroupId: string;
    }

    export interface ServerCoverageSite {
        /**
         * Specifies the operator of the IEC site.
         */
        operator: string;
        /**
         * Specifies the ID of IEC site.
         */
        siteId: string;
    }

    export interface ServerDataDisk {
        /**
         * Specifies the size of data disk for the IEC server binding. The value range is
         * 10 to 500 in GB. Changing this parameter creates a new IEC server resource.
         */
        size: number;
        /**
         * Specifies the type of data disk for the IEC server binding. Valid value is
         * *SAS*(high I/O disk type). Changing this parameter creates a new IEC server resource.
         */
        type: string;
    }

    export interface ServerNic {
        /**
         * The IPv4 address of the server on that network.
         */
        address: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
    }

    export interface ServerVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: string;
        /**
         * The device name in the IEC server.
         */
        device: string;
        /**
         * Specifies the size of data disk for the IEC server binding. The value range is
         * 10 to 500 in GB. Changing this parameter creates a new IEC server resource.
         */
        size: number;
        /**
         * Specifies the type of data disk for the IEC server binding. Valid value is
         * *SAS*(high I/O disk type). Changing this parameter creates a new IEC server resource.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }
}

export namespace IoTDA {
    export interface DataforwardingRuleTarget {
        /**
         * Specifies the detail of AMQP forwards. It is required when type
         * is `AMQP_FORWARDING`. The amqpForwarding structure is documented below.
         */
        amqpForwarding: outputs.IoTDA.DataforwardingRuleTargetAmqpForwarding;
        /**
         * Specifies the detail of the DIS forwards. It is required when type
         * is `DIS_FORWARDING`. The disForwarding structure is documented below.
         */
        disForwarding: outputs.IoTDA.DataforwardingRuleTargetDisForwarding;
        /**
         * Specifies the detail of the FunctionGraph forwards. It is required when
         * type is **FUNCTIONGRAPH_FORWARDING**. The fgsForwarding structure is documented below.
         */
        fgsForwarding: outputs.IoTDA.DataforwardingRuleTargetFgsForwarding;
        /**
         * Specifies the detail of the HTTP forwards. It is required when type
         * is `HTTP_FORWARDING`. The httpForwarding structure is documented below.
         */
        httpForwarding: outputs.IoTDA.DataforwardingRuleTargetHttpForwarding;
        /**
         * The resource ID in UUID format.
         */
        id: string;
        /**
         * Specifies the detail of the KAFKA forwards. It is required when type
         * is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
         */
        kafkaForwarding: outputs.IoTDA.DataforwardingRuleTargetKafkaForwarding;
        /**
         * Specifies the detail of the OBS forwards. It is required when type
         * is `OBS_FORWARDING`. The obsForwarding structure is documented below.
         */
        obsForwarding: outputs.IoTDA.DataforwardingRuleTargetObsForwarding;
        /**
         * Specifies the type of forwarding target. The options are as follows:
         * + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
         * You can set different addresses that different types of device data are pushed to.
         * + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
         * provides an abundant selection of APIs to help you quickly create real-time data applications.
         * + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
         * It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
         * data from anywhere.
         * + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
         * latency. AMQP is ready from the get-go and is O&M free.
         * + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
         * scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
         * and traffic balancing.
         * + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
         * function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
         * servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
         * Currently, only standard and enterprise edition IoTDA instances are supported.
         */
        type: string;
    }

    export interface DataforwardingRuleTargetAmqpForwarding {
        /**
         * Specifies the AMQP Queue name.
         */
        queueName: string;
    }

    export interface DataforwardingRuleTargetDisForwarding {
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
        /**
         * Specifies the DIS stream ID.
         */
        streamId: string;
    }

    export interface DataforwardingRuleTargetFgsForwarding {
        /**
         * Specifies the function name.
         */
        funcName: string;
        /**
         * Specifies the function URN.
         */
        funcUrn: string;
    }

    export interface DataforwardingRuleTargetHttpForwarding {
        /**
         * Specifies the Push URL. The request method must is post.
         */
        url: string;
    }

    export interface DataforwardingRuleTargetKafkaForwarding {
        /**
         * Specifies the list of the connected service addresses.
         * The addresses structure is documented below.
         */
        addresses: outputs.IoTDA.DataforwardingRuleTargetKafkaForwardingAddress[];
        /**
         * Specifies the password.
         */
        password?: string;
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
        /**
         * Specifies the topic.
         */
        topic: string;
        /**
         * Specifies the SASL user name.
         */
        userName?: string;
    }

    export interface DataforwardingRuleTargetKafkaForwardingAddress {
        /**
         * Specifies the domain of the connected service address.
         * Exactly one of `ip` or `domain` must be provided.
         */
        domain?: string;
        /**
         * Specifies the IP of the connected service address.
         * Exactly one of `ip` or `domain` must be provided.
         */
        ip?: string;
        /**
         * Specifies the port of the connected service address.
         */
        port: number;
    }

    export interface DataforwardingRuleTargetObsForwarding {
        /**
         * Specifies the OBS Bucket.
         */
        bucket: string;
        /**
         * Specifies the custom directory for storing channel files. The ID contains a
         * maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
         * and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
         * and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
         * directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
         * time(for example, 2022/06/14/10) when data is forwarded.
         */
        customDirectory: string;
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
    }

    export interface DeviceLinkageRuleAction {
        /**
         * Specifies the detail of device alarm. It is required when type
         * is `DEVICE_ALARM`. The deviceAlarm structure is documented below.
         */
        deviceAlarm: outputs.IoTDA.DeviceLinkageRuleActionDeviceAlarm;
        /**
         * Specifies the detail of device command. It is required when type
         * is `DEVICE_CMD`. The deviceCommand structure is documented below.
         */
        deviceCommand: outputs.IoTDA.DeviceLinkageRuleActionDeviceCommand;
        /**
         * Specifies the detail of SMN notifications. It is required when type
         * is `SMN_FORWARDING`. The smnForwarding structure is documented below.
         */
        smnForwarding: outputs.IoTDA.DeviceLinkageRuleActionSmnForwarding;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleActionDeviceAlarm {
        /**
         * Specifies the description of the alarm.  
         * The value can contain a maximum of `256` characters.
         */
        description?: string;
        /**
         * Specifies the dimension of the alarm. Combine the alarm name and alarm level to
         * jointly identify an alarm.
         * The valid values are as follows:
         * + **device**: Device dimension
         * + **app**: Resource space dimension.
         */
        dimension?: string;
        /**
         * Specifies the name of the alarm.
         */
        name: string;
        /**
         * Specifies the severity level of the alarm.
         * The valid values are **warning**, **minor**, **major** and **critical**.
         */
        severity: string;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleActionDeviceCommand {
        /**
         * Specifies the cache time of device commands, in seconds. Representing the effective
         * time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
         * longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
         * issued to the device regardless of the command issuance mode set on the IoT platform.
         */
        bufferTimeout?: number;
        /**
         * Specifies the command parameters, in json format.
         * + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
         * parameter name of the command in the product model.
         * + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
         * "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
         * - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
         * The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
         * `NOACK` indicates that the confirmation message does not need to be replied.
         * - **from**: Optional, the address of the command sender.
         * When the App initiates a request, the format is /users/{userId},
         * when the application server initiates a request, the format is /{serviceName},
         * and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
         * - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
         * - **method**: optional, the command name defined in the product model.
         * - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
         * name of the command in the product model. The specific format requires application and device conventions.
         */
        commandBody: string;
        /**
         * Specifies the command name.
         */
        commandName: string;
        /**
         * Specifies the device id which executes the command.
         */
        deviceId: string;
        /**
         * Specifies the issuance mode of device commands, which is only valid when the value of
         * `bufferTimeout` is greater than `0`.
         * The valid values are as follows:
         * + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
         * + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
         * Wait until the device goes online again or reports the execution result of the previous command before issuing the
         * command.
         */
        mode?: string;
        /**
         * Specifies the effective time of the command response, in seconds. Indicating that
         * the device responds effectively within the `responseTimeout` time after receiving the command. If no response is
         * received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
         */
        responseTimeout?: number;
        /**
         * Specifies the service id to which the command belongs.
         */
        serviceId: string;
    }

    export interface DeviceLinkageRuleActionSmnForwarding {
        /**
         * Specifies the message content.
         */
        messageContent: string;
        /**
         * Specifies the template name corresponding to the SMN service.
         */
        messageTemplateName: string;
        /**
         * Specifies the message title.
         */
        messageTitle: string;
        /**
         * Specifies the project ID to which the SMN belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the SMN belongs.
         */
        region: string;
        /**
         * Specifies the topic name of the SMN.
         */
        topicName: string;
        /**
         * Specifies the topic URN of the SMN.
         */
        topicUrn: string;
    }

    export interface DeviceLinkageRuleEffectivePeriod {
        /**
         * Specifies a list of days of week, separated by commas. 1 represents Sunday,
         * 2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
         */
        daysOfWeek: string;
        /**
         * Specifies the end time, in the format: `HH:mm`.
         * For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
         */
        endTime: string;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface DeviceLinkageRuleTrigger {
        /**
         * Specifies the condition triggered at specified time every day. It is
         * required when `type` is **DAILY_TIMER**.
         * The dailyTimerCondition structure is documented below.
         */
        dailyTimerCondition: outputs.IoTDA.DeviceLinkageRuleTriggerDailyTimerCondition;
        /**
         * Specifies the condition triggered upon the property of device. It is
         * required when `type` is **DEVICE_DATA**.
         * The deviceDataCondition structure is documented below.
         */
        deviceDataCondition: outputs.IoTDA.DeviceLinkageRuleTriggerDeviceDataCondition;
        /**
         * Specifies the condition triggered by device status. It is
         * required when `type` is **DEVICE_LINKAGE_STATUS**.
         * The deviceLinkageStatusCondition structure is documented below.
         */
        deviceLinkageStatusCondition: outputs.IoTDA.DeviceLinkageRuleTriggerDeviceLinkageStatusCondition;
        /**
         * Specifies the condition triggered by policy. It is required when `type`
         * is **SIMPLE_TIMER**.
         * The simpleTimerCondition structure is documented below.
         */
        simpleTimerCondition: outputs.IoTDA.DeviceLinkageRuleTriggerSimpleTimerCondition;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleTriggerDailyTimerCondition {
        /**
         * Specifies a list of days of week, separated by commas. 1 represents Sunday,
         * 2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
         */
        daysOfWeek: string;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface DeviceLinkageRuleTriggerDeviceDataCondition {
        /**
         * Specifies data validity period, Unit is `seconds`. Defaults to `300`.
         * For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
         * the data at 20:00, the action is not triggered regardless of whether the conditions are met.
         */
        dataValidatiyPeriod?: number;
        /**
         * Specifies the device id which executes the command.
         */
        deviceId?: string;
        /**
         * Specifies the Rvalue of a data comparison expression. Only when the `operator` is
         * **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
         * values, e.g. **20,30,40**,
         */
        inValues?: string[];
        /**
         * Specifies the data comparison operator. The valid values are: **>**, **<**,
         * **>=**, **<=**, **=**, **in** and **between**.
         */
        operator: string;
        /**
         * Specifies the path of the device property, in the format: **service_id/DataProperty**.
         */
        path: string;
        /**
         * Specifies the product ID. If this field is set and the `deviceId` is empty, the
         * device attribute will trigger the matching of all devices under this product.
         */
        productId?: string;
        /**
         * Specifies the trigger strategy. The options are as follows:
         * + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
         * + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
         * is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
         * again each time the battery drops to a lower level.
         */
        triggerStrategy: string;
        /**
         * Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
         * the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
         * which means greater than or equal to `20` and less than `30`.
         */
        value?: string;
    }

    export interface DeviceLinkageRuleTriggerDeviceLinkageStatusCondition {
        /**
         * Specifies the device id which executes the command.
         */
        deviceId: string;
        /**
         * Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.
         */
        duration: number;
        /**
         * Specifies the product ID. If this field is set and the `deviceId` is empty, the
         * device attribute will trigger the matching of all devices under this product.
         */
        productId?: string;
        /**
         * Specifies device status list, separate multiple status with commas.
         * e.g. **ONLINE**, **OFFLINE**.
         * The valid device status values are as follows:
         * + **ONLINE**: Device online.
         * + **OFFLINE**: Device offline.
         */
        statusLists: string[];
    }

    export interface DeviceLinkageRuleTriggerSimpleTimerCondition {
        /**
         * Specifies total number of repetition.
         */
        repeatCount: number;
        /**
         * Specifies the interval of repetition, Unit is `minutes`.
         */
        repeatInterval: number;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface DeviceShadow {
        /**
         * Specifies the initial properties data of the device.
         * The each key is a parameter name of a property in the product model.
         * If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
         */
        desired: {[key: string]: string};
        /**
         * Specifies the service ID of the device.
         * Which is defined in the product model associated with the device.
         */
        serviceId: string;
    }

    export interface ProductService {
        /**
         * Specifies the list of commands for the service.
         * The commands structure is documented below.
         */
        commands: outputs.IoTDA.ProductServiceCommand[];
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        /**
         * Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
         * Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
         */
        id: string;
        /**
         * Specifies whether the device service is mandatory.
         * Currently, this field is not a functional field and is used only for identification.
         * The valid values are as follows:
         * + **Master**: The master service.
         * + **Mandatory**: The mandatory service.
         * + **Optional**:  The optional service.
         */
        option: string;
        /**
         * Specifies the list of properties for the service.
         * The properties structure is documented below.
         */
        properties: outputs.IoTDA.ProductServiceProperty[];
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
    }

    export interface ProductServiceCommand {
        /**
         * Specifies the name of the parameter. The name contains a maximum of `64` characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the list of parameters for the command.
         * The paras structure is documented below.
         */
        paras: outputs.IoTDA.ProductServiceCommandPara[];
        /**
         * Specifies the list of responses for the command.
         * The responses structure is documented below.
         */
        responses: outputs.IoTDA.ProductServiceCommandResponse[];
    }

    export interface ProductServiceCommandPara {
        /**
         * Specifies the default value of the device property.
         * This parameter allowed value is a JSON string. e.g. **{\"foo\":\"bar\"}**
         * If this parameter is set value, the value will be written to the desired data of the device shadow when
         * the product is used to create a device. When the device goes online, the value will be delivered to the device.
         */
        defaultValue: string;
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        /**
         * Specifies the list of enumerated values of the parameter.
         */
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        maxLength: number;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of `64` characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the parameter is mandatory or not.
         * The default value is **false**.
         */
        required?: boolean;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

    export interface ProductServiceCommandResponse {
        /**
         * Specifies the default value of the device property.
         * This parameter allowed value is a JSON string. e.g. **{\"foo\":\"bar\"}**
         * If this parameter is set value, the value will be written to the desired data of the device shadow when
         * the product is used to create a device. When the device goes online, the value will be delivered to the device.
         */
        defaultValue: string;
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        /**
         * Specifies the list of enumerated values of the parameter.
         */
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        maxLength: number;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of `64` characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the parameter is mandatory or not.
         * The default value is **false**.
         */
        required?: boolean;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

    export interface ProductServiceProperty {
        /**
         * Specifies the default value of the device property.
         * This parameter allowed value is a JSON string. e.g. **{\"foo\":\"bar\"}**
         * If this parameter is set value, the value will be written to the desired data of the device shadow when
         * the product is used to create a device. When the device goes online, the value will be delivered to the device.
         */
        defaultValue: string;
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        /**
         * Specifies the list of enumerated values of the parameter.
         */
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        maxLength: number;
        /**
         * Specifies the access mode of the device property.
         * The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
         * **W** (the property value can be written) or **E** (the property value can be subscribed to).
         */
        method: string;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of `64` characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the parameter is mandatory or not.
         * The default value is **false**.
         */
        required?: boolean;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

}

export namespace Live {
    export interface RecordingFlv {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
    }

    export interface RecordingHls {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the TS slice duration for HLS recording.
         * Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
         */
        recordSliceDuration: number;
        /**
         * Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
        /**
         * Specifies TS file name prefix.
         * The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
         */
        tsFileNaming: string;
    }

    export interface RecordingMp4 {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
    }

    export interface RecordingObs {
        /**
         * Specifies OBS bucket.
         */
        bucket: string;
        /**
         * Specifies OBS object path. If omitted, recordings will be saved to the root directory.
         */
        object: string;
        /**
         * Specifies the region of OBS.
         */
        region: string;
    }

    export interface TranscodingTemplate {
        /**
         * Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
         */
        bitrate: number;
        /**
         * Specifies the adaptive bitrate.
         * The valid values are as follows:
         * + **off**: Disable rate adaptation and output the target rate according to the set rate.
         * + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
         * + **adaptive**: Adaptive output of target bitrate based on source file bitrate.
         */
        bitrateAdaptive: string;
        /**
         * Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
         * Value `0` indicates that the frame rate remains unchanged.
         */
        frameRate: number;
        /**
         * Specifies the interval time for I-frames, in seconds.
         * The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.
         */
        gop: string;
        /**
         * Specifies video height (unit: pixel).
         * + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
         * + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
         */
        height: number;
        /**
         * Specifies the maximum I-frame interval in frames.
         * The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.
         */
        iFrameInterval: string;
        /**
         * Specifies the encoding output I-frame strategy.
         * The valid values are as follows:
         * + **auto**: I-frame output according to the set `gop` duration.
         * + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
         * invalid after setting this value.
         */
        iFramePolicy: string;
        /**
         * Specifies the template name. The name can contain a maximum of 64 characters, and only
         * contains letters, digits and hyphens (-).
         */
        name: string;
        /**
         * Specifies the protocol type supported for transcoding output.
         * The valid value is **RTMP**. Defaults to **RTMP**.
         */
        protocol: string;
        /**
         * Specifies video width (unit: pixel).
         * + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
         * + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
         */
        width: number;
    }

}

export namespace Meeting {
    export interface ConferenceConfiguration {
        /**
         * Specifies whether to allow guests to start conferences (only valid for random
         * ID conferences).
         */
        allowGuestStart: boolean;
        /**
         * Specifies the range to allow incoming calls.
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         * + **3**: The invited user.
         */
        callinRestriction: number;
        /**
         * Specifies the guest password (pure number which is `4` to `16` digits long).
         */
        guestPassword: string;
        /**
         * Specifies whether the soft terminal is automatically muted when the guest joins the
         * conference.
         */
        isAutoMute: boolean;
        /**
         * Specifies whether the guest is password-free (only valid for random
         * conferences).
         */
        isGuestFreePassword: boolean;
        /**
         * Specifies whether the guest joins the conference, whether the hard
         * terminal is automatically muted.
         */
        isHardTerminalAutoMute: boolean;
        /**
         * Specifies whether to send conference calendar notifications.
         */
        isSendCalendar: boolean;
        /**
         * Specifies whether to send conference email notification.
         */
        isSendNotify: boolean;
        /**
         * Specifies whether to send conference SMS notification.
         */
        isSendSms: boolean;
        /**
         * Specifies the Automatically extend duration, the valid value is range from `0` to
         * `60`.
         */
        prolongTime: number;
        /**
         * Specifies whether to open the waiting room (only valid for RTC enterprises).
         */
        waitingRoomEnabled: boolean;
    }

    export interface ConferenceCycleParams {
        /**
         * Specifies the period type. The valid values are as follows:
         * + **Day**
         * + **Week**
         * + **Month**
         */
        cycle: string;
        /**
         * Specifies the end date of the recurring conference.
         * The format is `YYYY-MM-DD`.
         */
        endDate: string;
        /**
         * Specifies the cycle interval.
         * For different `cycle` types, the value range of interval are as follows:
         * + **Day**: Means that it will be held every few days, and the valid value is range from `1` to `15`.
         * + **Week**: Means that it is held every few weeks, and the valid value is range from `1` to `5`.
         * + **Month**: Means every few months, the value range is `1` to `3`.
         */
        interval: number;
        /**
         * Specifies the conference point in the cycle. Only valid by **Week** and **Month**.
         * For different `cycle` types, the value range of elements are as follows:
         * + **Week**: The valid value is range from `0` to `6`. The `0` means Sunday, `6` means Saturday.
         * + **Month**: The valid range for the elements is `1` to `31`. If the value does not exist in the current month, the
         * value means the end of the month.
         */
        points: number[];
        /**
         * Specifies the number of days for advance conference notice.
         * The valid value is range from `0` to `30`, defaults to `1`.
         */
        preRemind: number;
        /**
         * Specifies the start date of the recurring conference.
         * The format is `YYYY-MM-DD`.
         */
        startDate: string;
    }

    export interface ConferenceJoinPassword {
        /**
         * The password of the common participant.
         */
        guest: string;
        /**
         * The password of the meeting host.
         */
        host: string;
    }

    export interface ConferenceParticipant {
        /**
         * Specifies the account ID of the participant.
         */
        accountId: string;
        /**
         * Specifies the email address.
         */
        email: string;
        /**
         * Specifies whether to automatically invite this participant when the conference
         * starts. The valid values are as follows:
         * + **0**: Do not automatically invite.
         * + **1**: Automatic invitation.
         */
        isAutoInvite: number;
        /**
         * Specifies whether the user needs to be automatically muted when joining the conference
         * (only effective when invited in the conference). The valid values are as follows:
         * + **0**: No mute.
         * + **1**: Mute.
         */
        isMute: number;
        /**
         * Specifies the attendee name or nickname.  
         * The valid length is limited from `1` to `96`.
         */
        name: string;
        /**
         * Specifies the SIP or TEL number, maximum of 127 characters.
         */
        phone: string;
        /**
         * Specifies the role in the conference. The valid values are as follows:
         * + **0**: Normal attendee.
         * + **1**: The conference chair.
         */
        role: number;
        /**
         * Specifies the mobile number for SMS notification, maximum of 32 characters.
         */
        sms: string;
        /**
         * Specifies the call-in type. The valid values are as follows:
         * + **normal**: The soft terminal.
         * + **terminal**: The conference room or hard terminal.
         * + **outside**: The outside participant.
         * + **mobile**: The user's landline phone.
         * + **ideahub**: The ideahub.
         */
        type: string;
        /**
         * Specifies the user ID of the participant.
         */
        userId: string;
    }

    export interface ConferenceSubconference {
        /**
         * The sub-conference end time.
         */
        endTime: string;
        /**
         * The sub-conference ID.
         */
        id: string;
        /**
         * Specifies whether the conference automatically starts recording, it only takes
         * effect when the recording type is:
         * + **1**: Automatically start recording.
         * + **0**: Do not start recording automatically.
         */
        isAutoRecord: number;
        /**
         * Specifies the conference media type list.
         * It consists of one or more enumerations, and the valid values are as follows:
         * + **Voice**: Voice.
         * + **Video**: SD video.
         * + **HDVideo**: High-definition video (mutually exclusive with Video, if Video and HDVideo are selected at the same
         * time, the system will select Video by default).
         * + **Data**: Multimedia (If omitted, the system configuration will determines whether to automatically add **Data**).
         */
        mediaTypes: string[];
        /**
         * Specifies the recording authentication method.
         * + **0**: Viewable/downloadable via link.
         * + **1**: Enterprise users can watch/download.
         * + **2**: Attendees can watch/download.
         */
        recordAuthType: number;
        /**
         * Specifies the conference start time (UTC time).
         * The time format is `YYYY-MM-DD hh:mm`, e.g. `2006-01-02 15:04`.
         * There is no need to set if you book a cyclical conference.
         */
        startTime: string;
        /**
         * The other configuration information of periodic subconferences.
         * The object structure is documented below.
         */
        subconfigurations: outputs.Meeting.ConferenceSubconferenceSubconfiguration[];
    }

    export interface ConferenceSubconferenceSubconfiguration {
        /**
         * Specifies whether to allow guests to start conferences (only valid for random
         * ID conferences).
         */
        allowGuestStart: boolean;
        /**
         * The range that the webinar audience is allowed to call in.
         * The valid values are as follows:
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         */
        audienceCallinRestriction: number;
        /**
         * Specifies the range to allow incoming calls.
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         * + **3**: The invited user.
         */
        callinRestriction: number;
        /**
         * The webinar Audience Display Strategy.
         * The object structure is documented below.
         */
        showAudiencePolicies: outputs.Meeting.ConferenceSubconferenceSubconfigurationShowAudiencePolicy[];
        /**
         * Specifies whether to open the waiting room (only valid for RTC enterprises).
         */
        waitingRoomEnabled: boolean;
    }

    export interface ConferenceSubconferenceSubconfigurationShowAudiencePolicy {
        /**
         * Specifies the basic number of people, the valid values is range from `0` to `10,000`.
         */
        baseAudienceCount: number;
        /**
         * Audience display strategy: The server is used to calculate the number of audiences and send it to the client
         * to control the audience display.
         * + **0**: Do not display.
         * + **1**: Multiply display the number of participants, based on the real-time number of participants or the cumulative
         * number of participants, the multiplication setting can be performed.
         */
        mode: number;
        /**
         * Specifies the multiplier. The valid values is range from `0` to `10`, it can be set to 1 decimal place.
         */
        multiple: number;
    }

}

export namespace ModelArts {
    export interface DatasetDataSource {
        /**
         * Specifies the cluster ID of DWS/MRS when `dataType` is `1` or `4`.
         * Changing this parameter will create a new resource.
         */
        clusterId?: string;
        /**
         * Specifies the type of data source. The options are as follows:
         * + **0**: OBS.
         * + **1**: GaussDB(DWS).
         * + **2**: DLI.
         * + **4**: MRS.
         */
        dataType?: number;
        /**
         * Specifies the database name of DWS/DLI when `dataType` is `1` or `2`.
         * Changing this parameter will create a new resource.
         */
        databaseName?: string;
        /**
         * Specifies the password of database when `dataType` is `1`.
         * Changing this parameter will create a new resource.
         */
        password?: string;
        /**
         * Specifies the OBS path when `dataType` is `0`
         * or the hdsf path when `dataType` is `4`. All the file in this directory and subdirectories will be which be imported
         * to the dataset. Changing this parameter will create a new resource.
         */
        path?: string;
        /**
         * Specifies the queue name of DLI when `dataType` is `2`.
         * Changing this parameter will create a new resource.
         */
        queueName?: string;
        /**
         * Specifies the table name of DWS/DLI when `dataType` is `1` or `2`.
         * Changing this parameter will create a new resource.
         */
        tableName?: string;
        /**
         * Specifies the user name of database when `dataType` is `1`.
         * Changing this parameter will create a new resource.
         */
        userName?: string;
        /**
         * Specifies whether the data contains table header when the type
         * of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
         */
        withColumnHeader?: boolean;
    }

    export interface DatasetLabel {
        /**
         * Specifies the name of label.
         */
        name: string;
        /**
         * Specifies color of label.
         */
        propertyColor: string;
        /**
         * Specifies shape of label. Valid values include: `bndbox`, `polygon`,
         * `circle`, `line`, `dashed`, `point`, `polyline`.
         */
        propertyShape: string;
        /**
         * Specifies shortcut of label.
         */
        propertyShortcut: string;
    }

    export interface DatasetLabelFormat {
        /**
         * Specifies the separator between label and label.
         * Changing this parameter will create a new resource.
         */
        labelSeparator?: string;
        /**
         * Specifies the separator between text and label.
         * Changing this parameter will create a new resource.
         */
        textLabelSeparator?: string;
        /**
         * Specifies Label type for text classification.
         * The optional values are as follows:
         */
        type?: string;
    }

    export interface DatasetSchema {
        /**
         * Specifies the name of label.
         */
        name: string;
        /**
         * Specifies Label type for text classification.
         * The optional values are as follows:
         */
        type: string;
    }

    export interface GetDataset_versionsVersion {
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * The description of the dataset version.
         */
        description: string;
        /**
         * The total number of samples.
         */
        files: number;
        /**
         * The ID of the dataset version.
         */
        id: string;
        /**
         * Whether this version is current version.
         */
        isCurrent: boolean;
        /**
         * Specifies the name of the dataset version.
         */
        name: string;
        /**
         * Specifies the range of splitting ratio which randomly divides a labeled sample
         * into a training set and a validation set. Separate the minimum and maximum split ratios with commas,
         * for example: "0.0,1.0".
         */
        splitRatio: string;
        /**
         * Dataset version status. Valid values are as follows:
         * + **0**: Creating.
         * + **1**: Normal.
         * + **2**: Deleting.
         * + **3**: Deleted.
         * + **4**: Exception.
         */
        status: number;
        /**
         * The path to save the manifest file of the version.
         */
        storagePath: string;
        /**
         * The last update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetDatasetsDataset {
        /**
         * The dataset creation time.
         */
        createdAt: string;
        /**
         * The dataset format. Valid values include: `Default`, `CarbonData`: Carbon format(Supported only for
         * table type dataset.).
         */
        dataFormat: string;
        /**
         * The data sources which is used to imported the source data (such as pictures/files/audio, etc.) in
         * this directory and subdirectories to the dataset. Structure is documented below.
         */
        dataSources: outputs.ModelArts.GetDatasetsDatasetDataSource[];
        /**
         * The description of the dataset.
         */
        description: string;
        /**
         * The ID of the dataset.
         */
        id: string;
        /**
         * The labels information. Structure is documented below.
         */
        labels: outputs.ModelArts.GetDatasetsDatasetLabel[];
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * The OBS path for storing output files such as labeled files.
         */
        outputPath: string;
        /**
         * The schema information of source data when `type` is `400`(Table Type). Structure is documented below.
         */
        schemas: outputs.ModelArts.GetDatasetsDatasetSchema[];
        /**
         * Dataset status. Valid values are as follows:
         * + **0**: Creating.
         * + **1**: Completed.
         * + **2**: Deleting.
         * + **3**: Deleted.
         * + **4**: Exception.
         * + **5**: Syncing.
         * + **6**: Releasing.
         * + **7**: Version switching.
         * + **8**: Importing.
         */
        status: number;
        /**
         * Specifies the type of datasets. The options are:
         * + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **100**: Text classification, supported formats: `.txt`, `.csv`.
         * + **200**: Sound classification, Supported formats: `.wav`.
         * + **400**: Table type, supported formats: Carbon type.
         * + **600**: Video, supported formats: `.mp4`
         * + **900**: Free format.
         */
        type: number;
    }

    export interface GetDatasetsDatasetDataSource {
        /**
         * The type of data source. Valid values are as follows:
         * + *0*: OBS.
         * + *1*: GaussDB(DWS).
         * + *2*: DLI.
         * + *4*: MRS.
         */
        dataType: number;
        /**
         * The OBS path when `dataType` is `0`(OBS) or the HDFS path when `dataType` is `4`(MRS). All the file in this
         * directory and subdirectories will be which be imported to the dataset.
         */
        path: string;
        /**
         * Whether the data contains table header when the type of dataset is `400`(Table type).
         */
        withColumnHeader: boolean;
    }

    export interface GetDatasetsDatasetLabel {
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * The color of label.
         */
        propertyColor: string;
        /**
         * The shape of label. Valid values include: `bndbox`, `polygon`, `circle`, `line`, `dashed`,
         * `point`, `polyline`.
         */
        propertyShape: string;
        /**
         * The shortcut of label.
         */
        propertyShortcut: string;
    }

    export interface GetDatasetsDatasetSchema {
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * Specifies the type of datasets. The options are:
         * + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **100**: Text classification, supported formats: `.txt`, `.csv`.
         * + **200**: Sound classification, Supported formats: `.wav`.
         * + **400**: Table type, supported formats: Carbon type.
         * + **600**: Video, supported formats: `.mp4`
         * + **900**: Free format.
         */
        type: string;
    }

    export interface GetNotebookImagesImage {
        /**
         * Specifies the CPU architecture of image. The value can be **x86_64** and **aarch64**.
         */
        cpuArch: string;
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The ID of the image.
         */
        id: string;
        /**
         * Specifies the name of image.
         */
        name: string;
        /**
         * The path the image in HuaweiCloud SWR service (SoftWare Repository for Container).
         */
        swrPath: string;
        /**
         * Specifies the type of image. The options are:
         * + `BUILD_IN`: The system built-in image.
         * + `DEDICATED`: User-saved images.
         */
        type: string;
    }

    export interface NotebookMountStorage {
        /**
         * Specifies the ID of dedicated storage disk, which is mandatory when the `type`
         * is `EFS` and the `ownership` is `DEDICATED`.
         * Changing this parameter will create a new resource.
         */
        id: string;
        /**
         * The local mount path.
         */
        mountPath: string;
        /**
         * The path of storage which be mounted.
         */
        path: string;
        /**
         * The status of mount.
         */
        status: string;
        /**
         * Specifies the volume type. The options are as follows:
         * - *EFS*: use Scalable File Service, default 50GB is **free**.
         * - *EVS*: use Elastic Volume Service, default size is 5 GB.
         */
        type: string;
    }

    export interface NotebookVolume {
        /**
         * Specifies the ID of dedicated storage disk, which is mandatory when the `type`
         * is `EFS` and the `ownership` is `DEDICATED`.
         * Changing this parameter will create a new resource.
         */
        id?: string;
        /**
         * The local mount path.
         */
        mountPath: string;
        /**
         * Specifies the volume ownership. The options are as follows:
         * - *MANAGED*: shared storage disk of the ModelArts service.
         * - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.
         */
        ownership?: string;
        /**
         * Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
         */
        size: number;
        /**
         * Specifies the volume type. The options are as follows:
         * - *EFS*: use Scalable File Service, default 50GB is **free**.
         * - *EVS*: use Elastic Volume Service, default size is 5 GB.
         */
        type: string;
        /**
         * Specifies the URL of dedicated storage disk, which is mandatory when the `type`
         * is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
         * Changing this parameter will create a new resource.
         */
        uri?: string;
    }
}

export namespace Mpc {
    export interface TranscodingTemplateAudio {
        /**
         * Specifies the average output bitrate.  
         * The value is 0 or an integer ranging from `40` to `30,000`. The default value is `0`. The unit is kbit/s.
         * If this parameter is set to `0`, the average output bitrate is an adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the number of audio channels. Possible values are:
         * + **1**: AUDIO_CHANNELS_1
         * + **2**: AUDIO_CHANNELS_2
         * + **6**: AUDIO_CHANNELS_5_1
         */
        channels: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the audio sampling rate. Possible values are:
         * + **1**: AUDIO_SAMPLE_AUTO
         * + **2**: AUDIO_SAMPLE_22050 (22,050 Hz)
         * + **3**: AUDIO_SAMPLE_32000 (32,000 Hz)
         * + **4**: AUDIO_SAMPLE_44100 (44,100 Hz)
         * + **5**: AUDIO_SAMPLE_48000 (48,000 Hz)
         * + **6**: AUDIO_SAMPLE_96000 (96,000 Hz)
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupAudio {
        /**
         * Specifies the average output bitrate.  
         * The value is `0` or an integer ranging from `40` to `30,000`. The default value is `0`. The unit is kbit/s.
         * If this parameter is set to `0`, the average output bitrate is an adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the number of audio channels. Possible values are:
         * + **1**: AUDIO_CHANNELS_1
         * + **2**: AUDIO_CHANNELS_2
         * + **6**: AUDIO_CHANNELS_5_1
         */
        channels: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the audio sampling rate. Possible values are:
         * + **1**: AUDIO_SAMPLE_AUTO
         * + **2**: AUDIO_SAMPLE_22050 (22,050 Hz)
         * + **3**: AUDIO_SAMPLE_32000 (32,000 Hz)
         * + **4**: AUDIO_SAMPLE_44100 (44,100 Hz)
         * + **5**: AUDIO_SAMPLE_48000 (48,000 Hz)
         * + **6**: AUDIO_SAMPLE_96000 (96,000 Hz)
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupVideo {
        /**
         * Specifies the average output bitrate.  
         * The value is `0` or an integer ranging from `40` to `30,000`. The default value is `0`. The unit is kbit/s.
         * If this parameter is set to `0`, the average output bitrate is an adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the video height.  
         * The value is `0` or a multiple of `2` from `32` to `2,880` for H.264, and `0` or a multiple of `4` from `96` to
         * `2,880` for H.265. The unit is pixel.
         * If this parameter is set to `0`, the video height is an adaptive value. The default value is `0`.
         */
        height?: number;
        /**
         * Specifies the video width.  
         * The value can be 0 or a multiple of `2` from `32` to `4,096` for H.264 and `0` or a multiple of `4` from `160` to
         * `4,096` for H.265. The unit is pixel.
         * If this parameter is set to `0`, the video width is an adaptive value. The default value is `0`.
         */
        width?: number;
    }

    export interface TranscodingTemplateGroupVideoCommon {
        /**
         * Specifies whether to enable black bar removal. Possible values are:
         * + **0**: Disable black bar removal.
         * + **1**: Enable black bar removal and low-complexity algorithms for long videos (>5 minutes).
         * + **2**: Enable black bar removal and high-complexity algorithms for short videos (5 minutes).
         */
        blackBarRemoval?: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec?: number;
        /**
         * Specifies the frame rate. Its value is `0` or an integer ranging from `5` to `30`.
         * The default value is `0`. The unit is FPS.
         */
        fps?: number;
        /**
         * Specifies the encoding level. Possible values are:
         * + **1**: VIDEO_LEVEL_1_0
         * + **2**: VIDEO_LEVEL_1_1
         * + **3**: VIDEO_LEVEL_1_2
         * + **4**: VIDEO_LEVEL_1_3
         * + **5**: VIDEO_LEVEL_2_0
         * + **6**: VIDEO_LEVEL_2_1
         * + **7**: VIDEO_LEVEL_2_2
         * + **8**: VIDEO_LEVEL_3_0
         * + **9**: VIDEO_LEVEL_3_1
         * + **10**: VIDEO_LEVEL_3_2
         * + **11**: VIDEO_LEVEL_4_0
         * + **12**: VIDEO_LEVEL_4_1
         * + **13**: VIDEO_LEVEL_4_2
         * + **14**: VIDEO_LEVEL_5_0
         * + **15**: VIDEO_LEVEL_5_1
         */
        level?: number;
        /**
         * Specifies the maximum number of B-frames.
         * The value range is  `0` to `7`, and the default value is `4`. The unit is frame.
         */
        maxConsecutiveBframes?: number;
        /**
         * Specifies the maximum I-frame interval. The value ranges from `2` to `10`.
         * The default value is `5`. The unit is second.
         */
        maxIframesInterval?: number;
        maxReferenceFrames: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the encoding profile.  
         * Possible values are:
         * + **1**: VIDEO_PROFILE_H264_BASE
         * + **2**: VIDEO_PROFILE_H264_MAIN
         * + **3**: VIDEO_PROFILE_H264_HIGH
         * + **4**: VIDEO_PROFILE_H265_MAIN
         */
        profile?: number;
        /**
         * Specifies the encoding quality. A larger value indicates higher encoding quality and
         * longer transcoding time. Possible values are:
         * + **1**: VIDEO_PRESET_HSPEED2
         * + **2**: VIDEO_PRESET_HSPEED
         * + **3**: VIDEO_PRESET_NORMAL
         */
        quality?: number;
    }

    export interface TranscodingTemplateVideo {
        /**
         * Specifies the average output bitrate.  
         * The value is 0 or an integer ranging from `40` to `30,000`. The default value is `0`. The unit is kbit/s.
         * If this parameter is set to `0`, the average output bitrate is an adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies whether to enable black bar removal. Possible values are:
         * + **0**: Disable black bar removal.
         * + **1**: Enable black bar removal and low-complexity algorithms for long videos (>5 minutes).
         * + **2**: Enable black bar removal and high-complexity algorithms for short videos (5 minutes).
         */
        blackBarRemoval?: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec?: number;
        /**
         * Specifies the frame rate. Its value is `0` or an integer ranging from `5` to `30`.
         * The default value is `0`. The unit is FPS.
         */
        fps?: number;
        /**
         * Specifies the video height.  
         * The value is `0` or a multiple of `2` from `32` to `2,880` for H.264, and `0` or a multiple of `4` from `96` to
         * `2,880` for H.265. The unit is pixel.
         * If this parameter is set to `0`, the video height is an adaptive value. The default value is `0`.
         */
        height?: number;
        /**
         * Specifies the encoding level.  
         * Possible values are:
         * + **1**: VIDEO_LEVEL_1_0
         * + **2**: VIDEO_LEVEL_1_1
         * + **3**: VIDEO_LEVEL_1_2
         * + **4**: VIDEO_LEVEL_1_3
         * + **5**: VIDEO_LEVEL_2_0
         * + **6**: VIDEO_LEVEL_2_1
         * + **7**: VIDEO_LEVEL_2_2
         * + **8**: VIDEO_LEVEL_3_0
         * + **9**: VIDEO_LEVEL_3_1
         * + **10**: VIDEO_LEVEL_3_2
         * + **11**: VIDEO_LEVEL_4_0
         * + **12**: VIDEO_LEVEL_4_1
         * + **13**: VIDEO_LEVEL_4_2
         * + **14**: VIDEO_LEVEL_5_0
         * + **15**: VIDEO_LEVEL_5_1
         */
        level?: number;
        /**
         * Specifies the maximum number of B-frames.
         * The value range is `0` to `7`, and the default value is `4`. The unit is frame.
         */
        maxConsecutiveBframes?: number;
        /**
         * Specifies the maximum I-frame interval, in second.  
         * The value ranges from `2` to `10`. The default value is `5`.
         */
        maxIframesInterval?: number;
        maxReferenceFrames: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the encoding profile.  
         * Possible values are:
         * + **1**: VIDEO_PROFILE_H264_BASE
         * + **2**: VIDEO_PROFILE_H264_MAIN
         * + **3**: VIDEO_PROFILE_H264_HIGH
         * + **4**: VIDEO_PROFILE_H265_MAIN
         */
        profile?: number;
        /**
         * Specifies the encoding quality. A larger value indicates higher encoding quality and
         * longer transcoding time. Possible values are:
         * + **1**: VIDEO_PRESET_HSPEED2
         * + **2**: VIDEO_PRESET_HSPEED
         * + **3**: VIDEO_PRESET_NORMAL
         */
        quality?: number;
        /**
         * Specifies the video width.  
         * The value can be 0 or a multiple of `2` from `32` to `4,096` for H.264 and `0` or a multiple of `4` from `160` to
         * `4,096` for H.265. The unit is pixel.
         * If this parameter is set to `0`, the video width is an adaptive value. The default value is `0`.
         */
        width?: number;
    }

}

export namespace Mrs {
    export interface ClusterAnalysisCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterAnalysisTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterBootstrapScript {
        /**
         * Specifies whether the bootstrap action script runs only on active master nodes.
         * The default value is **false**, indicating that the bootstrap action script can run on all master nodes.
         */
        activeMaster: boolean;
        /**
         * Specifies whether the bootstrap action script is executed
         * before component start.
         * The options are as follows:
         * + **false**: After component start. The default value is **false**.
         * + **true**: Before component start.
         */
        beforeComponentStart: boolean;
        /**
         * Specifies whether the bootstrap action script involves root user
         * operations.
         * Changing this will create a new MapReduce cluster resource.
         */
        executeNeedSudoRoot: boolean;
        /**
         * Specifies the action after the bootstrap action script fails to be executed.
         * The options are as follows:
         * + **continue**: Continue to execute subsequent scripts.
         * + **errorout**: Stop the action.
         */
        failAction: string;
        /**
         * Specifies the name of a bootstrap action script.
         * Changing this will create a new MapReduce cluster resource.
         */
        name: string;
        /**
         * Specifies names of the node group where the bootstrap action script is executed.
         */
        nodes: string[];
        /**
         * Specifies bootstrap action script parameters.
         */
        parameters?: string;
        startTime: string;
        state: string;
        /**
         * Specifies the path of a bootstrap action script.
         * Set this parameter to an OBS bucket path or a local VM path.
         * + **OBS bucket path**: The path of an OBS file system starts with *s3a://* or *obs://* and end with *.sh*.
         * + **Local VM path**: The script path must start with a slash (/) and end with *.sh*.
         */
        uri: string;
    }

    export interface ClusterComponentConfig {
        /**
         * Specifies the configuration of component installed.
         * The object structure is documented below.
         */
        configs: outputs.Mrs.ClusterComponentConfigConfig[];
        /**
         * Specifies the name of a bootstrap action script.
         * Changing this will create a new MapReduce cluster resource.
         */
        name: string;
    }

    export interface ClusterComponentConfigConfig {
        /**
         * Specifies the configuration file name of component installed.
         * Changing this will create a new MapReduce cluster resource.
         */
        configFileName: string;
        /**
         * Specifies the configuration item key of component installed.
         * Changing this will create a new MapReduce cluster resource.
         */
        key: string;
        /**
         * Specifies the configuration item value of component installed.
         * Changing this will create a new MapReduce cluster resource.
         */
        value: string;
    }

    export interface ClusterCustomNode {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * Specifies the name of nodes for the node group.
         */
        groupName: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterExternalDatasource {
        /**
         * Specifies the component name. The valid values are `Hive` and `Ranger`.
         * Changing this will create a new MapReduce cluster resource.
         */
        componentName: string;
        /**
         * Specifies the data connection ID.
         * This parameter is mandatory if `sourceType` is not **LOCAL_DB**.
         * Changing this will create a new MapReduce cluster resource.
         */
        dataConnectionId?: string;
        /**
         * Specifies the component role type.
         * The options are as follows:
         * + **hive_metastore**: Hive Metastore role.
         * + **ranger_data**: Ranger role.
         */
        roleType: string;
        /**
         * Specifies the data connection type.
         * The options are as follows:
         * + **LOCAL_DB**: Local metadata.
         * + **RDS_POSTGRES**: RDS PostgreSQL database.
         * + **RDS_MYSQL**: RDS MySQL database.
         * + **gaussdb-mysql**: GaussDB(for MySQL).
         */
        sourceType: string;
    }

    export interface ClusterMasterNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterSmnNotify {
        /**
         * Specifies the subscription rule name.
         * Changing this will create a new MapReduce cluster resource.
         */
        subscriptionName: string;
        /**
         * Specifies the Uniform Resource Name (URN) of the topic.
         * Changing this will create a new MapReduce cluster resource.
         */
        topicUrn: string;
    }

    export interface ClusterStreamingCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterStreamingTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is **CUSTOM**. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + **master_nodes**: 1.
         * + **analysis_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_core_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **analysis_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + **streaming_task_nodes**: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + **SATA**: common I/O disk.
         * + **SAS**: high I/O disk.
         * + **SSD**: ultra-high I/O disk.
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         * * `bootstrap_scripts/start_time` - The execution time of one bootstrap action script, in RFC-3339 format.
         * * `bootstrap_scripts/state` - The status of one bootstrap action script.
         * The valid value are **PENDING**, **IN_PROGRESS**, **SUCCESS**, and **FAILURE**.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

}

export namespace Nat {
    export interface GatewaySessionConf {
        /**
         * Specifies the ICMP session expiration time, in seconds.
         * The valid value from `10` to `7,200`, default value is `10`.
         */
        icmpSessionExpireTime: number;
        /**
         * Specifies the TCP session expiration time, in seconds.
         * The valid value from `40` to `7,200`, default value is `900`.
         */
        tcpSessionExpireTime: number;
        /**
         * Specifies the duration of TIME_WAIT state when TCP connection is closed,
         * in seconds. The valid value from `0` to `1,800`, default value is `5`.
         */
        tcpTimeWaitTime: number;
        /**
         * Specifies the UDP session expiration time, in seconds.
         * The valid value from `40` to `7,200`, default value is `300`.
         */
        udpSessionExpireTime: number;
    }

}

export namespace Obs {
    export interface BucketCorsRule {
        /**
         * Specifies the allowed header of cross-origin requests. Only CORS requests
         * matching the allowed header are valid.
         */
        allowedHeaders?: string[];
        /**
         * Specifies the acceptable operation type of buckets and objects. The methods
         * include `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * Requests from this origin can access the bucket. Multiple matching rules are
         * allowed. One rule occupies one line, and allows one wildcard character (*) at most.
         */
        allowedOrigins: string[];
        /**
         * Specifies the exposed header in CORS responses, providing additional information
         * for clients.
         */
        exposeHeaders?: string[];
        /**
         * Specifies the duration that your browser can cache CORS responses, expressed in
         * seconds. The default value is 100.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies a period when the not merged parts (fragments) in an
         * incomplete upload are automatically deleted. (documented below).
         */
        abortIncompleteMultipartUploads?: outputs.Obs.BucketLifecycleRuleAbortIncompleteMultipartUpload[];
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period when objects that have been last updated are automatically
         * deleted. (documented below).
         */
        expirations?: outputs.Obs.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for lifecycle rules. The Rule Name contains a maximum of 255 characters.
         */
        name: string;
        /**
         * Specifies a period when noncurrent object versions are
         * automatically deleted. (documented below).
         */
        noncurrentVersionExpirations?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies a period when noncurrent object versions are
         * automatically transitioned to `WARM` or `COLD` storage class (documented below).
         */
        noncurrentVersionTransitions?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies. If omitted,
         * all objects in the bucket will be managed by the lifecycle rule. The prefix cannot start or end with a slash (/),
         * cannot have consecutive slashes (/), and cannot contain the following special characters: \:*?"<>|.
         * When configuring multiple `lifecycleRule`, field `prefix` in multiple `lifecycleRule` cannot have an inclusive
         * relationship.
         */
        prefix?: string;
        /**
         * Specifies a period when objects that have been last updated are automatically
         * transitioned to `WARM` or `COLD` storage class (documented below).
         */
        transitions?: outputs.Obs.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days since the initiation of an incomplete multipart upload that OBS
         * will wait before deleting the not merged parts (fragments) of the upload.
         * The valid value ranges from 1 to 2,147,483,647.
         */
        days: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the number of days when objects that have been last updated are automatically
         * deleted. The expiration time must be greater than the transition times.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days when noncurrent object versions are automatically deleted.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days when noncurrent object versions are automatically transitioned
         * to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are
         * supported.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the number of days when objects that have been last updated are automatically
         * transitioned to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are
         * supported.
         */
        storageClass: string;
    }

    export interface BucketLogging {
        /**
         * Specifies the IAM agency of OBS cloud service.
         */
        agency: string;
        /**
         * The name of the bucket that will receive the log objects. The acl policy of the
         * target bucket should be `log-delivery-write`.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketStorageInfo {
        /**
         * The number of objects stored in the bucket.
         */
        objectNumber: number;
        /**
         * The stored size of the bucket.
         */
        size: number;
    }

    export interface BucketWebsite {
        /**
         * Specifies the error page returned when an error occurs during static website
         * access. Only HTML, JPG, PNG, BMP, and WEBP files under the root directory are supported.
         */
        errorDocument?: string;
        /**
         * Unless using `redirectAllRequestsTo`. Specifies the default homepage of the
         * static website, only HTML web pages are supported. OBS only allows files such as `index.html` in the root directory of
         * a bucket to function as the default homepage. That is to say, do not set the default homepage with a multi-level
         * directory structure (for example, /page/index.html).
         */
        indexDocument?: string;
        /**
         * A hostname to redirect all website requests for this bucket to.
         * Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The
         * default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * A JSON or XML format containing routing rules describing redirect behavior and
         * when redirects are applied. Each rule contains a `Condition` and a `Redirect` as shown in the following table:
         */
        routingRules?: string;
    }

    export interface GetBucketsBucket {
        /**
         * The name of the OBS bucket.
         */
        bucket: string;
        /**
         * The date when the OBS bucket was created.
         */
        createdAt: string;
        /**
         * The enterprise project id of the OBS bucket.
         */
        enterpriseProjectId: string;
        /**
         * The region in which to obtain the OBS bucket.
         * If omitted, the provider-level region will be used.
         */
        region: string;
        /**
         * The storage class of the OBS bucket.
         */
        storageClass: string;
    }

}

export namespace Oms {
    export interface MigrationTaskBandwidthPolicy {
        /**
         * Specifies the end time of the traffic limit rule. The format is **hh:mm**,
         * e.g. **12:03**.
         */
        end: string;
        /**
         * Specifies the maximum traffic bandwidth allowed in the specified time
         * segment. The value ranges from `1` to `200`. The unit is MB/s.
         */
        maxBandwidth: number;
        /**
         * Specifies the start time of the traffic limit rule. The format is **hh:mm**,
         * e.g. **12:03**.
         */
        start: string;
    }

    export interface MigrationTaskDestinationObject {
        /**
         * Specifies the access key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        accessKey?: string;
        /**
         * Specifies the name of the destination bucket.
         * Changing this creates a new resource.
         */
        bucket: string;
        /**
         * Specifies the region where the destination bucket is located.
         * Changing this creates a new resource.
         */
        region: string;
        /**
         * Specifies the path prefix in the destination bucket. The prefix is added
         * before the object key to form a new key. Changing this creates a new resource.
         */
        savePrefix?: string;
        /**
         * Specifies the secret key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        secretKey?: string;
        /**
         * Specifies the temporary token for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        securityToken?: string;
    }

    export interface MigrationTaskSmnConfig {
        /**
         * Specifies the SMN message language. The value can be **zh-cn** or
         * **en-us**. Default value: **en-us**. Changing this creates a new resource.
         */
        language?: string;
        /**
         * Specifies the SMN message topic URN bound to a migration task.
         * Changing this creates a new resource.
         */
        topicUrn: string;
        /**
         * Specifies the trigger conditions of sending messages using SMN.
         * The value can be:
         * + **FAILURE**: indicates that an SMN message will be sent after the migration task fails.
         * + **SUCCESS**: indicates that an SMN message will be sent after the migration task succeeds.
         */
        triggerConditions: string[];
    }

    export interface MigrationTaskSourceCdn {
        /**
         * Specifies the CDN authentication key.
         * Changing this creates a new resource.
         */
        authenticationKey?: string;
        /**
         * Specifies the authentication type. Valid values are **NONE**,
         * **QINIU_PRIVATE_AUTHENTICATION**, **ALIYUN_OSS_A**, **ALIYUN_OSS_B**, **ALIYUN_OSS_C**,
         * **KSYUN_PRIVATE_AUTHENTICATION**, **TENCENT_COS_A**, **TENCENT_COS_B**, **TENCENT_COS_C**,
         * **TENCENT_COS_D**. Default value: **None**. Changing this creates a new resource.
         */
        authenticationType?: string;
        /**
         * Specifies the domain name from which to obtain objects to be migrated.
         * Changing this creates a new resource.
         */
        domain: string;
        /**
         * Specifies the protocol type. Valid values are **HTTP** and **HTTPS**.
         * Changing this creates a new resource.
         */
        protocol: string;
    }

    export interface MigrationTaskSourceObject {
        /**
         * Specifies the access key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        accessKey?: string;
        /**
         * Specifies the APP ID. This parameter is mandatory when `dataSource` is  
         * **Tencent**. Changing this creates a new resource.
         */
        appId?: string;
        /**
         * Specifies the name of the destination bucket.
         * Changing this creates a new resource.
         */
        bucket?: string;
        /**
         * Specifies the source cloud service provider. If `type` is
         * **url_list**,set this parameter to **URLSource**. The value can be **AWS**, **Azure**, **Aliyun**, **Tencent**,
         * **HuaweiCloud**, **QingCloud**, **KingsoftCloud**, **Baidu**, **Qiniu**, **URLSource** and **UCloud**.
         * The default value is **Aliyun**. Changing this creates a new resource.
         */
        dataSource?: string;
        /**
         * Specifies the name of the OBS bucket for storing the object list files.
         * `listFileBucket` is mandatory when `type` is set to **list** or **url_list**. Changing this creates a new resource.
         */
        listFileBucket?: string;
        /**
         * Specifies the object name of the list file or URL list file.
         * `listFileKey` is mandatory when `type` is set to **list** or **url_list**. Changing this creates a new resource.
         */
        listFileKey?: string;
        /**
         * Specifies the list of object keys.
         * + If `type` is set to **object**, this parameter specifies the names of the objects to be migrated. The strings
         * ending with a slash (/) indicate the folders to be migrated, and the strings not ending with a slash (/) indicate the
         * files to be migrated.
         * + If `type` is set to **prefix**, this parameter indicates the name prefixes of the objects to be migrated.
         * Set this parameter to [""] to migrate the entire bucket
         */
        objects?: string[];
        /**
         * Specifies the region where the destination bucket is located.
         * Changing this creates a new resource.
         */
        region?: string;
        /**
         * Specifies the secret key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        secretKey?: string;
        /**
         * Specifies the temporary token for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        securityToken?: string;
    }

}

export namespace Rds {
    export interface BackupDatabase {
        /**
         * Database to be backed up for Microsoft SQL Server.
         */
        name: string;
    }

    export interface Database_privilegeUser {
        name: string;
        readonly: boolean;
    }

    export interface GetAvailableFlavorsOptionalFlavor {
        /**
         * Indicates the az status.
         */
        azStatus: {[key: string]: string};
        /**
         * Indicates the performance specifications. Its value can be any of the following:
         * + **normal**: general-enhanced
         * + **normal2**: general-enhanced II
         * + **armFlavors**: Kunpeng general-enhanced
         * + **dedicicatenormal**: exclusive x86
         * + **armlocalssd**: standard Kunpeng
         * + **normallocalssd**: standard x86
         * + **general**: general-purpose
         * + **dedicated**: dedicated, which is only supported for cloud SSDs
         * + **rapid**: dedicated, which is only supported for extreme SSDs
         * + **bigmen**: Large-memory
         */
        groupType: string;
        /**
         * Indicates whether supported ipv6.
         */
        isIpv6Supported: boolean;
        /**
         * Indicates the max connection.
         */
        maxConnection: string;
        /**
         * Indicates the maximum disk capacity in GB.
         */
        maxVolumeSize: string;
        /**
         * Indicates the minimum disk capacity in GB.
         */
        minVolumeSize: string;
        /**
         * Indicates the number of SQL statements executed by the database per second, including **insert**, **select**,
         * **update**, **delete** and so on.
         */
        qps: string;
        /**
         * Indicates the memory size, in GB.
         */
        ram: string;
        /**
         * Indicates the resource specification code.
         */
        specCode: string;
        /**
         * Indicates the number of transactions executed by the database per second, each containing 18 SQL statements.
         */
        tps: string;
        /**
         * Indicates the resource type.
         */
        typeCode: string;
        /**
         * Indicates the CPU size.
         */
        vcpus: string;
    }

    export interface GetBackupFilesFile {
        /**
         * Indicates the name of the database.
         */
        databaseName: string;
        /**
         * Indicates the link for downloading the backup file.
         */
        downloadLink: string;
        /**
         * Indicates the link expiration time.
         */
        linkExpiredTime: string;
        /**
         * Indicates the file name.
         */
        name: string;
        /**
         * Indicates the file size in KB.
         */
        size: number;
    }

    export interface GetBackupsBackup {
        /**
         * Whether a DDM instance has been associated.
         */
        associatedWithDdm: boolean;
        /**
         * Start time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        beginTime: string;
        /**
         * Database been backed up.
         * The databases structure is documented below.
         */
        databases: outputs.Rds.GetBackupsBackupDatabase[];
        /**
         * The database information.
         * The datastore structure is documented below.
         */
        datastores: outputs.Rds.GetBackupsBackupDatastore[];
        /**
         * End time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        endTime: string;
        /**
         * Backup ID.
         */
        id: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Backup name.
         */
        name: string;
        /**
         * Backup size in KB.
         */
        size: number;
        /**
         * Backup status.  
         * The options are as follows:
         * + **BUILDING**: Backup in progress.
         * + **COMPLETED**: Backup completed.
         * + **FAILED**: Backup failed.
         * + **DELETING**: Backup being deleted.
         */
        status: string;
        /**
         * DB engine.  
         * The value can be **MySQL**, **PostgreSQL**, **SQLServer**, **MariaDB**.
         */
        type: string;
    }

    export interface GetBackupsBackupDatabase {
        /**
         * Backup name.
         */
        name: string;
    }

    export interface GetBackupsBackupDatastore {
        /**
         * DB engine.  
         * The value can be **MySQL**, **PostgreSQL**, **SQLServer**, **MariaDB**.
         */
        type: string;
        /**
         * DB engine version.
         */
        version: string;
    }

    export interface GetCrossRegionBackupInstancesBackupInstance {
        /**
         * Indicates the database information.
         */
        datastores: outputs.Rds.GetCrossRegionBackupInstancesBackupInstanceDatastore[];
        /**
         * Specifies the project ID of the target backup region.
         */
        destinationProjectId: string;
        /**
         * Specifies the region where the cross-region backup is located.
         */
        destinationRegion: string;
        /**
         * Indicates the ID of the instance.
         */
        id: string;
        /**
         * Specifies the number of days to retain cross-region backups.
         */
        keepDays: number;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Specifies the project ID of the source backup region.
         */
        sourceProjectId: string;
        /**
         * Specifies the source backup region.
         */
        sourceRegion: string;
    }

    export interface GetCrossRegionBackupInstancesBackupInstanceDatastore {
        /**
         * Indicates the database engine.
         * Its value can be any of the following and is case-insensitive: **MySQL**, **PostgreSQL**, **SQLServer**, **MariaDB**.
         */
        type: string;
        /**
         * Indicates the database engine version.
         */
        version: string;
    }

    export interface GetCrossRegionBackupsBackup {
        /**
         * Indicates whether a DDM instance has been associated.
         */
        associatedWithDdm: boolean;
        /**
         * Specifies the start time for obtaining the cross-region backup list.
         * The format is **yyyy-mm-ddThh:mm:ssZ**. This parameter must be used together with `endTime`.
         */
        beginTime: string;
        /**
         * Indicates the database to be backed up.
         */
        databases: outputs.Rds.GetCrossRegionBackupsBackupDatabase[];
        /**
         * Indicates the database information
         */
        datastores: outputs.Rds.GetCrossRegionBackupsBackupDatastore[];
        /**
         * Specifies the end time for obtaining the cross-region backup list.
         * The format is **yyyy-mm-ddThh:mm:ssZ**. The end time must be later than the start time.
         * This parameter must be used together with `beginTime`.
         */
        endTime: string;
        /**
         * Indicates the ID of the cross-region backup.
         */
        id: string;
        /**
         * Specifies the ID of the RDS instance.
         */
        instanceId: string;
        /**
         * Specifies the name of the cross-region backup.
         */
        name: string;
        /**
         * Indicates the backup size in KB.
         */
        size: number;
        /**
         * Specifies the status of the cross-region backup.
         * Value options:
         * + **BUILDING**: Backup in progress
         * + **COMPLETED**: Backup completed
         * + **FAILED**: Backup failed
         * + **DELETING**: Backup being deleted
         */
        status: string;
        /**
         * Indicates the database engine.
         * Its value can be any of the following and is case-insensitive: **MySQL**, **PostgreSQL**, **SQLServer** and **MariaDB**.
         */
        type: string;
    }

    export interface GetCrossRegionBackupsBackupDatabase {
        /**
         * Specifies the name of the cross-region backup.
         */
        name: string;
    }

    export interface GetCrossRegionBackupsBackupDatastore {
        /**
         * Indicates the database engine.
         * Its value can be any of the following and is case-insensitive: **MySQL**, **PostgreSQL**, **SQLServer** and **MariaDB**.
         */
        type: string;
        /**
         * Indicates the database engine version.
         */
        version: string;
    }

    export interface GetEngineVersionsVersion {
        /**
         * Version ID.
         */
        id: string;
        /**
         * Version name.
         */
        name: string;
    }

    export interface GetErrorLogsErrorLog {
        /**
         * Indicates the error log content.
         */
        content: string;
        /**
         * Specifies the log level. Value options: **ALL**, **INFO**, **LOG**, **WARNING**,
         * **ERROR**, **FATAL**, **PANIC**, **NOTE**. Defaults to **ALL**.
         */
        level: string;
        /**
         * Indicates the date and time of the error log in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        time: string;
    }

    export interface GetExtendLogFilesFile {
        /**
         * Indicates the file Name.
         */
        fileName: string;
        /**
         * Indicates the file size. Unit: KB.
         */
        fileSize: string;
    }

    export interface GetExtendLogLinksLink {
        /**
         * Indicates the creation time.
         */
        createdAt: string;
        /**
         * Indicates the download link.
         */
        fileLink: string;
        /**
         * Specifies the name of the file to be downloaded.
         */
        fileName: string;
        /**
         * Indicates the file size in KB.
         */
        fileSize: string;
        /**
         * Indicates the status of the link. The value can be one of the following:
         * + **SUCCESS**: The download link has been generated.
         * + **EXPORTING**: The file is being generated.
         * + **FAILED**: The log file fails to be prepared.
         */
        status: string;
        /**
         * Indicates the last update time.
         */
        updatedAt: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The availability zones which the RDS flavor belongs to.
         */
        availabilityZones: string[];
        /**
         * The Available versions of the database.
         */
        dbVersions: string[];
        /**
         * Specifies the performance specification, the valid values are as follows:
         * + **normal**: General enhanced.
         * + **normal2**: General enhanced type II.
         * + **armFlavors**: KunPeng general enhancement.
         * + **dedicatedNormal**: (dedicatedNormalLocalssd): Dedicated for x86.
         * + **armLocalssd**: KunPeng general type.
         * + **normalLocalssd**: x86 general type.
         * + **general**: General type.
         * + **dedicated**:
         * For MySQL engine: Dedicated type.
         * For PostgreSQL and SQL Server engines: Dedicated type, only supported by cloud disk SSD.
         * + **rapid**:
         * For MySQL engine: Dedicated (discontinued).
         * For PostgreSQL and SQL Server engines: Dedicated, only supported by ultra-fast SSDs.
         * + **bigmem**: Large memory type.
         */
        groupType: string;
        /**
         * The ID of the rds flavor.
         */
        id: string;
        /**
         * The mode of instance. The value can be **ha**(indicates primary/standby
         * instance), **single**(indicates single instance) and **replica**(indicates read replicas).
         */
        instanceMode: string;
        /**
         * Specifies the memory size(GB) in the RDS flavor.
         */
        memory: number;
        /**
         * @deprecated use instance_mode instead
         */
        mode: string;
        /**
         * The name of the rds flavor.
         */
        name: string;
        /**
         * Specifies the number of vCPUs in the RDS flavor.
         */
        vcpus: number;
    }

    export interface GetInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZones: string[];
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.Rds.GetInstancesInstanceBackupStrategy[];
        /**
         * Indicates the creation time.
         */
        created: string;
        /**
         * Indicates the database information. Structure is documented below.
         */
        dbs: outputs.Rds.GetInstancesInstanceDb[];
        /**
         * Specifies the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the intranet floating IP address of the instance.
         */
        fixedIp: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the replication mode for the standby DB instance.
         */
        haReplicationMode: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.Rds.GetInstancesInstanceNode[];
        /**
         * Indicates the configuration ID.
         */
        paramGroupId: string;
        /**
         * Indicates the private ips in list.
         */
        privateIps: string[];
        /**
         * Indicates the public ips in list.
         */
        publicIps: string[];
        /**
         * The region in which to obtain the instances. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates whether to enable SSL.
         */
        sslEnable: boolean;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the tags of the instance.
         */
        tags: {[key: string]: string};
        /**
         * Indicates the time zone.
         */
        timeZone: string;
        /**
         * Indicates the volume information. Structure is documented below.
         */
        volumes: outputs.Rds.GetInstancesInstanceVolume[];
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated.
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetInstancesInstanceDb {
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Specifies the type of the instance. Valid values are **Single**, **Ha**, **Replica**,
         * and **Enterprise**.
         */
        type: string;
        /**
         * Indicates the database user name.
         */
        userName: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the node type.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetInstancesInstanceVolume {
        /**
         * Indicates the kms key id.
         */
        diskEncryptionId: string;
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Specifies the type of the instance. Valid values are **Single**, **Ha**, **Replica**,
         * and **Enterprise**.
         */
        type: string;
    }

    export interface GetMysqlAccountsUser {
        /**
         * Indicates remarks of the database account.
         */
        description: string;
        /**
         * Indicates the IP addresses that are allowed to access your DB instance.
         */
        hosts: string[];
        /**
         * Specifies the username of the DB account.
         */
        name: string;
    }

    export interface GetMysqlDatabasePrivilegesUser {
        /**
         * The username of the database account.
         */
        name: string;
        /**
         * Specifies whether the database permission is **read-only**. Values option:
         * + **true**: indicates the database is read-only.
         * + **false**: indicates the database is readable and writable.
         */
        readonly: boolean;
    }

    export interface GetMysqlDatabasesDatabase {
        /**
         * Specifies the character set used by the database.
         */
        characterSet: string;
        /**
         * Indicates the database description.
         */
        description: string;
        /**
         * Specifies the database name.
         */
        name: string;
    }

    export interface GetMysqlProxiesProxyList {
        /**
         * Indicates the master instance information.
         */
        masterInstances: outputs.Rds.GetMysqlProxiesProxyListMasterInstance[];
        /**
         * Indicates the proxy information.
         */
        proxies: outputs.Rds.GetMysqlProxiesProxyListProxy[];
        /**
         * Indicates whether the security group allows access from the database proxy
         * to the database.
         */
        proxySecurityGroupCheckResult: boolean;
        /**
         * Indicates the read-only instance information.
         */
        readonlyInstances: outputs.Rds.GetMysqlProxiesProxyListReadonlyInstance[];
    }

    export interface GetMysqlProxiesProxyListMasterInstance {
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the read weight of the instance.
         */
        weight: number;
    }

    export interface GetMysqlProxiesProxyListProxy {
        /**
         * Indicates the proxy address.
         */
        address: string;
        /**
         * Indicates the ALT switch status.
         */
        altFlag: boolean;
        /**
         * Indicates the connection pool type.
         * The value can be:
         * + **CLOSED**: The connection pool is closed.
         * + **SESSION**: The session-level connection pool is enabled.
         */
        connectionPoolType: string;
        /**
         * Indicates the delay threshold, in seconds.
         */
        delayThresholdInSeconds: number;
        /**
         * Indicates the private domain name for the read/write splitting address of the proxy.
         */
        dnsName: string;
        /**
         * Indicates the proxy specifications.
         */
        flavorInfos: outputs.Rds.GetMysqlProxiesProxyListProxyFlavorInfo[];
        /**
         * Indicates whether to forcibly read the route to the read-only mode.
         */
        forceReadOnly: boolean;
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the memory size of the proxy.
         */
        memory: string;
        /**
         * Indicates the cluster mode of the proxy.
         * The value can be: **Cluster**, **Ha**.
         */
        mode: string;
        /**
         * Indicates the proxy name.
         */
        name: string;
        /**
         * Indicates the number of proxy nodes.
         */
        nodeNum: number;
        /**
         * Indicates the list of proxy nodes.
         */
        nodes: outputs.Rds.GetMysqlProxiesProxyListProxyNode[];
        /**
         * Indicates the charging mode of the proxy.
         * The value can be:
         * + **0**: pay-per-use billing.
         * + **1**: yearly/monthly billing.
         */
        payMode: string;
        /**
         * Indicates the port number.
         */
        port: number;
        /**
         * Indicates the Proxy read/write Mode.
         * The value can be:
         * + **readwrite(default value)**: read and write.
         * + **readonly**: read-only.
         */
        proxyMode: string;
        /**
         * Indicates the routing policy of the proxy.
         * The values can be:
         * + **0**: weighted load balancing.
         * + **1**: load balancing (The primary node does not process read requests).
         * + **2**: load balancing (The primary node processes read requests).
         */
        routeMode: number;
        /**
         * Indicates the second-level monitoring status of the proxy.
         */
        secondsLevelMonitorFunStatus: string;
        /**
         * Indicates the SSL switch status.
         */
        sslOption: boolean;
        /**
         * Indicates the status of the proxy node.
         * The values can be:
         * + **NORMAL**: The node is normal.
         * + **ABNORMAL**: The node is abnormal.
         * + **CREATING**: The node is being created.
         * + **CREATEFAIL**: The node failed to be created.
         */
        status: string;
        /**
         * Indicates the ID of the subnet to which the database proxy belongs.
         */
        subnetId: string;
        /**
         * Indicates whether the proxy supports the load balancing routing mode.
         */
        supportBalanceRouteMode: boolean;
        /**
         * Indicates whether the database proxy supports the SSL function.
         */
        supportProxySsl: boolean;
        /**
         * Indicates whether the proxy supports the switchover of the session
         * connection pool type.
         */
        supportSwitchConnectionPoolType: boolean;
        /**
         * Indicates whether the proxy supports transaction splitting.
         */
        supportTransactionSplit: boolean;
        /**
         * Indicates the status of the proxy transaction splitting switch.
         */
        transactionSplit: string;
        /**
         * Indicates the CPU size of the proxy.
         */
        vcpus: string;
    }

    export interface GetMysqlProxiesProxyListProxyFlavorInfo {
        /**
         * Indicates the specification code.
         */
        code: string;
        /**
         * Indicates the flavor group type.
         */
        groupType: string;
    }

    export interface GetMysqlProxiesProxyListProxyNode {
        /**
         * Indicates the AZ where the proxy node is located.
         */
        azCode: string;
        /**
         * Indicates whether the proxy node is frozen.
         * The values can be:
         * + **0**: unfrozen.
         * + **1**: frozen.
         */
        frozenFlag: number;
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the role of the proxy node:
         * The values can be:
         * + **master**: primary node.
         * + **slave**: standby node.
         */
        role: string;
        /**
         * Indicates the status of the proxy node.
         * The values can be:
         * + **NORMAL**: The node is normal.
         * + **ABNORMAL**: The node is abnormal.
         * + **CREATING**: The node is being created.
         * + **CREATEFAIL**: The node failed to be created.
         */
        status: string;
    }

    export interface GetMysqlProxiesProxyListReadonlyInstance {
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the read weight of the instance.
         */
        weight: number;
    }

    export interface GetMysqlProxyFlavorsFlavorGroup {
        /**
         * Indicates the list of flavors.
         */
        flavors: outputs.Rds.GetMysqlProxyFlavorsFlavorGroupFlavor[];
        /**
         * Indicates the specification group type. The value can be **ARM** or **X86**.
         */
        groupType: string;
    }

    export interface GetMysqlProxyFlavorsFlavorGroupFlavor {
        /**
         * Indicates the AZ information. **key** indicates the AZ associated with the specification, and **value**
         * indicates the specification status in the AZ. Only the specification status in the AZ where the primary instance is
         * located is displayed.
         */
        azStatus: {[key: string]: string};
        /**
         * Indicates the specification code of the database proxy.
         */
        code: string;
        /**
         * Indicates the database type.
         */
        dbType: string;
        /**
         * Indicates the specification ID of the database proxy.
         */
        id: string;
        /**
         * Indicates the memory size in GB.
         */
        memory: string;
        /**
         * Indicates the number of vCPUs.
         */
        vcpus: string;
    }

    export interface GetParametergroupsConfiguration {
        /**
         * The creation time of the configuration.
         */
        createdAt: string;
        /**
         * Specifies the database name.
         */
        datastoreName: string;
        /**
         * Specifies the database version name.
         */
        datastoreVersionName: string;
        /**
         * The parameter template description.
         */
        description: string;
        /**
         * The parameter template ID.
         */
        id: string;
        /**
         * Specifies the parameter template name.
         */
        name: string;
        /**
         * The latest update time of the configuration.
         */
        updatedAt: string;
        /**
         * Specifies whether the parameter template is created by users.
         * The options are as follows:
         * + **false**: The parameter template is a default parameter template.
         * + **true**: The parameter template is a custom template.
         */
        userDefined: boolean;
    }

    export interface GetPgAccountsUser {
        /**
         * Indicates the permission attributes of a user.
         * The attributes structure is documented below.
         */
        attributes: outputs.Rds.GetPgAccountsUserAttribute[];
        /**
         * Indicates the remarks of the DB account.
         */
        description: string;
        /**
         * Indicates the default rights of a user.
         */
        memberofs: string[];
        /**
         * Indicates the username of the DB account.
         */
        name: string;
    }

    export interface GetPgAccountsUserAttribute {
        /**
         * Indicates whether a user bypasses each row-level security policy. The value can be **true** or **false**.
         */
        rolbypassrls: boolean;
        /**
         * Indicates whether a user can log in to the database. The value can be **true** or **false**.
         */
        rolcanlogin: boolean;
        /**
         * Indicates the maximum number of concurrent connections to a DB instance. The value **-1** indicates
         * that there are no limitations on the number of concurrent connections.
         */
        rolconnlimit: number;
        /**
         * Indicates whether a user can create a database. The value can be **true** or **false**.
         */
        rolcreatedb: boolean;
        /**
         * Indicates whether a user can create other sub-users. The value can be **true** or **false**.
         */
        rolcreaterole: boolean;
        /**
         * Indicates whether a user automatically inherits the permissions of the role to which the user belongs.
         * The value can be **true** or **false**.
         */
        rolinherit: boolean;
        /**
         * Indicates whether the user is a replication role. The value can be **true** or **false**.
         */
        rolreplication: boolean;
        /**
         * Indicates whether a user has the super user permission. The value is **false**.
         */
        rolsuper: boolean;
    }

    export interface GetPgDatabasesDatabase {
        /**
         * Specifies the character set used by the database.
         * For details, see [documentation](https://www.postgresql.org/docs/16/infoschema-character-sets.html).
         */
        characterSet: string;
        /**
         * Indicates the database description.
         */
        description: string;
        /**
         * Specifies the database collation.
         * For details, see [documentation](https://support.huaweicloud.com/intl/en-us/bestpractice-rds/rds_pg_0017.html).
         */
        lcCollate: string;
        /**
         * Specifies the database name.
         */
        name: string;
        /**
         * Specifies the database owner.
         */
        owner: string;
        /**
         * Specifies the database size, in bytes.
         */
        size: number;
    }

    export interface GetPgPluginsPlugin {
        /**
         * Specifies whether the plugin has been created. Defaults to: **false**.
         */
        created: boolean;
        /**
         * Indicates the plugin description.
         */
        description: string;
        /**
         * Specifies the plugin name.
         */
        name: string;
        /**
         * Indicates the dependent preloaded library.
         */
        sharedPreloadLibraries: string;
        /**
         * Specifies the plugin version.
         */
        version: string;
    }

    export interface GetPgSqlLimitsSqlLimit {
        /**
         * Indicates the ID of SQL limit.
         */
        id: string;
        /**
         * Specifies whether the SQL limit is effective.
         */
        isEffective: boolean;
        /**
         * Specifies the number of SQL statements executed simultaneously.
         */
        maxConcurrency: number;
        /**
         * Specifies the max waiting time in seconds.
         */
        maxWaiting: number;
        /**
         * Specifies the query ID.
         */
        queryId: string;
        /**
         * Specifies the text form of SQL statement.
         */
        queryString: string;
        /**
         * Specifies the query order for names that are not schema qualified.
         */
        searchPath: string;
    }

    export interface GetPredefinedTagsTag {
        /**
         * Indicates the key of a tag.
         */
        key: string;
        /**
         * Indicates the list the tag values.
         */
        values: string[];
    }

    export interface GetQuotasQuota {
        /**
         * Indicates the resource list objects.
         */
        resources: outputs.Rds.GetQuotasQuotaResource[];
    }

    export interface GetQuotasQuotaResource {
        /**
         * Indicates the project resource quota.
         */
        quota: number;
        /**
         * Indicates the project resource type. The value can be **instance**.
         */
        type: string;
        /**
         * Indicates the number of used resources.
         */
        used: number;
    }

    export interface GetRecyclingInstancesInstance {
        /**
         * Indicates the creation time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        createdAt: string;
        /**
         * Specifies the floating IP address.
         */
        dataVip: string;
        /**
         * Indicates the deletion time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        deletedAt: string;
        /**
         * Specifies the DB engine name.
         */
        engineName: string;
        /**
         * Specifies the DB engine version.
         */
        engineVersion: string;
        /**
         * Specifies the enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the instance type.
         * Value options: **Ha**, **Single**.
         */
        haMode: string;
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Specifies whether the instance is a serverless instance.
         * Value options: **true**, **false**.
         */
        isServerless: boolean;
        /**
         * Specifies the instance name.
         */
        name: string;
        /**
         * Specifies the billing mode.
         * Value options: **0** (pay-per-use), **1** (yearly/monthly).
         */
        payModel: string;
        /**
         * Specifies the backup ID.
         */
        recycleBackupId: string;
        /**
         * Specifies the backup status.
         * Value options:
         * + **BUILDING**: The instance is being backed up and cannot be rebuilt.
         * + **COMPLETED**: The backup is complete and the instance can be rebuilt.
         */
        recycleStatus: string;
        /**
         * Indicates the retention time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        retainedUntil: string;
        /**
         * Specifies the storage space in **GB**.
         * The value must be a multiple of **10** and the value range is from **40 GB** to **4,000 GB**.
         */
        volumeSize: number;
        /**
         * Specifies the storage type.
         * Value options:
         * + **ULTRAHIGH**: ultra-high I/O storage.
         * + **ULTRAHIGHPRO**: ultra-high I/O (advanced) storage.
         * + **CLOUDSSD**: cloud SSD storage.
         * + **LOCALSSD**: local SSD storage.
         */
        volumeType: string;
    }

    export interface GetRestoreTimeRangesRestoreTime {
        /**
         * Indicates the end time of the restoration time range in the UNIX timestamp format.
         * The unit is millisecond and the time zone is UTC.
         */
        endTime: number;
        /**
         * Indicates the start time of the restoration time range in the UNIX timestamp format.
         * The unit is millisecond and the time zone is UTC.
         */
        startTime: number;
    }

    export interface GetRestoredDatabasesInstance {
        /**
         * Indicates the database information.
         */
        databases: outputs.Rds.GetRestoredDatabasesInstanceDatabase[];
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the database name. Databases whose names contain Chinese characters will be filtered out and cannot
         * be restored.
         */
        name: string;
        /**
         * Indicates the total number of tables in the database.
         */
        totalTables: number;
    }

    export interface GetRestoredDatabasesInstanceDatabase {
        /**
         * Indicates the database name. Databases whose names contain Chinese characters will be filtered out and cannot
         * be restored.
         */
        name: string;
        /**
         * Indicates the total number of tables in the database.
         */
        totalTables: number;
    }

    export interface GetRestoredTablesInstance {
        /**
         * Indicates the database information.
         */
        databases: outputs.Rds.GetRestoredTablesInstanceDatabase[];
        /**
         * Indicates the instance ID.
         */
        id: string;
        /**
         * Indicates the table name.
         */
        name: string;
        /**
         * Indicates the number of tables that can be restored.
         */
        totalTables: number;
    }

    export interface GetRestoredTablesInstanceDatabase {
        /**
         * Indicates the table name.
         */
        name: string;
        /**
         * Indicates the schema information.
         * The schemas structure is documented below.
         */
        schemas: outputs.Rds.GetRestoredTablesInstanceDatabaseSchema[];
        /**
         * Indicates the number of tables that can be restored.
         */
        totalTables: number;
    }

    export interface GetRestoredTablesInstanceDatabaseSchema {
        /**
         * Indicates the table name.
         */
        name: string;
        /**
         * Indicates the table information.
         * The tables structure is documented below.
         */
        tables: outputs.Rds.GetRestoredTablesInstanceDatabaseSchemaTable[];
        /**
         * Indicates the number of tables that can be restored.
         */
        totalTables: number;
    }

    export interface GetRestoredTablesInstanceDatabaseSchemaTable {
        /**
         * Indicates the table name.
         */
        name: string;
    }

    export interface GetSlowLogFilesFile {
        /**
         * Indicates the file name.
         */
        fileName: string;
        /**
         * Indicates the file size in bytes.
         */
        fileSize: string;
    }

    export interface GetSlowLogsSlowLog {
        /**
         * Indicates the IP address of the client.
         */
        clientIp: string;
        /**
         * Indicates the number of execution times.
         */
        count: string;
        /**
         * Specifies the name of the database.
         */
        database: string;
        /**
         * Indicates the wait lock time.
         */
        lockTime: string;
        /**
         * Indicates the execution syntax.
         */
        querySample: string;
        /**
         * Indicates the number of rows scanned.
         */
        rowsExamined: string;
        /**
         * Indicates the number of result lines.
         */
        rowsSent: string;
        /**
         * Specifies the start time in the **yyyy-mm-ddThh:mm:ssZ** format.
         */
        startTime: string;
        /**
         * Indicates the execution time.
         */
        time: string;
        /**
         * Specifies the statement type. Value options: **INSERT**, **UPDATE**, **SELECT**,
         * **DELETE**, **CREATE**.
         */
        type: string;
        /**
         * Specifies the name of the account.
         */
        users: string;
    }

    export interface GetSqlAuditLogsAuditLog {
        /**
         * Indicates the start time of the audit log.
         */
        beginTime: string;
        /**
         * Specifies the end time in the **yyyy-mm-ddThh:mm:ssZ** format.
         * It must be later than the start time. The time span cannot be longer than 30 days.
         */
        endTime: string;
        /**
         * Indicates the ID of the audit log.
         */
        id: string;
        /**
         * Indicates the audit log file name.
         */
        name: string;
        /**
         * Indicates the size in KB of the audit log.
         */
        size: number;
    }

    export interface GetSqlAuditOperationsOperation {
        /**
         * Indicates the list of the operation actions.
         */
        actions: string[];
        /**
         * Indicates the type of the operation.
         */
        type: string;
    }

    export interface GetSqlserverAccountsUser {
        /**
         * Indicates the username of the database account.
         */
        name: string;
        /**
         * Specifies the database user status. Its value can be any of the following:
         * + **unavailable**: The database user is unavailable.
         * + **available**: The database user is available.
         */
        state: string;
    }

    export interface GetSqlserverDatabasePrivilegesUser {
        /**
         * The username of the database account.
         */
        name: string;
        /**
         * Specifies whether the database permission is **read-only**. Values option:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         */
        readonly: boolean;
    }

    export interface GetSqlserverDatabasesDatabase {
        /**
         * Specifies the character set used by the database.
         */
        characterSet: string;
        /**
         * Specifies the database name.
         */
        name: string;
        /**
         * Specifies the database status.
         */
        state: string;
    }

    export interface GetStorageTypesStorageType {
        /**
         * The status details of the AZs to which the specification belongs.
         * Key indicates the AZ ID, and value indicates the specification status in the AZ.
         * The options of value are as follows:
         * - **normal**: The specifications in the AZ are available.
         * - **unsupported**: The specifications are not supported by the AZ.
         * - **sellout**: The specifications in the AZ are sold out.
         */
        azStatus: {[key: string]: string};
        /**
         * Storage type.  
         * The options are as follows:
         * - **ULTRAHIGH**: SSD storage.
         * - **LOCALSSD**: Local SSD storage.
         * - **CLOUDSSD**: Cloud SSD storage.
         * This storage type is supported only with general-purpose and dedicated DB instances.
         * - **ESSD**: extreme SSD storage.
         * This storage type is supported only with dedicated DB instances.
         */
        name: string;
        /**
         * Performance specifications.
         * The options are as follows:
         * - **normal**: General-enhanced.
         * - **normal2**: General-enhanced II.
         * - **armFlavors**: Kunpeng general-enhanced.
         * - **dedicicatenormal**: Exclusive x86.
         * - **armlocalssd**: Standard Kunpeng.
         * - **normallocalssd**: Standard x86.
         * - **general**: General-purpose.
         * - **dedicated**: Dedicated, which is only supported for cloud SSDs.
         * - **rapid**: Dedicated, which is only supported for extreme SSDs.
         * - **bigmen**: Large-memory.
         */
        supportComputeGroupTypes: string[];
    }

    export interface GetTagsTag {
        /**
         * Indicates the tag key.
         */
        key: string;
        /**
         * Indicates the list the tag values.
         */
        values: string[];
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the retention days for specific backup files. The value range is from 0 to 732.
         */
        keepDays: number;
        /**
         * Specifies the backup cycle. Automatic backups will be performed on the specified days of
         * the week, except when disabling the automatic backup policy. The value range is a comma-separated number, where each
         * number represents a day of the week. For example, a value of 1,2,3,4 would set the backup cycle to Monday, Tuesday,
         * Wednesday, and Thursday. The default value is 1,2,3,4,5,6,7.
         */
        period: string;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the **hh:mm-HH:MM**
         * format. The current time is in the UTC format. The HH value must be 1 greater than the hh value. The values of mm and
         * MM must be the same and must be set to any of the following: 00, 15, 30, or 45. Example value: 08:15-09:15 23:00-00:
         * 00.
         */
        startTime: string;
    }

    export interface InstanceDb {
        /**
         * Specifies the database password. The value should contain 8 to 32 characters,
         * including uppercase and lowercase letters, digits, and the following special characters: ~!@#%^*-_=+? You are advised
         * to enter a strong password to improve security, preventing security risks such as brute force cracking.
         */
        password?: string;
        /**
         * Specifies the database port.
         * + The MySQL database port ranges from 1024 to 65535 (excluding 12017 and 33071, which are occupied by the RDS system
         * and cannot be used). The default value is 3306.
         * + The PostgreSQL database port ranges from 2100 to 9500. The default value is 5432.
         * + The Microsoft SQL Server database port can be 1433 or ranges from 2100 to 9500, excluding 5355 and 5985. The
         * default value is 1433.
         * + The MariaDB database port ranges from 1024 to 65535 (excluding 12017 and 33071, which are occupied by the RDS system
         * and cannot be used). The default value is 3306.
         */
        port: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + **ULTRAHIGH**: SSD storage.
         * + **LOCALSSD**: local SSD storage.
         * + **CLOUDSSD**: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + **ESSD**: extreme SSD storage.
         */
        type: string;
        userName: string;
        /**
         * Specifies the database version. Changing this parameter will create a new
         * resource. Available values detailed in
         * [DB Engines and Versions](https://support.huaweicloud.com/intl/en-us/productdesc-rds/en-us_topic_0043898356.html).
         */
        version: string;
    }

    export interface InstanceMsdtcHost {
        /**
         * Specifies the host name.
         */
        hostName: string;
        /**
         * Indicates the host ID.
         */
        id: string;
        /**
         * Specifies the host IP address.
         */
        ip: string;
    }

    export interface InstanceNode {
        /**
         * Specifies the list of AZ name. Changing this parameter will create a
         * new resource.
         */
        availabilityZone: string;
        /**
         * Indicates the host ID.
         */
        id: string;
        /**
         * Specifies the parameter name. Some of them needs the instance to be restarted
         * to take effect.
         */
        name: string;
        /**
         * Indicates the node type. The value can be master or slave, indicating the primary node or standby node
         * respectively.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface InstanceParameter {
        /**
         * Specifies the parameter name. Some of them needs the instance to be restarted
         * to take effect.
         */
        name: string;
        /**
         * Specifies the parameter value.
         */
        value: string;
    }

    export interface InstanceRestore {
        /**
         * Specifies the ID of the backup used to restore data. Changing this
         * parameter will create a new resource.
         */
        backupId: string;
        /**
         * Specifies the database to be restored. This parameter applies only to
         * Microsoft SQL Server databases. Changing this parameter will create a new resource.
         */
        databaseName?: {[key: string]: string};
        /**
         * Specifies the source DB instance ID. Changing this parameter will create
         * a new resource.
         */
        instanceId: string;
    }

    export interface InstanceVolume {
        /**
         * Specifies the key ID for disk encryption.
         * Changing this parameter will create a new resource.
         */
        diskEncryptionId: string;
        /**
         * Specifies the upper limit of automatic expansion of storage, in GB.
         */
        limitSize?: number;
        /**
         * Specifies the volume size. Its value range is from 40 GB to 4000 GB. The value must be a
         * multiple of 10 and greater than the original size.
         */
        size: number;
        /**
         * Specifies the threshold to trigger automatic expansion.  
         * If the available storage drops to this threshold or `10` GB, the automatic expansion is triggered.
         * The valid values are as follows:
         * + **10**
         * + **15**
         * + **20**
         */
        triggerThreshold?: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + **ULTRAHIGH**: SSD storage.
         * + **LOCALSSD**: local SSD storage.
         * + **CLOUDSSD**: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + **ESSD**: extreme SSD storage.
         */
        type: string;
    }

    export interface MysqlDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission. The value can be:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         */
        readonly: boolean;
    }

    export interface MysqlDatabaseTableRestoreDatabase {
        /**
         * Specifies the name of the table after restoration.
         */
        newName: string;
        /**
         * Specifies the name of the table before restoration.
         */
        oldName: string;
    }

    export interface MysqlDatabaseTableRestoreRestoreTable {
        /**
         * Specifies the database name.
         */
        database: string;
        /**
         * Specifies the tables.
         * The tables structure is documented below.
         */
        tables: outputs.Rds.MysqlDatabaseTableRestoreRestoreTableTable[];
    }

    export interface MysqlDatabaseTableRestoreRestoreTableTable {
        /**
         * Specifies the name of the table after restoration.
         */
        newName: string;
        /**
         * Specifies the name of the table before restoration.
         */
        oldName: string;
    }

    export interface MysqlProxyMasterNodeWeight {
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Specifies the weight assigned to the node.
         * + If `routeMode` is `0`, the value is `0` to `1,000`.
         * + If `routeMode` is `1`, the value for the primary node is `0` and the value for read replicas is `0` or `1`.
         * + If `routeMode` is `2`, the value for the primary node is `1` and the value for read replicas is `0` or `1`.
         */
        weight: number;
    }

    export interface MysqlProxyNode {
        /**
         * Indicates the AZ where the proxy node is located.
         */
        azCode: string;
        /**
         * Indicates whether the proxy node is frozen. The values can be:
         * + **0**: unfrozen.
         * + **1**: frozen.
         */
        frozenFlag: number;
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Indicates the role of the proxy node. The values can be:
         * + **master**: primary node.
         * + **slave**: standby node.
         */
        role: string;
        /**
         * Indicates the proxy node status. The values can be:
         * + **NORMAL**: The node is normal.
         * + **ABNORMAL**: The node is abnormal.
         * + **CREATING**: The node is being created.
         * + **CREATEFAIL**: The node failed to be created.
         */
        status: string;
    }

    export interface MysqlProxyReadonlyNodesWeight {
        /**
         * Specifies the ID of the node.
         */
        id: string;
        /**
         * Specifies the weight assigned to the node.
         * + If `routeMode` is `0`, the value is `0` to `1,000`.
         * + If `routeMode` is `1`, the value for the primary node is `0` and the value for read replicas is `0` or `1`.
         * + If `routeMode` is `2`, the value for the primary node is `1` and the value for read replicas is `0` or `1`.
         */
        weight: number;
    }

    export interface ParametergroupConfigurationParameter {
        /**
         * The parameter group description. It contains a maximum of 256 characters and cannot
         * contain the following special characters:>!<"&'= the value is left blank by default.
         */
        description: string;
        /**
         * The parameter group name. It contains a maximum of 64 characters.
         */
        name: string;
        /**
         * Indicates whether the parameter is read-only.
         */
        readonly: boolean;
        /**
         * Indicates whether a restart is required.
         */
        restartRequired: boolean;
        /**
         * The DB engine. Currently, MySQL, PostgreSQL, Microsoft SQL Server and MariaDB are supported.
         * The value is case-insensitive and can be **mysql**, **postgresql**, **sqlserver**, or **mariadb**.
         */
        type: string;
        /**
         * Indicates the parameter value.
         */
        value: string;
        /**
         * Indicates the parameter value range.
         */
        valueRange: string;
    }

    export interface ParametergroupDatastore {
        /**
         * The DB engine. Currently, MySQL, PostgreSQL, Microsoft SQL Server and MariaDB are supported.
         * The value is case-insensitive and can be **mysql**, **postgresql**, **sqlserver**, or **mariadb**.
         */
        type: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface PgAccountAttribute {
        /**
         * Indicates whether a user bypasses each row-level security policy.
         */
        rolBypassRls: boolean;
        /**
         * Indicates whether a user can log in to the database.
         */
        rolCanLogin: boolean;
        /**
         * Indicates the maximum number of concurrent connections to a DB instance.
         */
        rolConnLimit: number;
        /**
         * Indicates whether a user can create a database.
         */
        rolCreateDb: boolean;
        /**
         * Indicates whether a user can create other sub-users.
         */
        rolCreateRole: boolean;
        /**
         * Indicates whether a user automatically inherits the permissions of the role to which the user belongs.
         */
        rolInherit: boolean;
        /**
         * Indicates whether the user is a replication role.
         */
        rolReplication: boolean;
        /**
         * Indicates whether a user has the super-user permission.
         */
        rolSuper: boolean;
    }

    export interface PgDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission. The value can be:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         */
        readonly: boolean;
        /**
         * Specifies the name of the schema.
         */
        schemaName: string;
    }

    export interface PgHbaHostBasedAuthentication {
        /**
         * Specifies the client IP address.
         * + **0.0.0.0/0** indicates that the user can access the database from any IP address.
         */
        address: string;
        /**
         * Specifies the database name other than **template0** and **template1**.
         * + **all** indicates all databases of the DB instance.
         * + Use commas (,) to separate multiple databases.
         */
        database: string;
        /**
         * Specifies the subnet mask. It is mandatory when `address` does not contain mask.
         */
        mask: string;
        /**
         * Specifies the authentication mode. Value options: **reject**, **md5** and
         * **scram-sha-256**.
         */
        method: string;
        /**
         * Specifies the connection type. Value options: **host**, **hostssl** and **hostnossl**.
         */
        type: string;
        /**
         * Specifies the name of a user other than **rdsAdmin**, **rdsMetric**, **rdsBackup**,
         * **rdsRepl** and **rdsProxy**.
         * + **all** indicates all database users of the DB instance.
         * + Use commas (,) to separate multiple user names.
         */
        user: string;
    }

    export interface ReadReplicaInstanceDb {
        /**
         * Specifies the database port.
         * + The MySQL database port ranges from `1,024` to `65,535` (excluding `12,017` and `33,071`, which are occupied by
         * the RDS system and cannot be used). The default value is `3,306`.
         * + The PostgreSQL database port ranges from `2,100` to `9,500`. The default value is `5,432`.
         * + The Microsoft SQL Server database port can be `1,433` or ranges from `2,100` to `9,500`, excluding `5,355` and
         * `5,985`. The default value is `1,433`.
         */
        port: number;
        /**
         * Specifies the volume type. It must same with the type of the primary instance.
         * Its value can be any of the following and is case-sensitive:
         * + **ULTRAHIGH**: SSD storage.
         * + **LOCALSSD**: local SSD storage.
         * + **CLOUDSSD**: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + **ESSD**: extreme SSD storage.
         */
        type: string;
        userName: string;
        version: string;
    }

    export interface ReadReplicaInstanceParameter {
        /**
         * Specifies the parameter name. Some of them needs the instance to be restarted
         * to take effect.
         */
        name: string;
        /**
         * Specifies the parameter value.
         */
        value: string;
    }

    export interface ReadReplicaInstanceVolume {
        diskEncryptionId: string;
        /**
         * Specifies the upper limit of automatic expansion of storage, in GB.
         */
        limitSize?: number;
        /**
         * Specifies the volume size. Its value range is from `40` GB to `4,000` GB. The value must
         * be a multiple of 10 and greater than the original size.
         */
        size: number;
        /**
         * Specifies the threshold to trigger automatic expansion.  
         * If the available storage drops to this threshold or `10` GB, the automatic expansion is triggered.
         * The valid values are as follows:
         * + **10**
         * + **15**
         * + **20**
         */
        triggerThreshold?: number;
        /**
         * Specifies the volume type. It must same with the type of the primary instance.
         * Its value can be any of the following and is case-sensitive:
         * + **ULTRAHIGH**: SSD storage.
         * + **LOCALSSD**: local SSD storage.
         * + **CLOUDSSD**: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + **ESSD**: extreme SSD storage.
         */
        type: string;
    }

    export interface SqlserverDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission. Value options:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         */
        readonly: boolean;
    }
}

export namespace Scm {
    export interface CertificateAuthentification {
        /**
         * Domain name mapping to the verification value
         */
        domain: string;
        /**
         * Name of a domain ownership verification value.
         */
        recordName: string;
        /**
         * Type of the domain name verification value.
         */
        recordType: string;
        /**
         * Domain verification value.
         */
        recordValue: string;
    }

    export interface CertificateTarget {
        /**
         * Specifies the project where the service you want to push a certificate to. The same certificate
         * can be pushed repeatedly to the same WAF or ELB service in the same `project`, but the CDN service can only be pushed
         * once.
         */
        projects?: string[];
        /**
         * Specifies the service to which the certificate is pushed. The options include `CDN`,`WAF`
         * and `ELB`.
         */
        service: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Certificate authority.  
         * The value can be: **GLOBALSIGN**, **SYMANTEC**, **GEOTRUST**, **CFCA**.
         */
        brand: string;
        /**
         * Whether to support deployment.
         */
        deploySupport: boolean;
        /**
         * Certificate description.
         */
        description: string;
        /**
         * Domain name associated with the certificate.
         */
        domain: string;
        /**
         * Number of domain names that can be associated with the certificate.
         */
        domainCount: number;
        /**
         * Domain name type.  
         * The options are as follows:
         * - SINGLE_DOMAIN: Single domain names
         * - WILDCARD: Wildcard domain names
         * - MULTI_DOMAIN: Multiple domain names
         */
        domainType: string;
        /**
         * The enterprise project id of the project.
         */
        enterpriseProjectId: string;
        /**
         * Certificate expiration time.
         */
        expireTime: string;
        /**
         * Certificate ID.
         */
        id: string;
        /**
         * Certificate name.
         */
        name: string;
        /**
         * Additional domain name associated with the certificate.
         */
        sans: string;
        /**
         * Signature algorithm.
         */
        signatureAlgorithm: string;
        /**
         * Certificate status.  
         * The options are as follows:
         * - ALL: All certificate status.
         * - PAID: The certificate has been paid and needs to be applied for from the CA.
         * - ISSUED: The certificate has been issued.
         * - CHECKING: The certificate application is being reviewed.
         * - CANCELCHECKING: The certificate application cancellation is being reviewed.
         * - UNPASSED: The certificate application fails.
         * - EXPIRED: The certificate has expired.
         * - REVOKING: The certificate revocation application is being reviewed.
         * - REVOKED: The certificate has been revoked.
         * - UPLOAD: The certificate is being managed.
         * - CHECKING_ORG: The organization verification is to be completed.
         * - ISSUING: The certificate is to be issued.
         * - SUPPLEMENTCHECKING: Additional domain names to be added for a multi-domain certificate are being reviewed.
         */
        status: string;
        /**
         * Certificate type.  
         * The value can be: **DV_SSL_CERT**, **DV_SSL_CERT_BASIC**, **EV_SSL_CERT**, **EV_SSL_CERT_PRO**, **OV_SSL_CERT**, **OV_SSL_CERT_PRO**.
         */
        type: string;
        /**
         * Certificate validity period, in months.
         */
        validityPeriod: number;
        /**
         * Number of wildcard domain names that can be associated with the certificate.
         */
        wildcardCount: number;
    }

}

export namespace ServiceStage {
    export interface ApplicationEnvironment {
        /**
         * Specifies the environment ID to which the variables belongs.
         */
        id: string;
        /**
         * Specifies the list of environment variables.
         * The object structure is documented below.
         */
        variables: outputs.ServiceStage.ApplicationEnvironmentVariable[];
    }

    export interface ApplicationEnvironmentVariable {
        /**
         * Specifies the variable name. The name can contain `1` to `64` characters, only letters,
         * digits, underscores (_), hyphens (-) and dots (.) are allowed. The name cannot start with a digit or dot.
         */
        name: string;
        /**
         * Specifies the variable value. The value can contain a maximum of `2,048` characters.
         */
        value: string;
    }

    export interface ComponentBuilder {
        /**
         * Specifies the cluster ID.
         */
        clusterId: string;
        /**
         * Specifies the cluster Name.
         */
        clusterName: string;
        /**
         * Specifies the cluster type.
         */
        clusterType: string;
        /**
         * Specifies the build command. If omitted, the default command will be used.
         * + About the  default command or script: build.sh in the root directory will be preferentially executed.
         * If build.sh does not exist, the code will be compiled using the common method of the selected language,
         * for example, mvn clean package for Java.
         * + About the custom command: Commands will be customized using the selected language.
         * Alternatively, the default command or script will be used after build.sh is modified.
         */
        cmd: string;
        /**
         * Specifies the file path for dockerfile.
         */
        dockerfilePath: string;
        /**
         * Specifies the filter labels for CCE nodes.
         */
        nodeLabel?: {[key: string]: string};
        /**
         * Specifies the organization name.
         * The organization is usually **domain name**. You can find out in the organization management of SWR.
         */
        organization: string;
        /**
         * Specifies whether to use the public cluster.
         */
        usePublicCluster: boolean;
    }

    export interface ComponentInstanceArtifact {
        /**
         * Specifies the authentication mode.
         * The valid values are **iam** and **none**. Defaults to **iam**.
         */
        authType?: string;
        /**
         * Specifies the configuration item.
         */
        name: string;
        /**
         * Specifies the properties of the OBS object.
         * This parameter is available only `storage` is **obs**.
         * The object structure is documented below.
         */
        properties: outputs.ServiceStage.ComponentInstanceArtifactProperties;
        /**
         * Specifies the data storage configuration.
         * The object structure is documented below.
         */
        storage: string;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
        /**
         * Specifies the software package or image address.
         * For a component deployed on a VM, this parameter is the software package address.
         * For a component deployed based on a container, this parameter is the image address or component name:v${index}.
         * The latter indicates that the component source code or the image automatically built using the software package
         * will be used.
         */
        url: string;
        /**
         * Specifies the version number.
         */
        version: string;
    }

    export interface ComponentInstanceArtifactProperties {
        /**
         * Specifies the OBS bucket name.
         */
        bucket: string;
        /**
         * Specifies the OBS bucket endpoint.
         */
        endpoint: string;
        /**
         * Specifies the key name of the OBS object.
         */
        key: string;
    }

    export interface ComponentInstanceConfiguration {
        /**
         * Specifies the environment variables.
         * The object structure is documented below.
         */
        envVariables: outputs.ServiceStage.ComponentInstanceConfigurationEnvVariable[];
        /**
         * Specifies the lifecycle.
         * The object structure is documented below.
         */
        lifecycle: outputs.ServiceStage.ComponentInstanceConfigurationLifecycle;
        /**
         * Specifies the policies of the log collection.
         * The object structure is documented below.
         */
        logCollectionPolicies: outputs.ServiceStage.ComponentInstanceConfigurationLogCollectionPolicy[];
        /**
         * Specifies the variable value.
         * The object structure is documented below.
         */
        probe: outputs.ServiceStage.ComponentInstanceConfigurationProbe;
        /**
         * Specifies the scheduling policy.
         * The key indicates the component name. In the Docker container scenario, key indicates the container name.
         * If the source parameters of a component specify the software package source, this parameter is optional, and the
         * software package source of the component is inherited by default. Otherwise, this parameter is required.
         * The object structure is documented below.
         */
        scheduler: outputs.ServiceStage.ComponentInstanceConfigurationScheduler;
        /**
         * Specifies the data storage configuration.
         * The object structure is documented below.
         */
        storages: outputs.ServiceStage.ComponentInstanceConfigurationStorage[];
        /**
         * Specifies the upgrade policy.
         * The object structure is documented below.
         */
        strategy: outputs.ServiceStage.ComponentInstanceConfigurationStrategy;
    }

    export interface ComponentInstanceConfigurationEnvVariable {
        /**
         * Specifies the configuration item.
         */
        name: string;
        /**
         * Specifies the variable value.
         */
        value: string;
    }

    export interface ComponentInstanceConfigurationLifecycle {
        /**
         * Specifies the startup commands.
         * The object structure is documented below.
         */
        entrypoint: outputs.ServiceStage.ComponentInstanceConfigurationLifecycleEntrypoint;
        /**
         * Specifies the post-start processing.
         * The object structure is documented below.
         */
        postStart: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePostStart;
        /**
         * Specifies the pre-stop processing.
         * The object structure is documented below.
         */
        preStop: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePreStop;
    }

    export interface ComponentInstanceConfigurationLifecycleEntrypoint {
        /**
         * Specifies the running parameters.
         */
        args: string[];
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationLifecyclePostStart {
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePostStartParameters;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationLifecyclePostStartParameters {
        /**
         * Specifies the command list.
         */
        commands: string[];
        /**
         * Specifies the custom IP address. The default address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationLifecyclePreStop {
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePreStopParameters;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationLifecyclePreStopParameters {
        /**
         * Specifies the command list.
         */
        commands: string[];
        /**
         * Specifies the custom IP address. The default address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationLogCollectionPolicy {
        /**
         * Specifies the configurations of the container mounting.
         * The object structure is documented below.
         */
        containerMountings: outputs.ServiceStage.ComponentInstanceConfigurationLogCollectionPolicyContainerMounting[];
        /**
         * Specifies the The host path that will be mounted to the specified container path.
         */
        hostPath?: string;
    }

    export interface ComponentInstanceConfigurationLogCollectionPolicyContainerMounting {
        /**
         * Specifies the aging period.
         * The valid values are **Hourly**, **Daily** and **Weekly**. The default value is **Hourly**.
         */
        agingPeriod?: string;
        /**
         * Specifies the extended host path.
         * This parameter can be configured only when `hostPath` is configured.
         * The valid values are as follows:
         * + **PodUID**
         * + **PodName**
         * + **PodUID/ContainerName**
         * + **PodName/ContainerName**
         */
        hostExtendPath?: string;
        /**
         * Specifies the request path.
         */
        path: string;
    }

    export interface ComponentInstanceConfigurationProbe {
        /**
         * Specifies the component liveness probe.
         * The object structure is documented below.
         */
        liveness: outputs.ServiceStage.ComponentInstanceConfigurationProbeLiveness;
        /**
         * Specifies the component service probe.
         * The object structure is documented below.
         */
        readiness: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadiness;
    }

    export interface ComponentInstanceConfigurationProbeLiveness {
        /**
         * Specifies the commands. Required if `type` is **command**.
         * The object structure is documented below.
         */
        commandParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessCommandParam;
        /**
         * Specifies the interval between the startup and detection.
         */
        delay: number;
        /**
         * Specifies the commands. Required if `type` is **http**.
         * The object structure is documented below.
         */
        httpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessHttpParam;
        /**
         * Specifies the commands. Required if `type` is **tcp**.
         * The object structure is documented below.
         */
        tcpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessTcpParam;
        /**
         * Specifies the detection timeout interval.
         */
        timeout: number;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationProbeLivenessCommandParam {
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationProbeLivenessHttpParam {
        /**
         * Specifies the custom IP address. The default address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol scheme. The valid values are **HTTP** and **HTTPS**.
         */
        scheme: string;
    }

    export interface ComponentInstanceConfigurationProbeLivenessTcpParam {
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationProbeReadiness {
        /**
         * Specifies the commands. Required if `type` is **command**.
         * The object structure is documented below.
         */
        commandParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessCommandParam;
        /**
         * Specifies the interval between the startup and detection.
         */
        delay: number;
        /**
         * Specifies the commands. Required if `type` is **http**.
         * The object structure is documented below.
         */
        httpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessHttpParam;
        /**
         * Specifies the commands. Required if `type` is **tcp**.
         * The object structure is documented below.
         */
        tcpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessTcpParam;
        /**
         * Specifies the detection timeout interval.
         */
        timeout: number;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationProbeReadinessCommandParam {
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationProbeReadinessHttpParam {
        /**
         * Specifies the custom IP address. The default address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol scheme. The valid values are **HTTP** and **HTTPS**.
         */
        scheme: string;
    }

    export interface ComponentInstanceConfigurationProbeReadinessTcpParam {
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationScheduler {
        /**
         * Specifies the commands.
         * The object structure is documented below.
         */
        affinity: outputs.ServiceStage.ComponentInstanceConfigurationSchedulerAffinity;
        /**
         * Specifies the commands.
         * The object structure is documented below.
         */
        antiAffinity: outputs.ServiceStage.ComponentInstanceConfigurationSchedulerAntiAffinity;
    }

    export interface ComponentInstanceConfigurationSchedulerAffinity {
        /**
         * Specifies the AZ list.
         */
        availabilityZones: string[];
        /**
         * Specifies the list of component instance names.
         */
        instanceNames: string[];
        /**
         * Specifies the node private IP address list.
         */
        privateIps: string[];
    }

    export interface ComponentInstanceConfigurationSchedulerAntiAffinity {
        /**
         * Specifies the AZ list.
         */
        availabilityZones: string[];
        /**
         * Specifies the list of component instance names.
         */
        instanceNames: string[];
        /**
         * Specifies the node private IP address list.
         */
        privateIps: string[];
    }

    export interface ComponentInstanceConfigurationStorage {
        /**
         * Specifies the directory mounted to the container.
         * The object structure is documented below.
         */
        mounts: outputs.ServiceStage.ComponentInstanceConfigurationStorageMount[];
        /**
         * Specifies the storage parameters.
         * The object structure is documented below.
         */
        parameter: outputs.ServiceStage.ComponentInstanceConfigurationStorageParameter;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationStorageMount {
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the mounted disk permission is read-only or read-write.
         * + **true**: read-only.
         * + **false**: read-write.
         */
        readonly: boolean;
        /**
         * Specifies the subpath of the mounted disk.
         * This parameter is applicable to `http` type.
         */
        subpath: string;
    }

    export interface ComponentInstanceConfigurationStorageParameter {
        /**
         * Specifies the PVC name.
         */
        claimName: string;
        /**
         * Specifies the configuration item.
         */
        name: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the Secret name. Required if the storage `type` is **Secret**.
         */
        secretName: string;
    }

    export interface ComponentInstanceConfigurationStrategy {
        /**
         * Specifies the upgrade policy.
         * The valid values are **Recreate** or **RollingUpdate**. The default value is **RollingUpdate**.
         * The **Recreate** indicates in-place upgrade while the **RollingUpdate** indicates rolling upgrade.
         */
        upgrade?: string;
    }

    export interface ComponentInstanceExternalAccess {
        /**
         * Specifies the access address. For example: `www.example.com`.
         */
        address: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol. The valid values are **HTTP** and **HTTPS**.
         */
        protocol: string;
    }

    export interface ComponentInstanceReferResource {
        /**
         * Specifies the application alias, which is provided only in DCS scenario.
         * The valid values are: **distributed_session**, **distributed_cache** and **distributed_session, distributed_cache**.
         * Defaults to **distributed_session, distributed_cache**.
         */
        alias: string;
        /**
         * Specifies the resource ID.
         * If the `type` is set to **ecs**, the value of this parameter must be **Default**.
         */
        id: string;
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: {[key: string]: string};
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentSource {
        /**
         * Specifies the authorization name.
         * This parameter and `storageType` are alternative.
         */
        authorization: string;
        /**
         * Specifies the component builder's properties.
         * The object structure is documented below.
         */
        properties: outputs.ServiceStage.ComponentSourceProperties;
        /**
         * Specifies the namespace name.
         */
        repoNamespace?: string;
        /**
         * Specifies the name of the branch of the code repository.
         * The default value is `master`.
         */
        repoRef?: string;
        /**
         * Specifies the storage type, such as **obs**, **swr**.
         * This parameter is conflict with `repoRef` and `repoNamespace`.
         */
        storageType: string;
        /**
         * Specifies the type of repository source or storage.
         * The valid values are **GitHub**, **GitLab**, **Gitee**, **Bitbucket** and **package**.
         */
        type: string;
        /**
         * Specifies the URL of the repository or package storage.
         */
        url: string;
    }

    export interface ComponentSourceProperties {
        /**
         * Specifies the bucket name of obs.
         */
        bucket: string;
        /**
         * Specifies the endpoint of obs.
         */
        endpoint: string;
        /**
         * Specifies the key of obs.
         */
        key: string;
    }

    export interface EnvironmentBasicResource {
        /**
         * Specifies the resource ID. For most resources, this parameter needs to fill in their **id**,
         * but for CCI namespace, this parameter needs to fill in **name**.
         */
        id: string;
        /**
         * Specifies the resource type.
         * + The type of basic resource supports **cce**, **cci**, **ecs** and **as**.
         * + The type of optional resource supports **elb**, **eip**, **rds**, **dcs** and **cse**.
         */
        type: string;
    }

    export interface EnvironmentOptionalResource {
        /**
         * Specifies the resource ID. For most resources, this parameter needs to fill in their **id**,
         * but for CCI namespace, this parameter needs to fill in **name**.
         */
        id: string;
        /**
         * Specifies the resource type.
         * + The type of basic resource supports **cce**, **cci**, **ecs** and **as**.
         * + The type of optional resource supports **elb**, **eip**, **rds**, **dcs** and **cse**.
         */
        type: string;
    }

    export interface GetComponentRuntimesRuntime {
        /**
         * Specifies the default container port to use for filtering.
         */
        defaultPort: number;
        /**
         * The runtime description.
         */
        description: string;
        /**
         * Specifies the runtime name to use for filtering.
         * For the runtime names corresponding to each type of component, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-servicestage/servicestage_user_0411.html).
         */
        name: string;
    }

}

export namespace Sfs {
    export interface FileSystemAccessRule {
        /**
         * Specifies the access level of the shared file system. Possible values are *ro* (
         * read-only)
         * and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
         */
        accessLevel: string;
        /**
         * The UUID of the share access rule.
         */
        accessRuleId: string;
        /**
         * Specifies the value that defines the access rule. The value contains 1 to 255
         * characters. Changing this will create a new access rule. The value varies according to the scenario:
         * + Set the VPC ID in VPC authorization scenarios.
         * + Set this parameter in IP address authorization scenario:
         * - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
         * - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.
         */
        accessTo: string;
        /**
         * Specifies the type of the share access rule. The default value is *cert*. Changing
         * this will create a new access rule.
         */
        accessType: string;
        /**
         * The status of the share access rule.
         */
        status: string;
    }

    export interface GetTurbosTurbo {
        /**
         * The availability zone where the SFS turbo file system is located.
         */
        availabilityZone: string;
        /**
         * The available capacity of the SFS turbo file system, in GB.
         */
        availableCapacity: string;
        /**
         * The ID of a KMS key to encrypt the SFS turbo file system.
         */
        cryptKeyId: string;
        /**
         * Whether the SFS turbo file system is enhanced.
         */
        enhanced: boolean;
        /**
         * The enterprise project ID of the SFS turbo file system.
         */
        enterpriseProjectId: string;
        /**
         * The mount point of the SFS turbo file system.
         */
        exportLocation: string;
        /**
         * The data source ID of the SFS turbo file system.
         */
        id: string;
        /**
         * Specifies the name of the SFS turbo file system.
         */
        name: string;
        /**
         * The ID of the security group to which the SFS turbo belongs.
         */
        securityGroupId: string;
        /**
         * Specifies the protocol of the SFS turbo file system. The valid value is **NFS**.
         */
        shareProto: string;
        /**
         * Specifies the type of the SFS turbo file system.
         * The valid values are **STANDARD** and **PERFORMANCE**.
         */
        shareType: string;
        /**
         * Specifies the capacity of the SFS turbo file system, in GB.
         * The value ranges from `500` to `32,768`, and must be large than `10,240` for an enhanced file system.
         */
        size: number;
        /**
         * The **network ID** of the subnet to which the SFS turbo belongs.
         */
        subnetId: string;
        /**
         * The version of the SFS turbo file system.
         */
        version: string;
        /**
         * The ID of the VPC to which the SFS turbo belongs.
         */
        vpcId: string;
    }

}

export namespace SharedApig {
    export interface ApiBackendParameter {
        /**
         * Specifies the description of the parameter. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the parameter location, which can be 'PATH', 'QUERY' or 'HEADER'.
         */
        location: string;
        /**
         * Specifies the parameter name. A parameter name consists of 132 characters, starting with
         * a letter. Only letters, digits, periods (.), hyphens (-), and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the parameter type, which can be 'REQUEST', 'CONSTANT', or 'SYSTEM'.
         */
        type?: string;
        /**
         * Specifies the parameter value, which is a string of not more than 255 characters. The
         * value varies depending on the parameter type:
         * + 'REQUEST': parameter name in `requestParameter`
         * + 'CONSTANT': real value of the parameter
         * + 'SYSTEM': gateway parameter name
         */
        value: string;
    }

    export interface ApiFunctionBackend {
        /**
         * Specifies the function URN.
         */
        functionUrn: string;
        /**
         * Specifies the invocation mode, which can be 'async' or 'sync'.
         */
        invocationType: string;
        /**
         * Timeout duration (in ms) for API Gateway to request for FunctionGraph. Defaults to 50000.
         */
        timeout?: number;
        /**
         * Specifies the function version.
         */
        version: string;
    }

    export interface ApiHttpBackend {
        /**
         * Specifies the backend request method, including 'GET','POST','PUT' and etc..
         */
        method: string;
        /**
         * Specifies the backend request protocol. The value can be 'HTTP' and 'HTTPS'.
         */
        protocol: string;
        /**
         * Timeout duration (in ms) for API Gateway to request for the backend service. Defaults to
         * 50000.
         */
        timeout?: number;
        /**
         * Specifies the backend request path. The value must comply with URI specifications.
         */
        uri: string;
        /**
         * Specifies the backend service address. An endpoint URL is in the format of
         * "domain name (or IP address):port number", with up to 255 characters. This parameter and `vpcChannel` are
         * alternative.
         */
        urlDomain?: string;
        /**
         * Specifies the VPC channel ID. This parameter and `urlDomain` are alternative.
         */
        vpcChannel?: string;
    }

    export interface ApiMockBackend {
        /**
         * Specifies the description of the Mock backend. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the return result.
         */
        resultContent?: string;
        /**
         * Specifies the version of the Mock backend.
         */
        version?: string;
    }

    export interface ApiRequestParameter {
        /**
         * Specifies the default value when the parameter is optional.
         */
        default?: string;
        /**
         * Specifies the description of the parameter. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the input parameter location, which can be 'PATH', 'QUERY' or 'HEADER'.
         */
        location: string;
        /**
         * Specifies the input parameter name. A parameter name consists of 132 characters, starting
         * with a letter. Only letters, digits, periods (.), hyphens (-), and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies whether the parameter is mandatory or not.
         */
        required: boolean;
        /**
         * Specifies the input parameter type, which can be 'STRING' or 'NUMBER'.
         */
        type: string;
    }

}

export namespace Smn {
    export interface GetTopicsTopic {
        /**
         * Specifies the topic display name.
         */
        displayName: string;
        /**
         * Specifies the enterprise project ID of the SMN topic.
         */
        enterpriseProjectId: string;
        /**
         * The topic ID. The value is the topic URN.
         */
        id: string;
        /**
         * Specifies the name of the topic.
         */
        name: string;
        /**
         * Message pushing policy.
         * + **0**: indicates that the message sending fails and the message is cached in the queue.
         * + **1**: indicates that the failed message is discarded.
         */
        pushPolicy: number;
        /**
         * The tags of the SMN topic, key/value pair format.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the topic URN.
         */
        topicUrn: string;
    }

    export interface SubscriptionExtension {
        /**
         * Specifies the client ID. This field is the tenant ID field in
         * the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
         * is set to **welink**. Changing this parameter will create a new resource.
         */
        clientId?: string;
        /**
         * Specifies the client secret. This field is the client secret
         * field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
         * Changing this parameter will create a new resource.
         */
        clientSecret?: string;
        /**
         * Specifies the keyword. When `protocol` is set to **feishu**,
         * either `keyword` or `signSecret` must be specified. When you use `keywords` to configure a security policy
         * for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
         * or DingTalk client. Changing this parameter will create a new resource.
         */
        keyword?: string;
        /**
         * Specifies the key including signature. When `protocol` is set
         * to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
         * the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
         * enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
         * Changing this parameter will create a new resource.
         */
        signSecret?: string;
    }

    export interface SubscriptionFilterPolicy {
        /**
         * The filter policy name.
         */
        name: string;
        /**
         * The string array for exact match.
         */
        stringEquals: string[];
    }

}

export namespace Sms {
    export interface GetSourceServersServer {
        /**
         * The version of Agent installed on the source server.
         */
        agentVersion: string;
        /**
         * Whether the source server is properly connected to SMS.
         */
        connected: boolean;
        /**
         * The disk information of the source server. Structure is documented below.
         */
        disks: outputs.Sms.GetSourceServersServerDisk[];
        /**
         * Specifies the ID of the source server.
         */
        id: string;
        /**
         * Specifies the IP address of the source server.
         */
        ip: string;
        /**
         * The memory size in MB.
         */
        memory: number;
        /**
         * Specifies the name of the source server.
         */
        name: string;
        /**
         * The OS type of the source server. The value can be **WINDOWS** and **LINUX**.
         */
        osType: string;
        /**
         * The OS version of the source server, for example, UBUNTU_20_4_64BIT.
         */
        osVersion: string;
        /**
         * The UTC time when the source server is registered.
         */
        registeredTime: string;
        /**
         * Specifies the status of the source server.
         */
        state: string;
        /**
         * The vcpus count of the source server.
         */
        vcpus: number;
    }

    export interface GetSourceServersServerDisk {
        /**
         * The disk type. The value can be **BOOT**, **OS** and **NORMAL**.
         */
        deviceType: string;
        /**
         * Specifies the name of the source server.
         */
        name: string;
        /**
         * The disk size in MB.
         */
        size: number;
    }

    export interface TaskTargetServerDisk {
        /**
         * Specifies the partition type. The value can be **NORMAL** and **OS**.
         * Changing this parameter will create a new resource.
         */
        deviceType: string;
        /**
         * Specifies the disk index, e.g. "0".
         * Changing this parameter will create a new resource.
         */
        diskId: string;
        /**
         * Specifies the volume name. In Windows, it indicates the drive letter,
         * and in Linux, it indicates the device ID, e.g. "/dev/sda1".
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies an array of physical volume information.
         * The object is documented below. Changing this parameter will create a new resource.
         */
        physicalVolumes?: outputs.Sms.TaskTargetServerDiskPhysicalVolume[];
        /**
         * Specifies the volume size in MB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the used space in MB.
         * Changing this parameter will create a new resource.
         */
        usedSize: number;
    }

    export interface TaskTargetServerDiskPhysicalVolume {
        /**
         * Specifies the partition type. The value can be **NORMAL** and **OS**.
         * Changing this parameter will create a new resource.
         */
        deviceType: string;
        /**
         * Specifies the file system type, e.g. "ext4".
         * Changing this parameter will create a new resource.
         */
        fileSystem: string;
        /**
         * Specifies the serial number of the volume.
         * Changing this parameter will create a new resource.
         */
        index: number;
        /**
         * Specifies the mount point, e.g. "/".
         * Changing this parameter will create a new resource.
         */
        mountPoint: string;
        /**
         * Specifies the volume name. In Windows, it indicates the drive letter,
         * and in Linux, it indicates the device ID, e.g. "/dev/sda1".
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the volume size in MB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the used space in MB.
         * Changing this parameter will create a new resource.
         */
        usedSize: number;
        /**
         * Specifies the GUID of the volume.
         * Changing this parameter will create a new resource.
         */
        uuid: string;
    }

}

export namespace Swr {
    export interface OrganizationPermissionsSelfPermission {
        /**
         * Specifies the permission of the existing HuaweiCloud user.
         * The values can be **Manage**, **Write** and **Read**.
         */
        permission: string;
        /**
         * Specifies the ID of the existing HuaweiCloud user.
         */
        userId: string;
        /**
         * Specifies the name of the existing HuaweiCloud user.
         */
        userName: string;
    }

    export interface OrganizationPermissionsUser {
        /**
         * Specifies the permission of the existing HuaweiCloud user.
         * The values can be **Manage**, **Write** and **Read**.
         */
        permission: string;
        /**
         * Specifies the ID of the existing HuaweiCloud user.
         */
        userId: string;
        /**
         * Specifies the name of the existing HuaweiCloud user.
         */
        userName: string;
    }

}

export namespace Tms {
    export interface TagsTag {
        /**
         * Specifies the tag key. The value can contain up to `36` characters. Only English letters,
         * Chinese characters, digits, hyphens (-) and underscores (_) are allowed.
         */
        key: string;
        /**
         * Specifies the tag value. The value can contain up to `43` characters. Only English letters,
         * Chinese characters, digits, periods (.), hyphens (-) and underscores (_) are allowed.
         */
        value: string;
    }

}

export namespace Vod {
    export interface MediaAssetThumbnail {
        /**
         * Specifies the screenshot aspect ratio. The value can be:
         * + **0**: adaptive (maintain the original aspect ratio).
         * + **1**: 16:9.
         */
        aspectRatio?: number;
        /**
         * Specifies the number of screenshots as the cover. Defaults to `1`.
         * Changing this creates a new resource.
         */
        coverPosition?: number;
        /**
         * Specifies an array of time points of screenshot. Required when `type` is **dots**.
         * Changing this creates a new resource.
         */
        dots?: number[];
        /**
         * Specifies the screenshot file format. Currently, only `1` (jpg) is supported.
         * Defaults to: `1`. Changing this creates a new resource.
         */
        format?: number;
        /**
         * Specifies the size of the longest side of the screenshot. Unit: pixel.
         * The width dimension is calculated by scaling the dimension proportional to the original video pixels.
         * Changing this creates a new resource.
         */
        maxLength?: number;
        /**
         * Specifies the screenshot time interval (unit: second). The value range is `1` to `12`.
         * Required when `type` is **time**. Changing this creates a new resource.
         */
        time?: number;
        /**
         * Specifies the screenshot type. Valid values are: **time** and **dots**.
         * Changing this creates a new resource.
         */
        type: string;
    }

    export interface TranscodingTemplateGroupQualityInfo {
        /**
         * Specifies the audio configurations.
         * The object structure is documented below.
         */
        audio?: outputs.Vod.TranscodingTemplateGroupQualityInfoAudio;
        /**
         * Specifies the output format. The value can be: **HLS**, **MP4**, **DASH**,
         * **DASH_HLS**, **MP3** and **ADTS**.
         */
        outputFormat: string;
        /**
         * Specifies the video configurations.
         * The object structure is documented below.
         */
        video?: outputs.Vod.TranscodingTemplateGroupQualityInfoVideo;
    }

    export interface TranscodingTemplateGroupQualityInfoAudio {
        /**
         * Specifies the audio bitrate. The value can be `0` or range from
         * `8` to `1,000`. Defaults to `0`. If set to `0`, the output audio will be produced at the recommended bitrate.
         */
        bitrate?: number;
        /**
         * Specifies the audio channels. The value can be:
         * + **1**: Mono
         * + **2**: Stereo
         */
        channels: number;
        /**
         * Specifies the audio sample rate. The value can be:
         * + **1**: AUTO
         * + **2**: 22,050 Hz
         * + **3**: 32,000 Hz
         * + **4**: 44,100 Hz
         * + **5**: 48,000 Hz
         * + **6**: 96,000 Hz
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupQualityInfoVideo {
        /**
         * Specifies the audio bitrate. The value can be `0` or range from
         * `8` to `1,000`. Defaults to `0`. If set to `0`, the output audio will be produced at the recommended bitrate.
         */
        bitrate?: number;
        /**
         * Specifies the video frame rate. The value ranges from `1` to `75`.
         * Defaults to `1`. If set to `1`, the frame rate of the transcoded video is the same as that of the untransocded video.
         */
        frameRate?: number;
        /**
         * Specifies the video height. The value can be `0` or range from `128` to `2,160`.
         * Defaults to `0`. If set to `0`, the system will automatically adjust the `height` according to the `width`.
         */
        height?: number;
        /**
         * Specifies the video quality.
         * The value can be: **4K**, **2K**, **FHD**, **SD**, **LD** and **HD**.
         */
        quality: string;
        /**
         * Specifies the video width. The value can be `0` or range from `128` to `3,840`.
         * Defaults to `0`. If set to `0`, the system will automatically adjust the `width` according to the `height`.
         */
        width?: number;
    }

}

export namespace Vpc {
    export interface AddressGroupIpExtraSet {
        /**
         * Specifies the IP address, IP address range, or CIDR block.
         */
        ip: string;
        /**
         * Specifies the supplementary information about the IP address,
         * IP address range, or CIDR block.
         */
        remarks?: string;
    }

    export interface BandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
         */
        type: string;
    }

    export interface EipBandwidth {
        /**
         * Specifies whether the bandwidth is billed by traffic or by bandwidth
         * size. The value can be **traffic** or **bandwidth**. If the `chargingMode` is **prePaid**, only **bandwidth** is valid.
         */
        chargeMode: string;
        /**
         * The shared bandwidth ID.  
         * This parameter is mandatory when `shareType` is set to **WHOLE**. Changing this will create a new resource.
         */
        id: string;
        /**
         * Specifies the bandwidth name.  
         * The name can contain `1` to `64` characters, including letters, digits, underscores (_), hyphens (-), and periods (.).
         * This parameter is mandatory when `shareType` is set to **PER**.
         */
        name: string;
        /**
         * Specifies whether the bandwidth is dedicated or shared.  
         * Changing this will create a new resource. Possible values are as follows:
         * + **PER**: Dedicated bandwidth
         * + **WHOLE**: Shared bandwidth
         */
        shareType: string;
        /**
         * The bandwidth size.  
         * The value ranges from `1` to `300` Mbit/s. This parameter is mandatory when `shareType` is set to **PER**.
         */
        size: number;
    }

    export interface EipPublicip {
        /**
         * Specifies the EIP address to be assigned.  
         * The value must be a valid **IPv4** address in the available IP address range.
         * The system automatically assigns an EIP if you do not specify it. Changing this will create a new resource.
         */
        ipAddress: string;
        /**
         * Specifies the IP version, either `4` (default) or `6`.
         */
        ipVersion: number;
        /**
         * The port ID which the EIP associated with.
         */
        portId: string;
        /**
         * Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
         * and **5_sbgp** (static BGP), the default value is **5_bgp**. Changing this will create a new resource.
         */
        type?: string;
    }

    export interface GetAddressGroupsAddressGroup {
        /**
         * IP address sets in an IP address group.
         * Value range: a single IP address, IP address range, or CIDR block.
         */
        addresses: string[];
        /**
         * Time when the IP address group is created.
         */
        createdAt: string;
        /**
         * Provides supplementary information about an IP address group,
         * which can be used to filter the IP address group.
         */
        description: string;
        /**
         * Enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * IP address group ID, which uniquely identifies the IP address group.
         */
        id: string;
        /**
         * IP addresses and their remarks in an IP address group.
         */
        ipExtraSets: outputs.Vpc.GetAddressGroupsAddressGroupIpExtraSet[];
        /**
         * Version of IP addresses in an IP address group,
         * which can be used to filter the IP address group.
         */
        ipVersion: number;
        /**
         * Maximum number of entries in an address group,
         * which limits the number of addresses that can be contained in an address group.
         */
        maxCapacity: number;
        /**
         * Name of an IP address group, which can be used to filter the IP address group.
         */
        name: string;
        /**
         * The status of IP address group.
         * Valid values are:
         * + `NORMAL`: normal status.
         * + `UPDATING`: updating.
         * + `UPDATE_FAILED`: update failed.
         * When the status of IP address group is `UPDATING`, the IP address group cannot be updated again.
         */
        status: string;
        /**
         * The status details of IP address group.
         */
        statusMessage: string;
        /**
         * Time when the IP address group was last updated.
         */
        updatedAt: string;
    }

    export interface GetAddressGroupsAddressGroupIpExtraSet {
        /**
         * An IP address, IP address range, or CIDR block.
         */
        ip: string;
        /**
         * Provides supplementary information about the IP address, IP address range, or CIDR block.
         */
        remarks: string;
    }

    export interface GetFlowLogsFlowLog {
        /**
         * The time when the resource is created.
         */
        createdAt: string;
        /**
         * The VPC flow log description.
         */
        description: string;
        /**
         * Whether to enable the VPC flow log.
         */
        enabled: boolean;
        /**
         * The ID of a VPC flow log
         */
        id: string;
        /**
         * Specifies the LTS log group ID.
         */
        logGroupId: string;
        /**
         * Specifies the LTS log stream ID.
         */
        logStreamId: string;
        /**
         * Specifies the VPC flow log name.
         * The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name: string;
        /**
         * Specifies the resource ID for which that the logs to be collected.
         */
        resourceId: string;
        /**
         * Specifies the resource type for which that the logs to be collected.
         * The value can be: **port**, **network,** and **vpc**.
         */
        resourceType: string;
        /**
         * Specifies the status of the flow log.
         * The value can be **ACTIVE**, **DOWN** or **ERROR**.
         */
        status: string;
        /**
         * Specifies the type of traffic to log.
         * The value can be: **all**, **accept** and **reject**.
         */
        trafficType: string;
        /**
         * The time when the resource is last updated.
         */
        updatedAt: string;
    }

    export interface GetNetworkAclsNetworkAcl {
        /**
         * The associated subnets of the network ACL.
         * The associatedSubnets structure is documented below.
         */
        associatedSubnets: outputs.Vpc.GetNetworkAclsNetworkAclAssociatedSubnet[];
        /**
         * The created time of the ACL.
         */
        createdAt: string;
        /**
         * The network ACL rule description.
         */
        description: string;
        /**
         * The egress rules of the network ACL.
         * The rules structure is documented below.
         */
        egressRules: outputs.Vpc.GetNetworkAclsNetworkAclEgressRule[];
        /**
         * Specifies whether the network ACL is enabled. The value can be **true** or **false**.
         */
        enabled: boolean;
        /**
         * Specifies the enterprise project ID of the network ACL.
         */
        enterpriseProjectId: string;
        /**
         * The network ACL ID.
         */
        id: string;
        /**
         * The ingress rules of the network ACL.
         * The rules structure is documented below.
         */
        ingressRules: outputs.Vpc.GetNetworkAclsNetworkAclIngressRule[];
        /**
         * Specifies the network ACL name. The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name: string;
        /**
         * Specifies the status of the network ACL.
         */
        status: string;
        /**
         * The updated time of the ACL.
         */
        updatedAt: string;
    }

    export interface GetNetworkAclsNetworkAclAssociatedSubnet {
        /**
         * The ID of the subnet to associate with the network ACL.
         */
        subnetId: string;
    }

    export interface GetNetworkAclsNetworkAclEgressRule {
        /**
         * The rule action.
         */
        action: string;
        /**
         * The network ACL rule description.
         */
        description: string;
        /**
         * The destination IP address or CIDR block of a network ACL rule.
         */
        destinationIpAddress: string;
        /**
         * The destination IP address group ID of a network ACL rule.
         */
        destinationIpAddressGroupId: string;
        /**
         * The destination ports of a network ACL rule.
         */
        destinationPort: string;
        /**
         * The IP version of a network ACL rule.
         */
        ipVersion: number;
        /**
         * Specifies the network ACL name. The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name: string;
        /**
         * The rule protocol.
         */
        protocol: string;
        /**
         * The ID of the rule.
         */
        ruleId: string;
        /**
         * The source IP address or CIDR block of a network ACL rule.
         */
        sourceIpAddress: string;
        /**
         * The source IP address group ID of a network ACL rule.
         */
        sourceIpAddressGroupId: string;
        /**
         * The source ports of a network ACL rule.
         */
        sourcePort: string;
    }

    export interface GetNetworkAclsNetworkAclIngressRule {
        /**
         * The rule action.
         */
        action: string;
        /**
         * The network ACL rule description.
         */
        description: string;
        /**
         * The destination IP address or CIDR block of a network ACL rule.
         */
        destinationIpAddress: string;
        /**
         * The destination IP address group ID of a network ACL rule.
         */
        destinationIpAddressGroupId: string;
        /**
         * The destination ports of a network ACL rule.
         */
        destinationPort: string;
        /**
         * The IP version of a network ACL rule.
         */
        ipVersion: number;
        /**
         * Specifies the network ACL name. The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name: string;
        /**
         * The rule protocol.
         */
        protocol: string;
        /**
         * The ID of the rule.
         */
        ruleId: string;
        /**
         * The source IP address or CIDR block of a network ACL rule.
         */
        sourceIpAddress: string;
        /**
         * The source IP address group ID of a network ACL rule.
         */
        sourceIpAddressGroupId: string;
        /**
         * The source ports of a network ACL rule.
         */
        sourcePort: string;
    }

    export interface GetQuotasQuota {
        /**
         * The resource objects.
         */
        resources: outputs.Vpc.GetQuotasQuotaResource[];
    }

    export interface GetQuotasQuotaResource {
        /**
         * The minimum quota value allowed.
         */
        min: number;
        /**
         * The maximum quota values for the resources.
         */
        quota: number;
        /**
         * Specifies the type of resource to filter quotas.
         * The value can be **vpc**, **subnet**, **securityGroup**, **securityGroupRule**, **publicIp**,
         * **vpn**, **vpngw**, **vpcPeer**, **firewall**, **shareBandwidth**, **shareBandwidthIP**,
         * **loadbalancer**, **listener**, **physicalConnect**, **virtualInterface**,
         * **vpcContainRoutetable**, and **routetableContainRoutes**.
         */
        type: string;
        /**
         * The number of created resources.
         */
        used: number;
    }

    export interface GetRouteTableRoute {
        /**
         * The description about the route.
         */
        description: string;
        /**
         * The destination address in the CIDR notation format
         */
        destination: string;
        /**
         * The next hop.
         */
        nexthop: string;
        /**
         * The route type.
         */
        type: string;
    }

    export interface GetRoutesRoute {
        /**
         * Specifies the route destination.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * The next hop of the route.
         */
        nexthop: string;
        /**
         * Specifies the route type.
         */
        type: string;
        /**
         * Specifies the ID of the VPC to which the route belongs.
         */
        vpcId: string;
    }

    export interface GetSecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * The supplementary information about the security group rule.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        portRangeMax: number;
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface GetSecgroupRulesRule {
        /**
         * Specifies the effective policy of the security group rule used for query.  
         * The valid values are as follows:
         * + **allow**
         * + **deny**
         */
        action: string;
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * Specifies the security group rule description used for query.
         */
        description: string;
        /**
         * Specifies the direction of the security group rule used for query.  
         * The valid values are as follows:
         * + **ingress**
         * + **egress**
         */
        direction: string;
        /**
         * The security group rule IP address protocol type. The value can be **IPv4** or **IPv6**.
         */
        ethertype: string;
        /**
         * The ID of the security group rule.
         */
        id: string;
        /**
         * The range of port values for security group rule. Which supports single port (80), continuous port (1-30)
         * and discontinuous port (22, 3389, 80).
         */
        ports: string;
        /**
         * The priority of security group rule. The valid value ranges from `1` to `100`, `1` represents the
         * highest priority.
         */
        priority: number;
        /**
         * Specifies the security group rule protocol type used for query.  
         * The value can be **tcp**, **udp**, **icmp**, **icmpv6** or IP protocol number, if empty, it indicates support for
         * all protocols.
         */
        protocol: string;
        /**
         * The remote address group ID.  
         * This field is mutually exclusive with `remoteGroupId` and `remoteIpPrefix`.
         */
        remoteAddressGroupId: string;
        /**
         * Specifies the remote security group ID used for query.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.  
         * This field is mutually exclusive with `remoteGroupId` and `remoteAddressGroupId`.
         */
        remoteIpPrefix: string;
        /**
         * Specifies the security group ID that the rule should belong to.
         */
        securityGroupId: string;
        /**
         * The latest update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetSecgroupsSecurityGroup {
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * Specifies the description of the security group. The security groups can be
         * filtered by keywords in the description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID of the security group.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the id of the desired security group.
         */
        id: string;
        /**
         * Specifies the name of the security group.
         */
        name: string;
        /**
         * The last update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetSubNetworkInterfacesSubNetworkInterface {
        /**
         * The time when the supplementary network interface is created.
         */
        createdAt: string;
        /**
         * Specifies the description of the supplementary network interface.
         */
        description: string;
        /**
         * The ID of supplementary network interface.
         */
        id: string;
        /**
         * Specifies the private IPv4 address of the supplementary network interface.
         */
        ipAddress: string;
        /**
         * The IPv6 address of the supplementary network interface.
         */
        ipv6IpAddress: string;
        /**
         * Specifies the MAC address of the supplementary network interface.
         */
        macAddress: string;
        /**
         * The ID of the parent device.
         */
        parentDeviceId: string;
        /**
         * Specifies the ID of the elastic network interface
         * to which the supplementary network interface belongs.
         */
        parentId: string;
        /**
         * The ID of the project to which the supplementary network interface belongs.
         */
        projectId: string;
        /**
         * Whether the IPv6 address is it enabled of the supplementary network interface.
         */
        securityEnabled: boolean;
        /**
         * The list of the security groups IDs to which the supplementary network interface belongs.
         */
        securityGroups: string[];
        /**
         * Specifies the ID of the subnet to which the supplementary network interface belongs.
         */
        subnetId: string;
        /**
         * The tags of a supplementary network interface.
         */
        tags: string[];
        /**
         * The vlan ID of the supplementary network interface.
         */
        vlanId: number;
        /**
         * Specifies the ID of the VPC to which the supplementary network interface belongs.
         */
        vpcId: string;
    }

    export interface GetSubnetIpAvailabilitiesNetworkIpAvailability {
        /**
         * Specifies the subnet ID.
         */
        networkId: string;
        /**
         * The network name.
         */
        networkName: string;
        /**
         * The subnet IP address usage objects.
         */
        subnetIpAvailabilities: outputs.Vpc.GetSubnetIpAvailabilitiesNetworkIpAvailabilitySubnetIpAvailability[];
        /**
         * The total number of IP addresses on a subnet.
         * The reserved IP addresses are not included.
         */
        totalIps: number;
        /**
         * The number of in-use IP addresses on a subnet.
         * The reserved IP addresses are not included.
         */
        usedIps: number;
    }

    export interface GetSubnetIpAvailabilitiesNetworkIpAvailabilitySubnetIpAvailability {
        /**
         * The subnet CIDR block.
         */
        cidr: string;
        /**
         * The IP version of the subnet.
         * The value can be **4** or **6**.
         */
        ipVersion: number;
        /**
         * The subnet ID.
         */
        subnetId: string;
        /**
         * The subnet name.
         */
        subnetName: string;
        /**
         * The total number of IP addresses on a subnet.
         * The reserved IP addresses are not included.
         */
        totalIps: number;
        /**
         * The number of in-use IP addresses on a subnet.
         * The reserved IP addresses are not included.
         */
        usedIps: number;
    }

    export interface GetSubnetPrivateIpsPrivateIp {
        /**
         * The resource using the private IP address. The parameter is left blank if it is not used.
         */
        deviceOwner: string;
        /**
         * The private IP address ID
         */
        id: string;
        /**
         * The private IP address.
         */
        ipAddress: string;
        /**
         * The status of the private IP address.
         * Possible values are **ACTIVE** and **DOWN**.
         */
        status: string;
        /**
         * Specifies the ID of the subnet that the private IP address belongs to.
         */
        subnetId: string;
    }

    export interface GetSubnetsSubnet {
        /**
         * Specifies the availability zone (AZ) to which the desired subnet belongs to.
         */
        availabilityZone: string;
        /**
         * Specifies the network segment of desired subnet. The value must be in CIDR format.
         */
        cidr: string;
        description: string;
        dhcpEnable: boolean;
        dnsLists: string[];
        /**
         * Specifies the subnet gateway address of desired subnet.
         */
        gatewayIp: string;
        /**
         * - Specifies the id of the desired subnet.
         */
        id: string;
        ipv4SubnetId: string;
        ipv6Cidr: string;
        ipv6Enable: boolean;
        ipv6Gateway: string;
        ipv6SubnetId: string;
        /**
         * Specifies the name of the desired subnet.
         */
        name: string;
        /**
         * Specifies the IP address of DNS server 1 on the desired subnet.
         */
        primaryDns: string;
        /**
         * Specifies the IP address of DNS server 2 on the desired subnet.
         */
        secondaryDns: string;
        /**
         * Specifies the current status of the desired subnet.
         * the value can be ACTIVE, DOWN, UNKNOWN, or ERROR.
         */
        status: string;
        subnetId: string;
        /**
         * Specifies the included key/value pairs which associated with the desired subnet.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the id of the VPC that the desired subnet belongs to.
         */
        vpcId: string;
    }

    export interface GetTrafficMirrorFilterRulesTrafficMirrorFilterRule {
        /**
         * The policy of in the traffic mirror filter rule.
         * Valid values are **accept** or **reject**.
         */
        action: string;
        /**
         * Time when a traffic mirror filter rule is created.
         */
        createdAt: string;
        /**
         * Description of a traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination IP address of the traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port number range of the traffic mirror filter rule.
         * The value ranges from `1` to `65,535`, enter two port numbers connected by a hyphen (-). For example, **80-200**.
         */
        destinationPortRange: string;
        /**
         * The direction of the traffic mirror filter rule.
         * Valid values are **ingress** or **egress**.
         */
        direction: string;
        /**
         * IP address version of the mirrored traffic.
         */
        ethertype: string;
        /**
         * Traffic mirror filter rule ID.
         */
        id: string;
        /**
         * The priority number of the traffic mirror filter rule.
         * Valid value ranges from `1` to `65,535`.
         */
        priority: number;
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * The protocol of the traffic mirror filter rule.
         * Valid value are **tcp**, **udp**, **icmp**, **icmpv6**, **all**.
         */
        protocol: string;
        /**
         * The source IP address of the traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port number range of the traffic mirror filter rule.
         * The value ranges from `1` to `65,535`, enter two port numbers connected by a hyphen (-). For example, **80-200**.
         */
        sourcePortRange: string;
        /**
         * The traffic mirror filter ID used as the query filter.
         */
        trafficMirrorFilterId: string;
        /**
         * Time when a traffic mirror filter rule is updated.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilter {
        /**
         * Time when a traffic mirror filter rule is created.
         */
        createdAt: string;
        /**
         * Description of a traffic mirror filter rule.
         */
        description: string;
        /**
         * Outbound mirror filter rules.
         */
        egressRules: outputs.Vpc.GetTrafficMirrorFiltersTrafficMirrorFilterEgressRule[];
        /**
         * Traffic mirror filter rule ID.
         */
        id: string;
        /**
         * Inbound mirror filter rules.
         */
        ingressRules: outputs.Vpc.GetTrafficMirrorFiltersTrafficMirrorFilterIngressRule[];
        /**
         * Specifies the name of the traffic mirror filter.
         */
        name: string;
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Time when a traffic mirror filter rule is updated.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilterEgressRule {
        /**
         * Whether to accept or reject traffic.
         */
        action: string;
        /**
         * Time when a traffic mirror filter rule is created.
         */
        createdAt: string;
        /**
         * Description of a traffic mirror filter rule.
         */
        description: string;
        /**
         * Destination CIDR block of the mirrored traffic.
         */
        destinationCidrBlock: string;
        /**
         * Source port range.
         */
        destinationPortRange: string;
        /**
         * Traffic direction.
         */
        direction: string;
        /**
         * IP address version of the mirrored traffic.
         */
        ethertype: string;
        /**
         * Traffic mirror filter rule ID.
         */
        id: string;
        /**
         * Mirror filter rule priority.
         */
        priority: number;
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Protocol of the mirrored traffic.
         */
        protocol: string;
        /**
         * Source CIDR block of the mirrored traffic.
         */
        sourceCidrBlock: string;
        /**
         * Source port range.
         */
        sourcePortRange: string;
        /**
         * Specifies the ID of the traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * Time when a traffic mirror filter rule is updated.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilterIngressRule {
        /**
         * Whether to accept or reject traffic.
         */
        action: string;
        /**
         * Time when a traffic mirror filter rule is created.
         */
        createdAt: string;
        /**
         * Description of a traffic mirror filter rule.
         */
        description: string;
        /**
         * Destination CIDR block of the mirrored traffic.
         */
        destinationCidrBlock: string;
        /**
         * Source port range.
         */
        destinationPortRange: string;
        /**
         * Traffic direction.
         */
        direction: string;
        /**
         * IP address version of the mirrored traffic.
         */
        ethertype: string;
        /**
         * Traffic mirror filter rule ID.
         */
        id: string;
        /**
         * Mirror filter rule priority.
         */
        priority: number;
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Protocol of the mirrored traffic.
         */
        protocol: string;
        /**
         * Source CIDR block of the mirrored traffic.
         */
        sourceCidrBlock: string;
        /**
         * Source port range.
         */
        sourcePortRange: string;
        /**
         * Specifies the ID of the traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * Time when a traffic mirror filter rule is updated.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorSessionsTrafficMirrorSession {
        /**
         * Time when a traffic mirror session is created.
         */
        createdAt: string;
        /**
         * Description of a traffic mirror session.
         */
        description: string;
        /**
         * Specifies whether the mirror session is enabled. Defaults to **true**.
         */
        enabled: boolean;
        /**
         * Traffic mirror session ID.
         */
        id: string;
        /**
         * Specifies the traffic mirror session name used to query.
         */
        name: string;
        /**
         * Specifies the maximum transmission unit (MTU).
         * The value range is **1-1460**, defaults to **96**.
         */
        packetLength: number;
        /**
         * Specifies the mirror session priority. The value range is **1-32766**.
         * A smaller value indicates a higher priority.
         */
        priority: number;
        /**
         * Project ID.
         */
        projectId: string;
        /**
         * Specifies the traffic mirror filter ID used in the session.
         */
        trafficMirrorFilterId: string;
        /**
         * Mirror source IDs. An elastic network interface can be used as a mirror source.
         * Each mirror session can have up to 10 mirror sources by default.
         */
        trafficMirrorSources: string[];
        /**
         * Specifies the traffic mirror target ID.
         */
        trafficMirrorTargetId: string;
        /**
         * Specifies the mirror target type. The value can be:
         * + **eni**: elastic network interface;
         * + **elb**: private network load balancer;
         */
        trafficMirrorTargetType: string;
        /**
         * Specifies the mirror source type. The value can be **eni**(elastic network interface).
         */
        type: string;
        /**
         * Time when the traffic mirror session is updated.
         */
        updatedAt: string;
        /**
         * Specifies the VNI, which is used to distinguish mirrored traffic of different
         * sessions. The value range is **0-16777215**, defaults to **1**.
         */
        virtualNetworkId: number;
    }

    export interface GetVpcRoute {
        destination: string;
        nexthop: string;
    }

    export interface GetVpcsVpc {
        /**
         * Specifies the cidr block of the desired VPC.
         */
        cidr: string;
        /**
         * The description of the VPC.
         */
        description: string;
        /**
         * Specifies the enterprise project ID which the desired VPC belongs to.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the id of the desired VPC.
         */
        id: string;
        /**
         * Specifies the name of the desired VPC. The value is a string of no more than 64 characters
         * and can contain digits, letters, underscores (_) and hyphens (-).
         */
        name: string;
        /**
         * The secondary CIDR blocks of the VPC.
         */
        secondaryCidrs: string[];
        /**
         * Specifies the current status of the desired VPC. The value can be CREATING, OK or ERROR.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired VPC.
         */
        tags: {[key: string]: string};
    }

    export interface NetworkAclAssociatedSubnet {
        /**
         * Specifies the ID of the subnet to associate with the network ACL.
         */
        subnetId: string;
    }

    export interface NetworkAclEgressRule {
        /**
         * Specifies the rule action. The value can be: **allow** and **deny**.
         */
        action: string;
        /**
         * Specifies the network ACL rule description. The value can contain no more
         * than 255 characters. The value cannot contain angle brackets (< or >).
         */
        description?: string;
        /**
         * Specifies the destination IP address or CIDR block of a network ACL rule.
         * The `destinationIpAddress` and `destinationAddressGroupId` cannot be configured at the same time.
         */
        destinationIpAddress?: string;
        /**
         * Specifies the destination IP address group ID of a network ACL rule.
         * The `destinationIpAddress` and `destinationAddressGroupId` cannot be configured at the same time.
         */
        destinationIpAddressGroupId?: string;
        /**
         * Specifies the destination ports of a network ACL rule.
         * You can specify a single port or a port range. Separate every two entries with a comma.
         */
        destinationPort?: string;
        /**
         * Specifies the IP version of a network ACL rule.
         * The value can be **4** (IPv4) and **6** (IPv6).
         */
        ipVersion: number;
        /**
         * Specifies the network ACL rule name. The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name?: string;
        /**
         * Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
         * or an IP protocol number (0255). The value **any** indicates all protocols.
         */
        protocol: string;
        /**
         * The ID of the rule.
         */
        ruleId: string;
        /**
         * Specifies the source IP address or CIDR block of a network ACL rule.
         * The `sourceIpAddress` and `sourceAddressGroupId` cannot be configured at the same time.
         */
        sourceIpAddress?: string;
        /**
         * Specifies the source IP address group ID of a network ACL rule.
         * `sourceIpAddress` and `sourceAddressGroupId` cannot be configured at the same time.
         */
        sourceIpAddressGroupId?: string;
        /**
         * Specifies the source ports of a network ACL rule.
         * You can specify a single port or a port range. Separate every two entries with a comma.
         */
        sourcePort?: string;
    }

    export interface NetworkAclIngressRule {
        /**
         * Specifies the rule action. The value can be: **allow** and **deny**.
         */
        action: string;
        /**
         * Specifies the network ACL rule description. The value can contain no more
         * than 255 characters. The value cannot contain angle brackets (< or >).
         */
        description?: string;
        /**
         * Specifies the destination IP address or CIDR block of a network ACL rule.
         * The `destinationIpAddress` and `destinationAddressGroupId` cannot be configured at the same time.
         */
        destinationIpAddress?: string;
        /**
         * Specifies the destination IP address group ID of a network ACL rule.
         * The `destinationIpAddress` and `destinationAddressGroupId` cannot be configured at the same time.
         */
        destinationIpAddressGroupId?: string;
        /**
         * Specifies the destination ports of a network ACL rule.
         * You can specify a single port or a port range. Separate every two entries with a comma.
         */
        destinationPort?: string;
        /**
         * Specifies the IP version of a network ACL rule.
         * The value can be **4** (IPv4) and **6** (IPv6).
         */
        ipVersion: number;
        /**
         * Specifies the network ACL rule name. The value can contain no more than 64 characters,
         * including letters, digits, underscores (_), hyphens (-), and periods (.).
         */
        name?: string;
        /**
         * Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
         * or an IP protocol number (0255). The value **any** indicates all protocols.
         */
        protocol: string;
        /**
         * The ID of the rule.
         */
        ruleId: string;
        /**
         * Specifies the source IP address or CIDR block of a network ACL rule.
         * The `sourceIpAddress` and `sourceAddressGroupId` cannot be configured at the same time.
         */
        sourceIpAddress?: string;
        /**
         * Specifies the source IP address group ID of a network ACL rule.
         * `sourceIpAddress` and `sourceAddressGroupId` cannot be configured at the same time.
         */
        sourceIpAddressGroupId?: string;
        /**
         * Specifies the source ports of a network ACL rule.
         * You can specify a single port or a port range. Separate every two entries with a comma.
         */
        sourcePort?: string;
    }

    export interface PortAllowedAddressPair {
        ipAddress: string;
        macAddress: string;
    }

    export interface PortExtraDhcpOption {
        ipVersion?: number;
        name: string;
        value: string;
    }

    export interface PortFixedIp {
        ipAddress?: string;
        subnetId: string;
    }

    export interface RouteTableRoute {
        /**
         * Specifies the supplementary information about the route.
         * The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
         */
        description?: string;
        /**
         * Specifies the destination address in the CIDR notation format,
         * for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
         * with any subnet in the VPC.
         */
        destination: string;
        /**
         * Specifies the next hop.
         * + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
         * + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
         * + If the route type is **vip**, the value is a virtual IP address.
         * + If the route type is **nat**, the value is a VPN gateway ID.
         * + If the route type is **peering**, the value is a VPC peering connection ID.
         * + If the route type is **vpn**, the value is a VPN gateway ID.
         * + If the route type is **dc**, the value is a Direct Connect gateway ID.
         * + If the route type is **cc**, the value is a Cloud Connection ID.
         * + If the route type is **egw**, the value is a VPCEP endpoint ID.
         * + If the route type is **er**, the value is a ER instance ID.
         */
        nexthop: string;
        /**
         * Specifies the route type. Currently, the value can be:
         * **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc**, **cc**, **egw** and **er**.
         */
        type: string;
    }

    export interface SecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * Specifies the description for the security group.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        portRangeMax: number;
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface VpcRoute {
        destination: string;
        nexthop: string;
    }
}

export namespace Vpcep {
    export interface ApprovalConnection {
        /**
         * The description of the VPC endpoint service connection.
         */
        description: string;
        /**
         * The user's domain ID.
         */
        domainId: string;
        /**
         * The unique ID of the VPC endpoint.
         */
        endpointId: string;
        /**
         * The packet ID of the VPC endpoint.
         */
        packetId: number;
        /**
         * The connection status of the VPC endpoint.
         */
        status: string;
    }

    export interface GetPublicServicesService {
        /**
         * The unique ID of the public VPC endpoint service.
         */
        id: string;
        /**
         * Indicates whether the associated VPC endpoint carries a charge.
         */
        isCharge: boolean;
        /**
         * The owner of the VPC endpoint service.
         */
        owner: string;
        /**
         * Specifies the name of the public VPC endpoint service. The value is not
         * case-sensitive and supports fuzzy match.
         */
        serviceName: string;
        /**
         * The type of the VPC endpoint service.
         */
        serviceType: string;
    }

    export interface ServiceConnection {
        /**
         * Specifies the description of the VPC endpoint service.
         */
        description: string;
        /**
         * The user's domain ID.
         */
        domainId: string;
        /**
         * The unique ID of the VPC endpoint.
         */
        endpointId: string;
        /**
         * The packet ID of the VPC endpoint.
         */
        packetId: number;
        /**
         * The connection status of the VPC endpoint.
         */
        status: string;
    }

    export interface ServicePortMapping {
        /**
         * Specifies the protocol used in port mappings. Only **TCP** is supported.
         */
        protocol?: string;
        /**
         * Specifies the port for accessing the VPC endpoint service. This port is provided by
         * the backend service to provide services. The value ranges from `1` to `65,535`.
         */
        servicePort?: number;
        /**
         * Specifies the port for accessing the VPC endpoint. This port is provided by the VPC
         * endpoint, allowing you to access the VPC endpoint service. The value ranges from `1` to `65,535`.
         */
        terminalPort?: number;
    }

}

export namespace Waf {
    export interface DedicatedDomainConnectionProtection {
        /**
         * Specifies the protection duration (s) for connection protection. During this period, WAF
         * stops forwarding website requests. Valid value ranges from `0` to `2,147,483,647`.
         */
        duration: number;
        /**
         * Specifies the `502`/`504` error percentage. A breakdown protection is triggered
         * when the `502`/`504` error threshold and percentage threshold have been reached. Valid value ranges from `0` to `99`.
         */
        errorPercentage: number;
        /**
         * Specifies the `502`/`504` error threshold for every 30 seconds. Valid value ranges
         * from `0` to `2,147,483,647`.
         */
        errorThreshold: number;
        /**
         * Specifies the breakdown duration (s) when the breakdown is triggered for the first
         * time. Valid value ranges from `0` to `2,147,483,647`.
         */
        initialDowntime: number;
        /**
         * Specifies the maximum multiplier for consecutive breakdowns
         * that occur within an hour. Valid value ranges from `0` to `2,147,483,647`.
         * For example: Assume that you set the initial downtime to `180s` and the maximum multiplier to `3`. If the breakdown
         * protection is triggered for the second time, the website downtime is 360s (180s X 2).
         * If the breakdown protection is triggered for the third or fourth time, the website downtime is 540s (180s x 3).
         * The breakdowns are calculated every one hour.
         */
        multiplierForConsecutiveBreakdowns: number;
        /**
         * Specifies the pending URL request threshold. Connection protection
         * is triggered when the number of read URL requests reaches the threshold you configure. Valid value ranges from `0` to
         * `2,147,483,647`.
         */
        pendingUrlRequestThreshold: number;
        /**
         * Specifies whether to enable connection protection. Defaults to **false**.
         */
        status: boolean;
    }

    export interface DedicatedDomainCustomPage {
        /**
         * Specifies the content type of the custom alarm page.
         * The value can be **text/html**, **text/xml** or **application/json**.
         */
        blockPageType: string;
        /**
         * Specifies the HTTP return code.
         * The value can be a positive integer in the range of `200`-`599` except `408`, `444` and `499`.
         */
        httpReturnCode: string;
        /**
         * Specifies the page content. The page content based on the selected page type.
         * The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
         * can be available.
         */
        pageContent: string;
    }

    export interface DedicatedDomainServer {
        /**
         * Specifies the IP address or domain name of the web server accessed by the
         * client. For example, `192.168.1.1` or `www.example.com`. Changing this creates a new service.
         */
        address: string;
        /**
         * Specifies the protocol type of the client. The options include **HTTP**
         * and **HTTPS**. Changing this creates a new service.
         */
        clientProtocol: string;
        /**
         * Specifies the port number used by the web server. The value ranges from `0` to
         * `65,535`. Changing this creates a new service.
         */
        port: number;
        /**
         * Specifies the protocol used by WAF to forward client requests to the
         * server. The valid values are **HTTP** and **HTTPS**. Changing this creates a new service.
         */
        serverProtocol: string;
        /**
         * Specifies the server network type, IPv4 or IPv6.
         * Valid values are **ipv4** and **ipv6**. Changing this creates a new service.
         */
        type: string;
        /**
         * Specifies the ID of the VPC used by the server. Changing this creates a service.
         */
        vpcId: string;
    }

    export interface DedicatedDomainTimeoutSettings {
        /**
         * Specifies the timeout for WAF to connect to the origin server. The unit is second.
         * Valid value ranges from `0` to `180`.
         */
        connectionTimeout: number;
        /**
         * Specifies the timeout for WAF to receive responses from the origin server.
         * The unit is second. Valid value ranges from `0` to `3,600`.
         */
        readTimeout: number;
        /**
         * Specifies the timeout for WAF to send requests to the origin server. The unit is second.
         * Valid value ranges from `0` to `3,600`.
         */
        writeTimeout: number;
    }

    export interface DedicatedDomainTrafficMark {
        /**
         * Specifies the IP tags. HTTP request header field of the original client IP address.
         * This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
         * configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
         * address list in order. Note:
         * + If you want to use a TCP connection IP address as the client IP address, set IP Tag to `$remote_addr`.
         * + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the `cdn-src-ip`,
         * `x-real-ip`, `x-forwarded-for` and `$remote_addr` fields in sequence to read the client IP address.
         */
        ipTags: string[];
        /**
         * Specifies the session tag. This tag is used by known attack source rules to block
         * malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
         * requests based on cookie attributes.
         */
        sessionTag: string;
        /**
         * Specifies the user tag. This tag is used by known attack source rules to block malicious
         * attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
         */
        userTag: string;
    }

    export interface DomainCustomPage {
        /**
         * Specifies the content type of the custom alarm page.
         * The value can be **text/html**, **text/xml** or **application/json**.
         */
        blockPageType: string;
        /**
         * Specifies the HTTP return code.
         * The value can be a positive integer in the range of `200` to `599` except `408`, `444` and `499`.
         */
        httpReturnCode: string;
        /**
         * Specifies the page content. The page content based on the selected page type.
         * The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
         * can be available.
         */
        pageContent: string;
    }

    export interface DomainServer {
        /**
         * Specifies the IP address or domain name of the web server that the client accesses.
         */
        address: string;
        /**
         * Specifies the protocol type of the client. The options include **HTTP** and **HTTPS**.
         */
        clientProtocol: string;
        /**
         * Specifies the port number used by the web server. The value ranges from `0` to `65,535`,
         * for example, `8,080`.
         */
        port: number;
        /**
         * Specifies the protocol used by WAF to forward client requests to the server.
         * The options include **HTTP** and **HTTPS**.
         */
        serverProtocol: string;
        /**
         * Specifies the server network type. Valid values are: **ipv4** and **ipv6**.
         * + When this field is set to **ipv4**, `address` must be set to an IPv4 address.
         * + When this field is set to **ipv6**, `address` must be set to an IPv6 address.
         */
        type?: string;
        /**
         * Specifies the load balancing algorithm will assign requests to the origin
         * site according to this weight.
         * Defaults to `1`.
         */
        weight?: number;
    }

    export interface DomainTimeoutSettings {
        /**
         * Specifies the timeout for WAF to connect to the origin server. The unit is second.
         * Valid value ranges from `0` to `180`.
         */
        connectionTimeout: number;
        /**
         * Specifies the timeout for WAF to receive responses from the origin server.
         * The unit is second. Valid value ranges from `0` to `3,600`.
         */
        readTimeout: number;
        /**
         * Specifies the timeout for WAF to send requests to the origin server. The unit is second.
         * Valid value ranges from `0` to `3,600`.
         */
        writeTimeout: number;
    }

    export interface DomainTrafficMark {
        /**
         * Specifies the IP tags. HTTP request header field of the original client IP address.
         * This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
         * configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
         * address list in order. Note:
         * + If you want to use a TCP connection IP address as the client IP address, set IP Tag to **$remote_addr**.
         * + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the **cdn-src-ip**,
         * **x-real-ip**, **x-forwarded-for** and **$remote_addr** fields in sequence to read the client IP address.
         * + When the website setting `proxy` is configured as **false**, this field does not take effect,
         * and the client IP is only obtained through the `$remote_addr` field.
         */
        ipTags: string[];
        /**
         * Specifies the session tag. This tag is used by known attack source rules to block
         * malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
         * requests based on cookie attributes.
         */
        sessionTag: string;
        /**
         * Specifies the user tag. This tag is used by known attack source rules to block malicious
         * attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
         */
        userTag: string;
    }

    export interface GetDedicatedInstancesInstance {
        /**
         * The access status of the instance. `0`: inaccessible, `1`: accessible.
         */
        accessStatus: number;
        /**
         * The available zone name of the WAF dedicated instance.
         */
        availableZone: string;
        /**
         * The ECS CPU architecture of WAF dedicated instance.
         */
        cpuArchitecture: string;
        /**
         * The flavor of the ECS used by the WAF instance.
         */
        ecsFlavor: string;
        groupId: string;
        /**
         * Specifies the ID of WAF dedicated instance.
         */
        id: string;
        /**
         * Specifies the name of WAF dedicated instance.
         */
        name: string;
        /**
         * The running status of the instance. Values are:
         */
        runStatus: number;
        /**
         * The security group of the instance. This is an array of security group IDs.
         */
        securityGroups: string[];
        /**
         * The ID of the ECS hosting the dedicated engine.
         */
        serverId: string;
        /**
         * The service plane IP address of the dedicated WAF instance.
         */
        serviceIp: string;
        /**
         * The subnet ID of WAF dedicated instance VPC.
         */
        subnetId: string;
        /**
         * Whether the dedicated WAF instance can be upgraded. `0`: Cannot be upgraded; `1`: Can be upgraded.
         */
        upgradable: number;
        /**
         * The VPC ID of WAF dedicated instance.
         */
        vpcId: string;
    }

    export interface GetInstanceGroupsGroup {
        bodyLimit: number;
        connectionTimeout: number;
        dedicatedInstances: outputs.Waf.GetInstanceGroupsGroupDedicatedInstance[];
        description: string;
        domainNames: outputs.Waf.GetInstanceGroupsGroupDomainName[];
        headerLimit: number;
        loadBalancers: string[];
        name: string;
        readTimeout: number;
        region: string;
        vpcId: string;
        writeTimeout: number;
    }

    export interface GetInstanceGroupsGroupDedicatedInstance {
        id: string;
        name: string;
    }

    export interface GetInstanceGroupsGroupDomainName {
        id: string;
        name: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The protection switches. The object structure is documented below.
         */
        bindHosts: outputs.Waf.GetPoliciesPolicyBindHost[];
        /**
         * The deep inspection in basic web protection.
         */
        deepInspection: boolean;
        /**
         * The detection mode in precise protection.
         * + **false**: Instant detection. When a request hits the blocking conditions in precise protection, WAF terminates
         * checks and blocks the request immediately.
         * + **true**: Full detection. If a request hits the blocking conditions in precise protection, WAF does not block the
         * request immediately. Instead, it blocks the requests until other checks are finished.
         */
        fullDetection: boolean;
        /**
         * The header inspection in basic web protection.
         */
        headerInspection: boolean;
        /**
         * The domain name ID.
         */
        id: string;
        /**
         * The protection level. Valid values are:
         * + **1**: Low. At this protection level, WAF blocks only requests with obvious attack features. If a large number of
         * false alarms have been reported, this value is recommended.
         * + **2**: Medium. This protection level meets web protection requirements in most scenarios.
         * + **3**: High. At this protection level, WAF provides the finest granular protection and can intercept attacks with
         * complex bypass features, such as Jolokia cyberattacks, common gateway interface (CGI) vulnerability detection,
         * and Druid SQL injection attacks.
         */
        level: number;
        /**
         * Specifies the policy name used for matching. The value is case-sensitive and supports
         * fuzzy matching.
         */
        name: string;
        /**
         * The protection switches. The options object structure is documented below.
         */
        options: outputs.Waf.GetPoliciesPolicyOption[];
        /**
         * The protective action after a rule is matched. Valid values are:
         * + **block**: WAF blocks and logs detected attacks.
         * + **log**: WAF logs detected attacks only.
         */
        protectionMode: string;
        /**
         * The protective actions for each rule in anti-crawler protection. Valid values are:
         * + **block**: WAF blocks discovered attacks.
         * + **log**: WAF only logs discovered attacks.
         */
        robotAction: string;
        /**
         * The shiro decryption check in basic web protection.
         */
        shiroDecryptionCheck: boolean;
    }

    export interface GetPoliciesPolicyBindHost {
        /**
         * The domain name.
         */
        hostname: string;
        /**
         * The domain name ID.
         */
        id: string;
        /**
         * The special domain name mode. This attribute is only valid for dedicated mode.
         */
        mode: string;
        /**
         * The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
         * cloud WAF or **premium** for dedicated WAF instances.
         */
        wafType: string;
    }

    export interface GetPoliciesPolicyOption {
        /**
         * Indicates whether the javascript anti-crawler is enabled.
         */
        antiCrawler: boolean;
        /**
         * Indicates whether Basic Web Protection is enabled.
         */
        basicWebProtection: boolean;
        /**
         * Indicates whether the blacklist and whitelist protection is enabled.
         */
        blacklist: boolean;
        /**
         * Indicates whether the anti-crawler protection is enabled.
         */
        botEnable: boolean;
        /**
         * Indicates whether the cc attack protection rules are enabled.
         */
        ccAttackProtection: boolean;
        crawler: boolean;
        /**
         * Indicates whether the search engine is enabled.
         */
        crawlerEngine: boolean;
        /**
         * Indicates whether other crawler check is enabled.
         */
        crawlerOther: boolean;
        /**
         * Indicates whether the anti-crawler detection is enabled.
         */
        crawlerScanner: boolean;
        /**
         * Indicates whether the script tool is enabled.
         */
        crawlerScript: boolean;
        /**
         * Indicates whether data masking is enabled.
         */
        dataMasking: boolean;
        /**
         * Indicates whether false alarm masking is enabled.
         */
        falseAlarmMasking: boolean;
        /**
         * Indicates whether General Check in Basic Web Protection is enabled.
         */
        generalCheck: boolean;
        /**
         * Indicates whether the geolocation access control is enabled.
         */
        geolocationAccessControl: boolean;
        /**
         * Indicates whether the information leakage prevention is enabled.
         */
        informationLeakagePrevention: boolean;
        /**
         * Indicates whether the known attack source is enabled.
         */
        knownAttackSource: boolean;
        /**
         * Indicates whether the precise protection is enabled.
         */
        preciseProtection: boolean;
        /**
         * Indicates whether the web tamper protection is enabled.
         */
        webTamperProtection: boolean;
        /**
         * Indicates whether the web shell detection in basic web protection is enabled.
         */
        webshell: boolean;
    }

    export interface GetReferenceTablesTable {
        /**
         * The conditions of the reference table.
         */
        conditions: string[];
        /**
         * The server time when reference table was created.
         */
        creationTime: string;
        /**
         * The description of the reference table.
         */
        description: string;
        /**
         * The ID of the reference table.
         */
        id: string;
        /**
         * Specifies the name of the reference table. The value is case-sensitive and matches exactly.
         */
        name: string;
        /**
         * The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
         * and `header`.
         */
        type: string;
    }

    export interface PolicyBindHost {
        /**
         * The domain name.
         */
        hostname: string;
        /**
         * The domain name ID.
         */
        id: string;
        /**
         * The special domain name mode. This attribute is only valid for dedicated mode.
         */
        mode: string;
        /**
         * The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
         * cloud WAF or **premium** for dedicated WAF instances.
         */
        wafType: string;
    }

    export interface PolicyOption {
        /**
         * Specifies whether the javascript anti-crawler is enabled. Defaults to **false**.
         */
        antiCrawler?: boolean;
        /**
         * Specifies whether basic web protection is enabled. Defaults to **false**.
         */
        basicWebProtection?: boolean;
        /**
         * Specifies whether the blacklist and whitelist protection is enabled.
         * Defaults to **false**.
         */
        blacklist?: boolean;
        /**
         * Specifies whether the anti-crawler protection is enabled. Defaults to **false**.
         */
        botEnable?: boolean;
        /**
         * Specifies whether the cc attack protection rules are enabled.
         * Defaults to **false**.
         */
        ccAttackProtection?: boolean;
        crawler: boolean;
        /**
         * Specifies whether the search engine is enabled. Defaults to **false**.
         */
        crawlerEngine?: boolean;
        /**
         * Specifies whether other crawler check is enabled. Defaults to **false**.
         */
        crawlerOther?: boolean;
        /**
         * Specifies whether the anti-crawler detection is enabled. Defaults to **false**.
         */
        crawlerScanner?: boolean;
        /**
         * Specifies whether the script tool is enabled. Defaults to **false**.
         */
        crawlerScript?: boolean;
        /**
         * Specifies whether data masking is enabled. Defaults to **false**.
         */
        dataMasking?: boolean;
        /**
         * Specifies whether false alarm masking is enabled. Defaults to **false**.
         */
        falseAlarmMasking?: boolean;
        /**
         * Specifies whether the general check in basic web protection is enabled.
         * Defaults to **false**.
         */
        generalCheck?: boolean;
        /**
         * Specifies whether the geolocation access control is enabled.
         * Defaults to **false**.
         */
        geolocationAccessControl?: boolean;
        /**
         * Specifies whether the information leakage prevention is enabled.
         * Defaults to **false**.
         */
        informationLeakagePrevention?: boolean;
        /**
         * Specifies whether the known attack source is enabled. Defaults to **false**.
         */
        knownAttackSource?: boolean;
        /**
         * Specifies whether the precise protection is enabled. Defaults to **false**.
         */
        preciseProtection?: boolean;
        /**
         * Specifies whether the web tamper protection is enabled.
         * Defaults to **false**.
         */
        webTamperProtection?: boolean;
        /**
         * Specifies whether the web shell detection in basic web protection is enabled.
         * Defaults to **false**.
         */
        webshell?: boolean;
    }

}

export namespace Workspace {
    export interface DesktopDataVolume {
        /**
         * The time that the volume was created.
         */
        createdAt: string;
        /**
         * The device location to which the volume is attached.
         */
        device: string;
        /**
         * The volume ID.
         */
        id: string;
        /**
         * Specifies the desktop name.
         * The name can contain `1` to `15` characters, only letters, digits and hyphens (-) are allowed.
         * The name must start with a letter or digit and cannot end with a hyphen.
         * Changing this will create a new resource.
         */
        name: string;
        /**
         * Specifies the size of system volume, in GB.
         * + For root volume, the valid value is range from `80` to `1,020`.
         * + For data volume, the valid value is range from `10` to `8,200`.
         */
        size: number;
        /**
         * Specifies the type of system volume.
         * The valid values are as follows:
         * + **SAS**: High I/O disk type.
         * + **SSD**: Ultra-high I/O disk type.
         */
        type: string;
    }

    export interface DesktopNic {
        /**
         * Specifies the network ID of subnet resource.
         */
        networkId: string;
    }

    export interface DesktopRootVolume {
        /**
         * The time that the volume was created.
         */
        createdAt: string;
        /**
         * The device location to which the volume is attached.
         */
        device: string;
        /**
         * The volume ID.
         */
        id: string;
        /**
         * Specifies the desktop name.
         * The name can contain `1` to `15` characters, only letters, digits and hyphens (-) are allowed.
         * The name must start with a letter or digit and cannot end with a hyphen.
         * Changing this will create a new resource.
         */
        name: string;
        /**
         * Specifies the size of system volume, in GB.
         * + For root volume, the valid value is range from `80` to `1,020`.
         * + For data volume, the valid value is range from `10` to `8,200`.
         */
        size: number;
        /**
         * Specifies the type of system volume.
         * The valid values are as follows:
         * + **SAS**: High I/O disk type.
         * + **SSD**: Ultra-high I/O disk type.
         */
        type: string;
    }

    export interface ServiceAdDomain {
        /**
         * Specifies the primary DNS IP address.
         */
        activeDnsIp?: string;
        /**
         * Specifies the IP address of primary domain controller.
         */
        activeDomainIp: string;
        /**
         * Specifies the name of primary domain controller.
         */
        activeDomainName: string;
        /**
         * Specifies the domain administrator account.
         * It must be an existing domain administrator account on the AD server.
         */
        adminAccount: string;
        /**
         * Specifies whether to delete the corresponding computer object on AD
         * while deleting the desktop.
         */
        deleteComputerObject: boolean;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
        /**
         * Specifies the account password of domain administrator.
         */
        password: string;
        /**
         * Specifies the standby DNS IP address.
         */
        standbyDnsIp?: string;
        /**
         * Specifies the IP address of the standby domain controller.
         */
        standbyDomainIp?: string;
        /**
         * Specifies the name of the standby domain controller.
         */
        standbyDomainName?: string;
    }

    export interface ServiceDesktopSecurityGroup {
        /**
         * Security group ID.
         */
        id: string;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
    }

    export interface ServiceInfrastructureSecurityGroup {
        /**
         * Security group ID.
         */
        id: string;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
    }

    export interface ServiceOtpConfigInfo {
        /**
         * Specifies the auxiliary authentication server access account.
         */
        appId?: string;
        /**
         * Specifies the authentication service access password.
         */
        appSecret?: string;
        /**
         * Specifies the authentication service access mode.
         * + **INTERNET**: Indicates internet access.
         * + **DEDICATED**: Indicates dedicated access.
         * + **SYSTEM_DEFAULT**: Indicates system default.
         */
        authServerAccessMode?: string;
        /**
         * Specifies the auxiliary authentication server address.
         */
        authUrl?: string;
        /**
         * Specifies the PEM format certificate content.
         */
        certContent?: string;
        /**
         * Specifies whether to enable auxiliary authentication.
         */
        enable: boolean;
        /**
         * Specifies the verification code receiving mode.
         * + **VMFA**: Indicates virtual MFA device.
         * + **HMFA**: Indicates hardware MFA device.
         */
        receiveMode: string;
        /**
         * Specifies authentication application object.
         * + **INTERNET**: Indicates Internet access. Optional only when ruleType is **ACCESS_MODE**.
         * + **PRIVATE**: Indicates dedicated line access. Optional only when ruleType is **ACCESS_MODE**.
         */
        rule?: string;
        /**
         * Specifies authentication application object type.
         * + **ACCESS_MODE**: Indicates access type.
         */
        ruleType?: string;
    }

}

export namespace config {
    export interface AssumeRole {
        agencyName: string;
        domainId?: string;
        domainName: string;
    }

}
