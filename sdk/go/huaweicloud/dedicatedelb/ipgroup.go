// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dedicatedelb

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Dedicated ELB Ip Group resource within HuaweiCloud.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := DedicatedElb.NewIpgroup(ctx, "basic", &DedicatedElb.IpgroupArgs{
//				Description: pulumi.String("basic example"),
//				IpLists: dedicatedelb.IpgroupIpListArray{
//					&dedicatedelb.IpgroupIpListArgs{
//						Description: pulumi.String("ECS01"),
//						Ip:          pulumi.String("192.168.10.10"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Ipgroup struct {
	pulumi.CustomResourceState

	// Human-readable description for the ip.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The enterprise project id of the ip group. Changing this
	// creates a new ip group.
	EnterpriseProjectId pulumi.StringOutput `pulumi:"enterpriseProjectId"`
	// Specifies an array of one or more ip addresses. The ipList object structure is
	// documented below.
	IpLists IpgroupIpListArrayOutput `pulumi:"ipLists"`
	// Human-readable name for the ip group.
	Name pulumi.StringOutput `pulumi:"name"`
	// The region in which to create the ip group resource. If omitted, the
	// provider-level region will be used. Changing this creates a new ip group.
	Region pulumi.StringOutput `pulumi:"region"`
}

// NewIpgroup registers a new resource with the given unique name, arguments, and options.
func NewIpgroup(ctx *pulumi.Context,
	name string, args *IpgroupArgs, opts ...pulumi.ResourceOption) (*Ipgroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IpLists == nil {
		return nil, errors.New("invalid value for required argument 'IpLists'")
	}
	var resource Ipgroup
	err := ctx.RegisterResource("huaweicloud:DedicatedElb/ipgroup:Ipgroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIpgroup gets an existing Ipgroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIpgroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IpgroupState, opts ...pulumi.ResourceOption) (*Ipgroup, error) {
	var resource Ipgroup
	err := ctx.ReadResource("huaweicloud:DedicatedElb/ipgroup:Ipgroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Ipgroup resources.
type ipgroupState struct {
	// Human-readable description for the ip.
	Description *string `pulumi:"description"`
	// The enterprise project id of the ip group. Changing this
	// creates a new ip group.
	EnterpriseProjectId *string `pulumi:"enterpriseProjectId"`
	// Specifies an array of one or more ip addresses. The ipList object structure is
	// documented below.
	IpLists []IpgroupIpList `pulumi:"ipLists"`
	// Human-readable name for the ip group.
	Name *string `pulumi:"name"`
	// The region in which to create the ip group resource. If omitted, the
	// provider-level region will be used. Changing this creates a new ip group.
	Region *string `pulumi:"region"`
}

type IpgroupState struct {
	// Human-readable description for the ip.
	Description pulumi.StringPtrInput
	// The enterprise project id of the ip group. Changing this
	// creates a new ip group.
	EnterpriseProjectId pulumi.StringPtrInput
	// Specifies an array of one or more ip addresses. The ipList object structure is
	// documented below.
	IpLists IpgroupIpListArrayInput
	// Human-readable name for the ip group.
	Name pulumi.StringPtrInput
	// The region in which to create the ip group resource. If omitted, the
	// provider-level region will be used. Changing this creates a new ip group.
	Region pulumi.StringPtrInput
}

func (IpgroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*ipgroupState)(nil)).Elem()
}

type ipgroupArgs struct {
	// Human-readable description for the ip.
	Description *string `pulumi:"description"`
	// The enterprise project id of the ip group. Changing this
	// creates a new ip group.
	EnterpriseProjectId *string `pulumi:"enterpriseProjectId"`
	// Specifies an array of one or more ip addresses. The ipList object structure is
	// documented below.
	IpLists []IpgroupIpList `pulumi:"ipLists"`
	// Human-readable name for the ip group.
	Name *string `pulumi:"name"`
	// The region in which to create the ip group resource. If omitted, the
	// provider-level region will be used. Changing this creates a new ip group.
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a Ipgroup resource.
type IpgroupArgs struct {
	// Human-readable description for the ip.
	Description pulumi.StringPtrInput
	// The enterprise project id of the ip group. Changing this
	// creates a new ip group.
	EnterpriseProjectId pulumi.StringPtrInput
	// Specifies an array of one or more ip addresses. The ipList object structure is
	// documented below.
	IpLists IpgroupIpListArrayInput
	// Human-readable name for the ip group.
	Name pulumi.StringPtrInput
	// The region in which to create the ip group resource. If omitted, the
	// provider-level region will be used. Changing this creates a new ip group.
	Region pulumi.StringPtrInput
}

func (IpgroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ipgroupArgs)(nil)).Elem()
}

type IpgroupInput interface {
	pulumi.Input

	ToIpgroupOutput() IpgroupOutput
	ToIpgroupOutputWithContext(ctx context.Context) IpgroupOutput
}

func (*Ipgroup) ElementType() reflect.Type {
	return reflect.TypeOf((**Ipgroup)(nil)).Elem()
}

func (i *Ipgroup) ToIpgroupOutput() IpgroupOutput {
	return i.ToIpgroupOutputWithContext(context.Background())
}

func (i *Ipgroup) ToIpgroupOutputWithContext(ctx context.Context) IpgroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpgroupOutput)
}

// IpgroupArrayInput is an input type that accepts IpgroupArray and IpgroupArrayOutput values.
// You can construct a concrete instance of `IpgroupArrayInput` via:
//
//	IpgroupArray{ IpgroupArgs{...} }
type IpgroupArrayInput interface {
	pulumi.Input

	ToIpgroupArrayOutput() IpgroupArrayOutput
	ToIpgroupArrayOutputWithContext(context.Context) IpgroupArrayOutput
}

type IpgroupArray []IpgroupInput

func (IpgroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ipgroup)(nil)).Elem()
}

func (i IpgroupArray) ToIpgroupArrayOutput() IpgroupArrayOutput {
	return i.ToIpgroupArrayOutputWithContext(context.Background())
}

func (i IpgroupArray) ToIpgroupArrayOutputWithContext(ctx context.Context) IpgroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpgroupArrayOutput)
}

// IpgroupMapInput is an input type that accepts IpgroupMap and IpgroupMapOutput values.
// You can construct a concrete instance of `IpgroupMapInput` via:
//
//	IpgroupMap{ "key": IpgroupArgs{...} }
type IpgroupMapInput interface {
	pulumi.Input

	ToIpgroupMapOutput() IpgroupMapOutput
	ToIpgroupMapOutputWithContext(context.Context) IpgroupMapOutput
}

type IpgroupMap map[string]IpgroupInput

func (IpgroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ipgroup)(nil)).Elem()
}

func (i IpgroupMap) ToIpgroupMapOutput() IpgroupMapOutput {
	return i.ToIpgroupMapOutputWithContext(context.Background())
}

func (i IpgroupMap) ToIpgroupMapOutputWithContext(ctx context.Context) IpgroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpgroupMapOutput)
}

type IpgroupOutput struct{ *pulumi.OutputState }

func (IpgroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Ipgroup)(nil)).Elem()
}

func (o IpgroupOutput) ToIpgroupOutput() IpgroupOutput {
	return o
}

func (o IpgroupOutput) ToIpgroupOutputWithContext(ctx context.Context) IpgroupOutput {
	return o
}

// Human-readable description for the ip.
func (o IpgroupOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ipgroup) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The enterprise project id of the ip group. Changing this
// creates a new ip group.
func (o IpgroupOutput) EnterpriseProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Ipgroup) pulumi.StringOutput { return v.EnterpriseProjectId }).(pulumi.StringOutput)
}

// Specifies an array of one or more ip addresses. The ipList object structure is
// documented below.
func (o IpgroupOutput) IpLists() IpgroupIpListArrayOutput {
	return o.ApplyT(func(v *Ipgroup) IpgroupIpListArrayOutput { return v.IpLists }).(IpgroupIpListArrayOutput)
}

// Human-readable name for the ip group.
func (o IpgroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Ipgroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The region in which to create the ip group resource. If omitted, the
// provider-level region will be used. Changing this creates a new ip group.
func (o IpgroupOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Ipgroup) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type IpgroupArrayOutput struct{ *pulumi.OutputState }

func (IpgroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ipgroup)(nil)).Elem()
}

func (o IpgroupArrayOutput) ToIpgroupArrayOutput() IpgroupArrayOutput {
	return o
}

func (o IpgroupArrayOutput) ToIpgroupArrayOutputWithContext(ctx context.Context) IpgroupArrayOutput {
	return o
}

func (o IpgroupArrayOutput) Index(i pulumi.IntInput) IpgroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Ipgroup {
		return vs[0].([]*Ipgroup)[vs[1].(int)]
	}).(IpgroupOutput)
}

type IpgroupMapOutput struct{ *pulumi.OutputState }

func (IpgroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ipgroup)(nil)).Elem()
}

func (o IpgroupMapOutput) ToIpgroupMapOutput() IpgroupMapOutput {
	return o
}

func (o IpgroupMapOutput) ToIpgroupMapOutputWithContext(ctx context.Context) IpgroupMapOutput {
	return o
}

func (o IpgroupMapOutput) MapIndex(k pulumi.StringInput) IpgroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Ipgroup {
		return vs[0].(map[string]*Ipgroup)[vs[1].(string)]
	}).(IpgroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IpgroupInput)(nil)).Elem(), &Ipgroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpgroupArrayInput)(nil)).Elem(), IpgroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpgroupMapInput)(nil)).Elem(), IpgroupMap{})
	pulumi.RegisterOutputType(IpgroupOutput{})
	pulumi.RegisterOutputType(IpgroupArrayOutput{})
	pulumi.RegisterOutputType(IpgroupMapOutput{})
}
