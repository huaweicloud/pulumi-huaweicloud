// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vpc

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Security Group Rule resource within HuaweiCloud.
//
// ## Example Usage
// ### Create an ingress rule that opens TCP port 8080 with port range parameters
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Vpc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			securityGroupId := cfg.RequireObject("securityGroupId")
//			_, err := Vpc.NewSecgroupRule(ctx, "test", &Vpc.SecgroupRuleArgs{
//				SecurityGroupId: pulumi.Any(securityGroupId),
//				Direction:       pulumi.String("ingress"),
//				Ethertype:       pulumi.String("IPv4"),
//				Protocol:        pulumi.String("tcp"),
//				PortRangeMin:    pulumi.Int(8080),
//				PortRangeMax:    pulumi.Int(8080),
//				RemoteIpPrefix:  pulumi.String("0.0.0.0/0"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Create an ingress rule that enable the remote address group and open some TCP ports
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Vpc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			groupName := cfg.RequireObject("groupName")
//			securityGroupId := cfg.RequireObject("securityGroupId")
//			testAddressGroup, err := Vpc.NewAddressGroup(ctx, "testAddressGroup", &Vpc.AddressGroupArgs{
//				Addresses: pulumi.StringArray{
//					pulumi.String("192.168.10.12"),
//					pulumi.String("192.168.11.0-192.168.11.240"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = Vpc.NewSecgroupRule(ctx, "testSecgroupRule", &Vpc.SecgroupRuleArgs{
//				SecurityGroupId:      pulumi.Any(securityGroupId),
//				Direction:            pulumi.String("ingress"),
//				Action:               pulumi.String("allow"),
//				Ethertype:            pulumi.String("IPv4"),
//				Ports:                pulumi.String("80,500,600-800"),
//				Protocol:             pulumi.String("tcp"),
//				Priority:             pulumi.Int(5),
//				RemoteAddressGroupId: testAddressGroup.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Security Group Rules can be imported using the `id`, e.g.
//
// ```sh
//
//	$ pulumi import huaweicloud:Vpc/secgroupRule:SecgroupRule secgroup_rule_1 aeb68ee3-6e9d-4256-955c-9584a6212745
//
// ```
type SecgroupRule struct {
	pulumi.CustomResourceState

	// Specifies the effective policy. The valid values are **allow** and **deny**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Action pulumi.StringOutput `pulumi:"action"`
	// Specifies the supplementary information about the networking security
	// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
	// Changing this creates a new security group rule.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Specifies the direction of the rule, valid values are **ingress** or
	// **egress**. Changing this creates a new security group rule.
	Direction pulumi.StringOutput `pulumi:"direction"`
	// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
	// Changing this creates a new security group rule.
	Ethertype pulumi.StringOutput `pulumi:"ethertype"`
	// Specifies the higher part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMax pulumi.IntOutput `pulumi:"portRangeMax"`
	// Specifies the lower part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMin pulumi.IntOutput `pulumi:"portRangeMin"`
	// Specifies the allowed port value range, which supports single port (80),
	// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
	// Changing this creates a new security group rule.
	Ports pulumi.StringOutput `pulumi:"ports"`
	// Specifies the priority number.
	// The valid value is range from **1** to **100**. The default value is **1**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Priority pulumi.IntOutput `pulumi:"priority"`
	// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
	// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
	// This is required if you want to specify a port range. Changing this creates a new security group rule.
	Protocol pulumi.StringOutput `pulumi:"protocol"`
	// Specifies the region in which to create the security group rule resource. If
	// omitted, the provider-level region will be used. Changing this creates a new security group rule.
	Region pulumi.StringOutput `pulumi:"region"`
	// Specifies the remote address group ID.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	RemoteAddressGroupId pulumi.StringOutput `pulumi:"remoteAddressGroupId"`
	// Specifies the remote group ID. Changing this creates a new security
	// group rule.
	RemoteGroupId pulumi.StringOutput `pulumi:"remoteGroupId"`
	// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
	// 192.168.0.0/16). Changing this creates a new security group rule.
	RemoteIpPrefix pulumi.StringOutput `pulumi:"remoteIpPrefix"`
	// Specifies the security group ID the rule should belong to. Changing
	// this creates a new security group rule.
	SecurityGroupId pulumi.StringOutput `pulumi:"securityGroupId"`
}

// NewSecgroupRule registers a new resource with the given unique name, arguments, and options.
func NewSecgroupRule(ctx *pulumi.Context,
	name string, args *SecgroupRuleArgs, opts ...pulumi.ResourceOption) (*SecgroupRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Direction == nil {
		return nil, errors.New("invalid value for required argument 'Direction'")
	}
	if args.Ethertype == nil {
		return nil, errors.New("invalid value for required argument 'Ethertype'")
	}
	if args.SecurityGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SecurityGroupId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource SecgroupRule
	err := ctx.RegisterResource("huaweicloud:Vpc/secgroupRule:SecgroupRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSecgroupRule gets an existing SecgroupRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSecgroupRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SecgroupRuleState, opts ...pulumi.ResourceOption) (*SecgroupRule, error) {
	var resource SecgroupRule
	err := ctx.ReadResource("huaweicloud:Vpc/secgroupRule:SecgroupRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SecgroupRule resources.
type secgroupRuleState struct {
	// Specifies the effective policy. The valid values are **allow** and **deny**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Action *string `pulumi:"action"`
	// Specifies the supplementary information about the networking security
	// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
	// Changing this creates a new security group rule.
	Description *string `pulumi:"description"`
	// Specifies the direction of the rule, valid values are **ingress** or
	// **egress**. Changing this creates a new security group rule.
	Direction *string `pulumi:"direction"`
	// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
	// Changing this creates a new security group rule.
	Ethertype *string `pulumi:"ethertype"`
	// Specifies the higher part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMax *int `pulumi:"portRangeMax"`
	// Specifies the lower part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMin *int `pulumi:"portRangeMin"`
	// Specifies the allowed port value range, which supports single port (80),
	// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
	// Changing this creates a new security group rule.
	Ports *string `pulumi:"ports"`
	// Specifies the priority number.
	// The valid value is range from **1** to **100**. The default value is **1**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Priority *int `pulumi:"priority"`
	// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
	// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
	// This is required if you want to specify a port range. Changing this creates a new security group rule.
	Protocol *string `pulumi:"protocol"`
	// Specifies the region in which to create the security group rule resource. If
	// omitted, the provider-level region will be used. Changing this creates a new security group rule.
	Region *string `pulumi:"region"`
	// Specifies the remote address group ID.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	RemoteAddressGroupId *string `pulumi:"remoteAddressGroupId"`
	// Specifies the remote group ID. Changing this creates a new security
	// group rule.
	RemoteGroupId *string `pulumi:"remoteGroupId"`
	// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
	// 192.168.0.0/16). Changing this creates a new security group rule.
	RemoteIpPrefix *string `pulumi:"remoteIpPrefix"`
	// Specifies the security group ID the rule should belong to. Changing
	// this creates a new security group rule.
	SecurityGroupId *string `pulumi:"securityGroupId"`
}

type SecgroupRuleState struct {
	// Specifies the effective policy. The valid values are **allow** and **deny**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Action pulumi.StringPtrInput
	// Specifies the supplementary information about the networking security
	// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
	// Changing this creates a new security group rule.
	Description pulumi.StringPtrInput
	// Specifies the direction of the rule, valid values are **ingress** or
	// **egress**. Changing this creates a new security group rule.
	Direction pulumi.StringPtrInput
	// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
	// Changing this creates a new security group rule.
	Ethertype pulumi.StringPtrInput
	// Specifies the higher part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMax pulumi.IntPtrInput
	// Specifies the lower part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMin pulumi.IntPtrInput
	// Specifies the allowed port value range, which supports single port (80),
	// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
	// Changing this creates a new security group rule.
	Ports pulumi.StringPtrInput
	// Specifies the priority number.
	// The valid value is range from **1** to **100**. The default value is **1**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Priority pulumi.IntPtrInput
	// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
	// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
	// This is required if you want to specify a port range. Changing this creates a new security group rule.
	Protocol pulumi.StringPtrInput
	// Specifies the region in which to create the security group rule resource. If
	// omitted, the provider-level region will be used. Changing this creates a new security group rule.
	Region pulumi.StringPtrInput
	// Specifies the remote address group ID.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	RemoteAddressGroupId pulumi.StringPtrInput
	// Specifies the remote group ID. Changing this creates a new security
	// group rule.
	RemoteGroupId pulumi.StringPtrInput
	// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
	// 192.168.0.0/16). Changing this creates a new security group rule.
	RemoteIpPrefix pulumi.StringPtrInput
	// Specifies the security group ID the rule should belong to. Changing
	// this creates a new security group rule.
	SecurityGroupId pulumi.StringPtrInput
}

func (SecgroupRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*secgroupRuleState)(nil)).Elem()
}

type secgroupRuleArgs struct {
	// Specifies the effective policy. The valid values are **allow** and **deny**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Action *string `pulumi:"action"`
	// Specifies the supplementary information about the networking security
	// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
	// Changing this creates a new security group rule.
	Description *string `pulumi:"description"`
	// Specifies the direction of the rule, valid values are **ingress** or
	// **egress**. Changing this creates a new security group rule.
	Direction string `pulumi:"direction"`
	// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
	// Changing this creates a new security group rule.
	Ethertype string `pulumi:"ethertype"`
	// Specifies the higher part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMax *int `pulumi:"portRangeMax"`
	// Specifies the lower part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMin *int `pulumi:"portRangeMin"`
	// Specifies the allowed port value range, which supports single port (80),
	// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
	// Changing this creates a new security group rule.
	Ports *string `pulumi:"ports"`
	// Specifies the priority number.
	// The valid value is range from **1** to **100**. The default value is **1**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Priority *int `pulumi:"priority"`
	// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
	// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
	// This is required if you want to specify a port range. Changing this creates a new security group rule.
	Protocol *string `pulumi:"protocol"`
	// Specifies the region in which to create the security group rule resource. If
	// omitted, the provider-level region will be used. Changing this creates a new security group rule.
	Region *string `pulumi:"region"`
	// Specifies the remote address group ID.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	RemoteAddressGroupId *string `pulumi:"remoteAddressGroupId"`
	// Specifies the remote group ID. Changing this creates a new security
	// group rule.
	RemoteGroupId *string `pulumi:"remoteGroupId"`
	// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
	// 192.168.0.0/16). Changing this creates a new security group rule.
	RemoteIpPrefix *string `pulumi:"remoteIpPrefix"`
	// Specifies the security group ID the rule should belong to. Changing
	// this creates a new security group rule.
	SecurityGroupId string `pulumi:"securityGroupId"`
}

// The set of arguments for constructing a SecgroupRule resource.
type SecgroupRuleArgs struct {
	// Specifies the effective policy. The valid values are **allow** and **deny**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Action pulumi.StringPtrInput
	// Specifies the supplementary information about the networking security
	// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
	// Changing this creates a new security group rule.
	Description pulumi.StringPtrInput
	// Specifies the direction of the rule, valid values are **ingress** or
	// **egress**. Changing this creates a new security group rule.
	Direction pulumi.StringInput
	// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
	// Changing this creates a new security group rule.
	Ethertype pulumi.StringInput
	// Specifies the higher part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMax pulumi.IntPtrInput
	// Specifies the lower part of the allowed port range, valid integer value
	// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
	// This parameter and `ports` are alternative.
	PortRangeMin pulumi.IntPtrInput
	// Specifies the allowed port value range, which supports single port (80),
	// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
	// Changing this creates a new security group rule.
	Ports pulumi.StringPtrInput
	// Specifies the priority number.
	// The valid value is range from **1** to **100**. The default value is **1**.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	Priority pulumi.IntPtrInput
	// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
	// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
	// This is required if you want to specify a port range. Changing this creates a new security group rule.
	Protocol pulumi.StringPtrInput
	// Specifies the region in which to create the security group rule resource. If
	// omitted, the provider-level region will be used. Changing this creates a new security group rule.
	Region pulumi.StringPtrInput
	// Specifies the remote address group ID.
	// This parameter is not used with `portRangeMin` and `portRangeMax`.
	// Changing this creates a new security group rule.
	RemoteAddressGroupId pulumi.StringPtrInput
	// Specifies the remote group ID. Changing this creates a new security
	// group rule.
	RemoteGroupId pulumi.StringPtrInput
	// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
	// 192.168.0.0/16). Changing this creates a new security group rule.
	RemoteIpPrefix pulumi.StringPtrInput
	// Specifies the security group ID the rule should belong to. Changing
	// this creates a new security group rule.
	SecurityGroupId pulumi.StringInput
}

func (SecgroupRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*secgroupRuleArgs)(nil)).Elem()
}

type SecgroupRuleInput interface {
	pulumi.Input

	ToSecgroupRuleOutput() SecgroupRuleOutput
	ToSecgroupRuleOutputWithContext(ctx context.Context) SecgroupRuleOutput
}

func (*SecgroupRule) ElementType() reflect.Type {
	return reflect.TypeOf((**SecgroupRule)(nil)).Elem()
}

func (i *SecgroupRule) ToSecgroupRuleOutput() SecgroupRuleOutput {
	return i.ToSecgroupRuleOutputWithContext(context.Background())
}

func (i *SecgroupRule) ToSecgroupRuleOutputWithContext(ctx context.Context) SecgroupRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecgroupRuleOutput)
}

// SecgroupRuleArrayInput is an input type that accepts SecgroupRuleArray and SecgroupRuleArrayOutput values.
// You can construct a concrete instance of `SecgroupRuleArrayInput` via:
//
//	SecgroupRuleArray{ SecgroupRuleArgs{...} }
type SecgroupRuleArrayInput interface {
	pulumi.Input

	ToSecgroupRuleArrayOutput() SecgroupRuleArrayOutput
	ToSecgroupRuleArrayOutputWithContext(context.Context) SecgroupRuleArrayOutput
}

type SecgroupRuleArray []SecgroupRuleInput

func (SecgroupRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecgroupRule)(nil)).Elem()
}

func (i SecgroupRuleArray) ToSecgroupRuleArrayOutput() SecgroupRuleArrayOutput {
	return i.ToSecgroupRuleArrayOutputWithContext(context.Background())
}

func (i SecgroupRuleArray) ToSecgroupRuleArrayOutputWithContext(ctx context.Context) SecgroupRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecgroupRuleArrayOutput)
}

// SecgroupRuleMapInput is an input type that accepts SecgroupRuleMap and SecgroupRuleMapOutput values.
// You can construct a concrete instance of `SecgroupRuleMapInput` via:
//
//	SecgroupRuleMap{ "key": SecgroupRuleArgs{...} }
type SecgroupRuleMapInput interface {
	pulumi.Input

	ToSecgroupRuleMapOutput() SecgroupRuleMapOutput
	ToSecgroupRuleMapOutputWithContext(context.Context) SecgroupRuleMapOutput
}

type SecgroupRuleMap map[string]SecgroupRuleInput

func (SecgroupRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecgroupRule)(nil)).Elem()
}

func (i SecgroupRuleMap) ToSecgroupRuleMapOutput() SecgroupRuleMapOutput {
	return i.ToSecgroupRuleMapOutputWithContext(context.Background())
}

func (i SecgroupRuleMap) ToSecgroupRuleMapOutputWithContext(ctx context.Context) SecgroupRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecgroupRuleMapOutput)
}

type SecgroupRuleOutput struct{ *pulumi.OutputState }

func (SecgroupRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecgroupRule)(nil)).Elem()
}

func (o SecgroupRuleOutput) ToSecgroupRuleOutput() SecgroupRuleOutput {
	return o
}

func (o SecgroupRuleOutput) ToSecgroupRuleOutputWithContext(ctx context.Context) SecgroupRuleOutput {
	return o
}

// Specifies the effective policy. The valid values are **allow** and **deny**.
// This parameter is not used with `portRangeMin` and `portRangeMax`.
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// Specifies the supplementary information about the networking security
// group rule. This parameter can contain a maximum of 255 characters and cannot contain angle brackets (< or >).
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Specifies the direction of the rule, valid values are **ingress** or
// **egress**. Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Direction }).(pulumi.StringOutput)
}

// Specifies the layer 3 protocol type, valid values are **IPv4** or **IPv6**.
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Ethertype() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Ethertype }).(pulumi.StringOutput)
}

// Specifies the higher part of the allowed port range, valid integer value
// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
// This parameter and `ports` are alternative.
func (o SecgroupRuleOutput) PortRangeMax() pulumi.IntOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.IntOutput { return v.PortRangeMax }).(pulumi.IntOutput)
}

// Specifies the lower part of the allowed port range, valid integer value
// needs to be between `1` and `65,535`. Changing this creates a new security group rule.
// This parameter and `ports` are alternative.
func (o SecgroupRuleOutput) PortRangeMin() pulumi.IntOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.IntOutput { return v.PortRangeMin }).(pulumi.IntOutput)
}

// Specifies the allowed port value range, which supports single port (80),
// continuous port (1-30) and discontinous port (22, 3389, 80) The valid port values is range form `1` to `65,535`.
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Ports() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Ports }).(pulumi.StringOutput)
}

// Specifies the priority number.
// The valid value is range from **1** to **100**. The default value is **1**.
// This parameter is not used with `portRangeMin` and `portRangeMax`.
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.IntOutput { return v.Priority }).(pulumi.IntOutput)
}

// Specifies the layer 4 protocol type, valid values are **tcp**, **udp**,
// **icmp** and **icmpv6**. If omitted, the protocol means that all protocols are supported.
// This is required if you want to specify a port range. Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Protocol }).(pulumi.StringOutput)
}

// Specifies the region in which to create the security group rule resource. If
// omitted, the provider-level region will be used. Changing this creates a new security group rule.
func (o SecgroupRuleOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Specifies the remote address group ID.
// This parameter is not used with `portRangeMin` and `portRangeMax`.
// Changing this creates a new security group rule.
func (o SecgroupRuleOutput) RemoteAddressGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.RemoteAddressGroupId }).(pulumi.StringOutput)
}

// Specifies the remote group ID. Changing this creates a new security
// group rule.
func (o SecgroupRuleOutput) RemoteGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.RemoteGroupId }).(pulumi.StringOutput)
}

// Specifies the remote CIDR, the value needs to be a valid CIDR (i.e.
// 192.168.0.0/16). Changing this creates a new security group rule.
func (o SecgroupRuleOutput) RemoteIpPrefix() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.RemoteIpPrefix }).(pulumi.StringOutput)
}

// Specifies the security group ID the rule should belong to. Changing
// this creates a new security group rule.
func (o SecgroupRuleOutput) SecurityGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *SecgroupRule) pulumi.StringOutput { return v.SecurityGroupId }).(pulumi.StringOutput)
}

type SecgroupRuleArrayOutput struct{ *pulumi.OutputState }

func (SecgroupRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecgroupRule)(nil)).Elem()
}

func (o SecgroupRuleArrayOutput) ToSecgroupRuleArrayOutput() SecgroupRuleArrayOutput {
	return o
}

func (o SecgroupRuleArrayOutput) ToSecgroupRuleArrayOutputWithContext(ctx context.Context) SecgroupRuleArrayOutput {
	return o
}

func (o SecgroupRuleArrayOutput) Index(i pulumi.IntInput) SecgroupRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SecgroupRule {
		return vs[0].([]*SecgroupRule)[vs[1].(int)]
	}).(SecgroupRuleOutput)
}

type SecgroupRuleMapOutput struct{ *pulumi.OutputState }

func (SecgroupRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecgroupRule)(nil)).Elem()
}

func (o SecgroupRuleMapOutput) ToSecgroupRuleMapOutput() SecgroupRuleMapOutput {
	return o
}

func (o SecgroupRuleMapOutput) ToSecgroupRuleMapOutputWithContext(ctx context.Context) SecgroupRuleMapOutput {
	return o
}

func (o SecgroupRuleMapOutput) MapIndex(k pulumi.StringInput) SecgroupRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SecgroupRule {
		return vs[0].(map[string]*SecgroupRule)[vs[1].(string)]
	}).(SecgroupRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SecgroupRuleInput)(nil)).Elem(), &SecgroupRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecgroupRuleArrayInput)(nil)).Elem(), SecgroupRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecgroupRuleMapInput)(nil)).Elem(), SecgroupRuleMap{})
	pulumi.RegisterOutputType(SecgroupRuleOutput{})
	pulumi.RegisterOutputType(SecgroupRuleArrayOutput{})
	pulumi.RegisterOutputType(SecgroupRuleMapOutput{})
}
